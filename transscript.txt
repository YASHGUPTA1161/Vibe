imagine building your next startup with nothing more than a sentence this is Vibe an AI powered app builder that makes that possible and in this course you're going to learn how to build it yourself let's try it out by entering a simple prompt and hitting submit what you're about to see next is something you'd normally expect from high-end tools like Lovable Replet or Bolt but in this tutorial it is something you will learn how to build the result a fully functional Netflix style homepage generated entirely by AI we can explore the full app right here in the preview and everything just works the layout the interactions even models and favorites it doesn't just look like a Netflix style homepage it behaves like one and just above the preview there's a live URL you can open it in a new tab share it with others or test the app in a real browser environment and when you're ready to see exactly how it works simply switch to the code tab and explore every component utility and file that was created but how is this even possible and how does it all work let's break it down what you're looking at here is the inest developer server it shows a background task that kicked off as soon as we submitted our prompt the task itself is handled by an AI coding agent the agent has access to various tools used to build the app it can run commands in the terminal create read or even update files and its goal is to create a fully functional Nex.js JS application tailored to the user's request you can click into any step to see exactly what happened and when which packages were installed what commands were run and which files were created or modified finally the agent spins up a real development environment using an E2B sandbox a secure container that runs your app and exposes a live URL so you can preview and interact with it just like any deployed project and finally the finished app is saved to our Postgress database powered by Neon let's head back to our Netflix project for a second and just above the message form you will see that we have a message two credits remaining that's right each generation uses a credit so let's see what else we can build with this app and find out what happens when we spend our last point this time I will go with something a bit more interactive like a conbon board I can drag around and just like our previous project this one was created flawlessly i can drag and drop cards and even create new ones everything just works and just like our previous project I can visit the file explorer and see every line of code that was generated notice how I've got one more credit left let's go ahead and spend it right beneath our homepage we can find all of our previously generated apps or vibes as we are going to call them let's click into the first one just to confirm it is still live and working but now let's use our final credit to build something new this time I'm going to build an admin dashboard and I'm hoping to see some status cards and a pageionated table and here it is a sleek looking admin dashboard with status cards sidebar and a pageentated searchable data table notice how I have no more credits left meaning that when I try to generate a new prompt I'm going to get an error and it is time to upgrade in order to get more credits it's time to upgrade billing is powered by Clerk that's right just like their out system the developer experience is incredibly smooth no web hooks no complicated code no confusing Stripe setup everything works out of the box watch how quickly I can upgrade my account that's it i have upgraded and I am now on the premium plan and I can see my status reflected immediately in the user settings and as a developer you can now track your monthly recurring revenue on the clerk dashboard page after a successful upgrade you will see that you have a 100 credits remaining and beneath them the exact time they will reset and by the way dark mode is fully supported in this project you can switch it on from the project's settings bar and it will immediately update the entire app's UI including the code explorer and the landing page this isn't just a coding tutorial we'll also be following a proper Git workflow throughout the project this will include creating commits new branches and real pull requests every pull request will be reviewed by Code Rabbit our AI reviewer that provides feedback on everything from logic issues to best practices all actionable insights and critical mistakes will be flagged automatically drastically improving our code quality let's quickly go over the text stack we'll be using next.js 15 with React 19 make our framework with support for serverside rendering and server components trpc combined with fanstack query will ensure our app meets full stack type safety prisma OM with postgress provided by Neon will be our database solution tailwind version 4 for styling along with chats and UI for accessible and reusable components authentication and billing will be done by clerk while background jobs and agent tooling and agent networks will be done by ingest e2b for executing AI generated code in secure cloud sandboxes docker for generating custom sandbox templates open AAI anthropic or Grock depending on the model you choose to power your AI agents code Rabbit for AI powered code reviews and of course we'll deploy everything to production when it's finished and now without further ado let's get started in this chapter we're going to set up our Nex.js project confirm our environment get familiar with the file structure and versions of our project and set up our component library and finally create a GitHub repository for this project so let's start by setting up our Next.js project if you head to the documentation page of Nex.js and click on the installation tab you will find the system requirements the minimum Node.js version is 18.18 and these are the supported operating systems so first things first let's confirm we have a proper node version installed you can go inside of your terminal and you can run node-v and while you're here also confirm these two commands you should not be getting errors for any of these three if you get errors for any of them it is time to upgrade or reinstall your node you can do that by visiting the official Node.js website if you have a version which is lower than 18.18 you're going to have to upgrade as well keep in mind that if you are or Linux or some different operating system your versions of npm and npx may be different but as long as you're not getting any errors and you have a correct node version you are good to go so now let's go ahead and let's actually install our Nex.js application seeing here we have an automatic installation CLI command so I'm going to go ahead and copy it but I'm not going to run it immediately i will slightly modify it instead of using at latest I'm going to write the exact version 15.3.4 so instead of latest I'm going to do 1534 why am I doing this and do you need to do this the reason I'm doing this is because I don't know when my viewers will come across this video this might be a month from now 6 months from now or a year from now and depending on that there might be a lot of new breaking changes introduced in the latest versions so if you want to you can use the latest version that's perfectly fine but if you want to avoid any breaking changes meaning that you're watching this video far into the future like 6 months from now or a year from now and you just want to code along I'm giving you the option to use the exact version that I had at the time right so this is the latest version at the time of me making this tutorial so I'm going to go ahead and use this version i'm going to create a project called a vibe i'm going to select yes for TypeScript yes for slint yes for Tailwind and I'm also going to select yes for the source directory be careful here because I think that the default value might be no so use the arrow keys to select yes and press enter same thing for the app router make sure you select yes here yes for Turboac but only for nextdev in my case and I'm not going to customize the import alias so this will be the only no option for me and now let's just wait for our dependencies to install after our dependencies have installed you're going to see a success message like this what you have to do next is you have to enter this directory with your terminal so let's go ahead and do change directory vibe like this and once you're inside of here you can run the ls command to see a list of files inside before we run this project I want to set up our IDE the place where we are going to write some code for me that's going to be VS Code so I'm going to go ahead and select open and I will select my new Vibe project inside of here you should be seeing a similar or the exact same file and folder structure so first let's confirm our versions i'm going to go inside of package JSON you can see that I have Turboac here because I selected TurboAC yes you can see that I have React 19 you can see that I have next 15.3.4 you can see that I use Tailwind version 4 and TypeScript version 5 and these are probably the most important versions for this project of course if you are watching this into the future and you want to use whatever are the newest versions for you you absolutely can you don't have to worry about this then I'm simply showing this for those people who want to use the exact same versions as me great so about the config files I have a tsconfig a post CSS config next config and an esllet config you might notice that Tailwind config is missing that is because we are using Tailwind version 4 which no longer introduces a Tailwind config inside of the source folder I have an app folder source folder is quite important make sure you have it so inside of the app folder here I have a favicon globals layout and page you can quickly visit them if you want to and inside of my public folder you can see that I have some SVGs here great so now let's go ahead and let's install Shats CNN UI into our project first of all let's mark these as completed now let's go ahead and set up Shatsen UI so by visiting chats UI and going into the introduction you can see that even though we are going to use it as our component library is actually not a component library instead it is how you build a component library it is basically a collection of open code components with composition pattern that you can simply add to your project so let's go ahead and go inside of the installation and select next.js let's pick our package manager here let's copy the command make sure you are doing this inside of your project so again you can run ls to confirm you are inside and once again instead of using latest I'm going to go ahead and show you which version I have so for me that is 2.7.0 so let's go ahead and run the command my apologies instead of latest 2.7.0 in it if you get prompted to install you can select yes i'm going to be using neutral for my color here and there we go just like that we have initialized chats UI into our project here you can see how it verified the framework next.js and it valid validated the Tailwind config it found version 4 perfect you can see that it also installed some dependencies modified our global CSS and created one file so we can now go ahead and visit all of those things here you can see that I now have CLSX Lucid React and I believe also Tailwind Animate CSS i think that's the new package that came from uh Shotsy UI and Tailwind merge is new as well I believe great so those are the packages that SHAT CN CLI added now let's go ahead and look at our lib file utils inside of the source folder in here we have a CN function which we're going to use throughout our project whenever we need to safely uh merge or add dynamic Tailwind classes and it also modified the globals.css by adding a bunch of variables which we can now use uh to build our project theme it also added dark mode rules as well perfect so now let's go ahead and let's learn how to add a component so for example let's go inside of our components here let's select a button component and let's go ahead and select CLI option for the installation and let's go ahead and copy this to clipboard and I'm going to use 2.7.0 add button and just like that we have added a component to our project if you get prompted with the option to use legacy peer depths or force uh you can select any of those two options but if you're using the same versions as me I'm pretty sure uh it will you will have the exact same experience it should just work straight out of the box but if you get any errors or any uh decisions to make you can select legacy peer depths if you don't have that choice perfectly fine you can just continue great so now you can go inside of source components UI and you can find button.tsx and you can see that it's using some of these new packages that it added before and it also uses the CN which it initialized before so the cool thing about SAT CNUI components is that they are open code meaning that it's not bundled in a Node.js package it is actually available for us to modify and build as much as we want so now let's go ahead and let's run our project so npm rundev you will see d- turbo pack here and then you can open the localhost 3000 to see your app now let's go ahead and let's modify source app page tsx so we can see some changes here go inside of page here and let's learn how to actually write a page component so I'm going to remove everything and the important thing here is that your components need to be uh using default export right so the name doesn't matter this can be called home or it can be called page i like to use the page convention and now in here I can just write hello world and once I save you will see the change hello world if this is your first time using Visual Studio Code if you have a little uh circle here it means the file is unsaved so just hit save and then it will be updated and here's what happens if you don't do a default export it will not be able to find the page so that's why default expert is important here but the name itself does not matter but of course you can't use some reserved uh things right you should not be able to call this error right because error is already reserved great so now let's go ahead and let's test out our tailwind so I'm going to go ahead and add a class name here text bold my apologies it is font bold i forgot there we go and now my font is bold but let's try changing the color text rows 500 and now I've changed the color you might notice that I have this little color icon and when I hover over my classes I can see the inner CSS it is applying if you want to see the exact same thing you can go ahead and install Tailwind CSS IntelliSense package it will be quite useful in this tutorial great now let's go ahead and let's remove this and let's add a button from components UI button let's go ahead and give it some children and let's close it and just like that you have a button here and now I'm going to show you a quick way you can enter the button inner code you can use command or control and then click here and that will take you to the actual source components UI button right so it will be quite useful for you to learn this shortcut because I will use it quite often in the tutorial so you don't get confused how I got there that fast another shortcut you should learn is command space my apologies command P or control P depending if you are on Windows and then once you open this bar you can search for button and press like this i'm going to be using this quite extensively in the tutorial so it would be good that you learn this as well so once you're inside of the button here you can see that we can have some variants like destructive let's go ahead and try it out once you add it you can see that the destructive variant is now uh active but what happens if you go inside of the code and change this to danger you can see how it immediately breaks and we have to change this to danger so what we've just done is we've changed the inner code of the button to our liking instead of destructive it is now called danger so let's bring that back now and let's try creating a new one so new and let's go ahead and try something fun like background purple 500 text white and if you go ahead and try now you will see that you have the new option and just like that you created your own variant so that's the power of Shatsen UI and now that we confirm the button is working let's go ahead and let's add all of the other components the reason I want to add all other components is so that it's easier to follow along in this tutorial you obviously don't need all of them and you can clean them up later but it's just going to be easier for us to have all of them at our disposal and then simply choose which ones we want to use instead of having to install and wait so I'm going to go ahead and shut down my app and I'm going to run npxhat cnui 2.7.0-all and this will add every single component to our project and you can see how it added all of these components but it skipped the button because it already exists perfect so now we can go ahead and inside of your source components UI you will see all of these various components here you now probably have a lot of unsaved files here my apologies not unsaved uncommitted files uh we're going to explore what that means in a second so let's go ahead now and let's do the last thing that we need which is create a GitHub repository so I'm going to go ahead and go inside of my GitHub and I selected new repository here now just a quick note you don't have to do this so yes following this step right here creating a GitHub repository branching out doing commits and opening pull requests it's completely optional it is simply for those who want to learn uh how to follow a proper Git workflow if that is not something of interest to you you don't have to do it at all right so I'm going to create a new repository called Vibe and I'm going to set it to private and I'm going to create a new repository here and then I'm going to go ahead and copy uh these three lines because we need to push an existing repository here but before we can do that we have to stage our changes so we have 53 unstaged changes now so let's go ahead and add a plus here and now all of them are staged and now let's add a commit message so I'm going to go ahead and do 01 setup basically my commit messages will match uh my chapter and then I'm just going to commit and then what we're going to do is we're going to go ahead inside of our project and we're going to run those three commands here wait a second and now if you go ahead and refresh your repository you can see that you have your project available right here and now in here you no longer have that button publish a branch because now you have access to your uh remote origin main meaning that this is no longer a local repository this is now a remote branch on a remote repository perfect so that marks the end of this chapter and now we are ready to start setting up our database amazing job and see you in the next chapter in this chapter we're going to set up our database we're going to start by obtaining a connection URL using a poser database provided by Neon we are then going to set up Prisma our OM we're going to learn how to add and modify a Prisma schema some basic migrations as well as how to use a database studio and also how to reset your database in case something goes wrong and then we're going to go ahead and branch out open up a pull request and review and merge that pull request so let's go ahead and visit Neon database you can use the link in the description or the link you can see on the screen to let them know you came from this video once you've created an account with Neon go ahead and click create project i'm going to go ahead and call my project Vibe and my database name will be Vibe as well and then I'm going to click the connect button and I'm going to copy the snippet for my connection string after that I'm going to go inside of my project and I will create a new file environment inside of here I'm going to create a database URL and I'm going to paste my connection string after that let's go ahead and let's set up Prisma you can use the link in the description or the link you can see on the screen to let them know you came from this video this helps me a lot in creating more content like this so let's go ahead and learn how to use Prisma with Nex.js the first step is to set up the project since we already have that we don't have to do that instead we can go immediately to step two install and configure Prisma since we are using other databases specifically Neon let's click here so we know what to install so let's go ahead and start by installing Prisma and TSX as our dev dependencies once this was installed I will just go ahead and go inside of my package json so you can see the versions right prisma is 6.10.1 and TSX is 4.2 20.3 so if you're using the latest versions this probably does not matter for you but if you want to use the same versions as me you would go ahead and set up your installation like this for example if you want to great so after we've done this our next step is to install Prisma client but this time not as a dev dependency but as an actual dependency instead after we've done this let me show you the version prisma client 6.10.1 so I think the most important thing about the Prisma versions is that Prisma client needs to match your Prisma dev dependency at least at the time of me making this video I'm pretty sure that is an important rule it might change in this in the future so I'm not sure but I think it was this way for a long time now so now let's go ahead and let's actually run our app so in here they have this snippet but I'm not sure if this exact output will work with our directory because we have a source file here so instead what I'm going to do is I'm just going to run npx prisma init with nothing more so npx prisma init let's go ahead and run this and after this was finished I see this big log here so your Prisma schema was created in Prisma/sema.prisma prisma would have added database URL but it already exists in your environment you already have a g ignore file don't forget to add environment in here so pretty good warnings here so yes every time you run npx prisma in it it creates an environment file or it modifies it and it adds a database URL but this time it detected that we already have a database URL inside of our environment so it didn't do anything right usually it would modify your uh uh environment file and it would write a big message at the top saying modified or generated by Prisma but the only thing you need in your environment is the database URL so even if yours looks different maybe in the future they've changed this all you need is a database URL for now great so now let's go ahead and let's visit the other things added inside of Prisma folder we now have a schema.prisma and what's important here is that your provider is posgress and that your URL is the database URL so make sure you don't have any typos here but if you got this warning message it means you have typed it correctly because it did not override it and yes about this second message uh don't forget to add environment in the git ignore file that is very important but as you can see my environment file is grayed out which actually means it is inside of git ignore you can find it right here great so now that we have that set up let's go ahead and learn how to modify the schema so I'm going to go ahead and I'm going to copy this exact changes that they are using in their Prisma if you don't have access to that documentation page for whatever reason don't worry i'm just doing this as an example our schema will be different anyway or you can just pause the screen and type it out now so basically we're adding a user model with an ID of type integer and it will auto increment basically if I add one user it will be ID1 and then I add another user it will be ID2 then an email string which is required and unique and a name string which is optional so basically Prisma is using decorators for stuff like defining a primary key or ID in this case or adding the default value or setting something to be unique and if you want to make a field optional you simply add a question mark after its type and if you want to make a relation like user and post you start by defining well obviously your database structure one to many many to many right uh and then you simply add how you want it to be architectured so I want user to have many posts but I want post to have only one user so you define the second model and you literally say it's an array of that model right and then inside of here in order to properly connect it using foreign keys what you have to do is you have to set the author ID or the user ID and then you have to create an actual relation using the foreign key so you have to use user as the model and then you use a decorator relation so it matches the outer id and it references the ID of the user model and this is the place where you would add things like on delete cascade right so in case the user gets deleted we want the model post to get deleted as well so you can remove this for now just leave it exactly like this this is like a pretty good minimal example to learn Prisma and one thing I forgot to tell you yes you can install Prisma uh here to see the syntax i should have told you this before my apologies i just remembered uh so make sure to install this right so you can see the pretty colors and everything and once you've done this make sure you save this file and let's go ahead and see how do we actually you know commit this right because right now uh our database here is completely empty nothing yet exists here nothing is pushed here so let's go ahead and let's do npx prisma migrate dev i'm not going to do this flag because that's not how we're going to uh run our commands so npx prisma migrate dev and now we're going to be asked to uh call this migration in a certain way so I'm going to call this migration in it and just like that we applied the migration and two things have happened now actually three things the first thing is that it synchronized our database from neon to the schema right so now uh our neon database has the same schema there uh the second thing it did is it created a migrations file instead of our project and the third thing it did is it generated the Prisma client instead of source generated Prisma right so let's try and check all of those things out uh if you go inside of your Prisma you can now see the migrations here and inside of here you can see the actual SQL file that happened uh and the second thing you can see is I'm not sure where is my uh generated it's right here source generated there we go you can see the Prisma is now available here and the third thing that it did is it synchronized the Neon database so if you go inside of neon uh and if you go inside of tables I think you might be able to see there we go post and user right so you can see uh the exact fields here title content published author ID and user relation ID email name and posts relation there we go so we officially synchronized all of those things now so let's go ahead and see the next steps that we have to do uh in here it suggest creating a seed script let's go ahead and do that right I'm going to copy this you don't have to do this but I think it's nice it's a nice way to learn Prisma let's go inside of Prisma and let's create a seed.ts script like this and let's paste it inside now in here I have to go inside of source I think let me just see how do I access this all right found it so it's source generated Prisma right we have to go inside of source generated Prisma it's not inside of app like they suggested here perhaps uh this depends on whether you use the source folder or not or they've changed it so they use the prisma dot user create input now if you're wondering where does this come from how does it know user create input why is this called user well that's actually the magic of Prisma every time that you modify the Prisma schema and you run the proper command npx prisma migrate dev which internally runs npx prisma generate what basically happens is that it refreshes its internal uh intellisense typescript tool if I can call it like that and it creates a bunch of these useful types for you so right now you also have things like Prisma uh you can see all these weird things if I I think I can you I can import user and I can import post right and if I were to add a new model I would be able to import that as well right so that's the cool thing about Prisma uh perfect so I have this user data here and let me just if you if you are not unable to copy this let me just show you this first example and all the other ones are exactly like that and this is the bottom part right uh or you can use the link that I will put on the screen uh for this seed script if you want if you are unable to find it great so now let's go ahead and let's add this to our package JSON so Prisma and seed Let's go inside of package json so after scripts here let's add Prisma seed tsx Prisma SLT seed.ts just ensure that yours is in the correct place and once you've done that and saved the file uh in here we have a warning before starting the development server note that if you're using Nex.js JS version 15.2.0 or 15.2.1 do not use Turboac right so you can see that Turbopac sometimes has this small little issues but since we are on a newer version we should have no problems here right uh and now let's go ahead and run npx Prisma database seed here like that and that uses the tsx Prisma seed and there we go the seed command has been executed so just make sure you have tsx installed in your dev dependencies and your seed command set at the correct place and you should immediately be able to see this if you go inside of your neon database and if you go inside of your users you will see Alice and Bob inside of the users here so we successfully populated our database perfect another way of seeing this data is by using the Prisma Studio so NTX Prisma Studio should open it up on 555 and there we go you can see that inside of here I have some posts and I have some users right here Alice and Bob perfect let's see what are the next steps here so now we have to learn how to actually uh fetch our data right so let's go ahead and do that i'm going to go ahead inside of my project inside of source inside of lib and I'm going to create a database.ts file so they recommend creating Prisma i like to call it database and I'm going to import Prisma client from generated Prisma this is the same thing that they are doing i'm just using an alias here and then you literally have to do the same thing here i'm going to go ahead and try and explain uh how this works so basically why not just export new Prisma client the reason why is because of Nex.js hot reload uh every time a hot reload happens a new Prisma client gets initialized and that causes problems and you would actually see a warning in your terminal about that so what they do is they store Prisma in a global because global as the window object is not affected uh by hot reload i used window object i'm not sure if this belongs to the window nameace perhaps node namespace would be a better descriptor of it and I also don't like to use the export default so I will just use the export const here and let me just put it here actually I have to do it like this okay so now that we've done that let's go ahead and let's uh try and query something so I'm going to go inside of my source folder inside of app page.x and I'm going to go ahead and import prisma from lib database right here and I will get my users from await which means I have to turn this into an asynchronous component prisma dot user and let's just use find many and then I'm going to remove this entirely and do JSON stringify users null and two and we can remove the button import so this is a server component by default meaning that it is rendered on the server and it has access to the database server component is not the same thing as server side rendering those are two different concepts a server component is actually a react thing not a next.js thing next.js is simply the environment where server components can be demonstrated so let's go ahead now and do npm rundev let's visit localhost 3000 and in here you should see a JSON of your users inside and if you change this to post and change this to posts you should be able to see posts here as well so that is basically it right in here they go a bit more in depth they're creating a whole you know unique include we're going to learn that through the project itself so that's basically it for this but there is one more thing I want to uh go over here so we added the schema we learned about basic migrations and we learned about database studio but we didn't learn about database reset so why do we even need to learn about database reset well I just think it's very useful for development so let me go ahead and actually modify this so for development right not for production cases right you would pretty much never need to reset your database in production but during development it's just super easy if you get stuck right because this is the case now so we now have some posts and we have some users right so what happens if I go ahead now inside of my schema Prisma here and for example I remove the title from the post it's no longer required or I remove the email right and if I go ahead and do that now so npx prisma migrate dev i'm going to add this changes now uh it will probably ask me to reset database anyway right uh that's why this is a dev command right it should this should also not be used in production you would usually do npx prisma migrate you can learn more about that uh in the actual Prisma documentation here and there we go so now we have a problem you are about to drop the column title which still contains nonnull values and you're about to drop the column emails are you sure you want to create and apply this migration i'm going to select yes and I'm going to call this test migration here uh and this time it worked right so this seems to be uh normal now but the problem is what if you do something more complicated for example let's try and let's drop the user here and let's drop this right i'm trying to make a scenario uh where this actually stops working right let me try this i'm going to do another migration and I'm going to call this test again test two and okay it's still working never mind basically my point is that you need to learn how to nuke your database let's say that you do some some of your own experiments here and you get to a point where you're getting errors with your npx Prisma migration what I usually do if I get completely stuck and I'm in development this is important only for development mode i would go inside of Prisma here and I will remove all of my migrations all of them and then I would do npx prisma migrate reset like this are you sure you want to reset your database all data will be lost and I will press yes right so uh oh yes um I forgot that resetting it also runs the seed script so let's remove the seed script because it doesn't make sense right we just use it to learn so we can remove that we can go inside of our package JSON and we can remove this and we can also go inside of our source app page and we can remove this as well and then let's go ahead and just confirm that we can do npx prisma migrate reset again so just confirm and this should clear your entire database basically this is quite useful in development mode when you are for example doing what we just did right we just learned how to use Prisma so we populated our database with some models we don't really need we don't need the user with name optional and email required and posts right there there's not going to be any posts in our project so we just learned how to reset our database as well perfect so now it's time to create our first pull request once again uh the part of git workflow of this tutorial is completely optional only for those who want to learn so you can end the chapter here uh if you don't want to follow the git workflow so what I'm going to do is I'm going to go ahead down here where it says main and I'm going to click create new branch and I'm going to call this 02 and then I'm going to call it database so I'm going to call my branches according to my chapter 02 database and you can see that down here it says 02 database then I'm going to go ahead and click the plus icon to add all of these changes and then I'm going to go ahead and add my 02 database commit message and after that I'm going to publish my branch and once I've done that I'm going to go back to my GitHub here and immediately you will see an option to create a pull request in my repository if this did not appear for you you can manually go inside of pull requests new pull request the base will be main or master depending on what you're using and you're going to select your new branch here in the compare and then create a pull request and then click create pull request right here and once you've created your pull request you can go inside of file changes here and in here you can see every single thing that was modified you can see that we added the Prisma client instead of our lib database we slightly modified our page tsx and we added the schema prisma we installed some new packages and we also added uh source generated prisma to get ignore so that was not added and after that we can go ahead and merge this pull request and click confirm merge uh I'm not going to delete my branch simply so I have access to all of my branches here you can see that I can now always go back to that state of the application and then what you have to do inside of your project is the following go uh down here and click on the 02 database branch and then you have to select your main branch you might be wondering which one this main or this main well basically the difference is one is a local branch and the other one is a remote branch so the remote branch would be the one that is most uh well I I would say that is the source of truth i could be wrong in doing this because you could have some changes on your main branches that you didn't push but in our case we're going to push everything from the main branch so in your case it doesn't matter if you click on this one or if you click on this one you will have the exact same result what's important is that you do the following uh you click on synchronize changes here and then okay like this and now you should no longer have any uh visible buttons here right and if you go inside of your graph you should see this an initial commit then 01 and then something different for 02 right because we branched out and then we merged that back into our main like that and now if you go ahead inside of your main here you can see that six minutes ago we merged this right uh perfect so that's it for this chapter you can now see that even though I'm in my main branch I still have my Prisma schema meaning everything is fine everything is good perfect so let's go ahead and wrap this up so I'm going to go ahead and uh check this as done amazing job and see you in the next chapter in this chapter we're going to set up TRPC which is going to be our data access layer let's go ahead and let's head to the TRPC documentation page you can use the link in the description or the link you can see on the screen to let them know you came from this video once you are on the landing page go ahead and click on the docs and in here click on the client usage and in here you can find tanstack react query with a little star icon and in here going to server components be mindful that at the top here you do have a nex.js tab but that is talking about an older nex.js version so make sure that you are inside of tanstack react query server components this is what we need the first thing we have to do is install all the necessary dependencies so if you're watching this video far into the future I would recommend waiting until you see the exact versions that I had installed so before you run this what I suggest you do and what I suggest you do before you start any of my chapters is click on this button right here and just click okay basically this is just a sanity check to confirm that you are on your main branch and that you didn't accidentally uh forget to synchronize your merged branch from the previous chapter so you only care about this if you are actually following the git workflow once you've done that and you are confirmed to be on the main branch you can go ahead and install all of these packages i am going to show you which versions exactly I have installed let's head into package.json so we can see all the changes here as you can see I have tenstack react query 5.80.10 and all tRPC versions are 11.4.2 so if that's something you care about you can go ahead and install these versions as follows you would add this exact number to all of these packages regarding TRPC and then you would change this from using the latest version to using 5.80.10 and the ones for ZOD client only and server only are not that important but I'm going to show you them as well so server only is 0.0.1 0.1 and zod is a package we already have installed and we had it installed in the first chapter setup because when we added all chats component we also added forms and forms in chaten use zod for validation so that's why this isn't marked as a new dependency because we already had it great so now that you have confirmed to installed all TRPC ones just double check that you actually have the same versions of all TRP PC packages because that is quite important right so the version here is the the important version here is 11.x right the minor versions probably don't matter that much but there is a big breaking change in uh 11 if you're coming from 10 or 9 so make sure you're using at minimum 11 something and then you're good to go perfect now let's go ahead and let's create a small init file here uh so I'm going to copy this uh it's a very simple snippet so even if you don't have access to this documentation page don't worry i will pause the screen and you will be able to copy with me let's create a TRPC folder inside of our source folder and inside let's create init.ts and in here we are importing init TRPC from TRPC server package and cache from React we are setting up the create TRRPC context here with some mock information and we are also creating our initial T object which is basically initializing the TRPC and then we are extending it to create the router callers uh and factory and base procedure perfect so that's our init file now let's go ahead and scroll a bit down and let's create our base routers so I'm going to go ahead inside of TRPC I'm going to create routers folder and inside app.ts so I'm importing Z from zod and from the previously created init file I'm importing the TRPC router with the base procedure so in here we have a very simple procedure called hello and it accepts text which is a string and it returns back an object with a property greeting which is a string with the information from the text that we've entered we are going to test this out later so it's easier for you to understand if this is the first time seeing the TRPC syntax so that's it for the routers and now what we have to do is we have to create our API folder DRPC and then a special uh Nex.js variable folder uh and then route.ts so let's do that first inside of source app folder let's create API then let's create tRPC and then let's create a dynamic folder inside of square brackets TRPC again and then route ds and let's go ahead and copy this now in here we're going to get some errors it's specifically uh about this import alias so we don't use uh this curly little string instead we use an add sign so you can just switch it to that and you will have no more errors as you can see uh all of these things already exist so we have the TRPC server package they are just extending it here some tree shaking it seems and the TRPC in it is the one we just created as well as the router's app right so you can commandclick on this to visit that same as the init one and this is a NodeJS package so that's a different thing great you can save this as well just double check that you have app folder API TRPC TRPC in square brackets and then route.ts it's very important to have this exact structure great once we've done that let's go ahead and let's create the queryclient.ts so I'm going to go inside of source drpc queryclient.ts yes it is.ts perfect so about super JSON we can um let's do this let's immediately install it so super JSON because we are going to need it and I will go inside of my package JSON here so this is my version in case you want to use the exact same one and what we're going to do is we're going to immediately enable serialized data using superjson.s serialize and des serialize data using superjson ds serialize as well so you can leave it the component like this no need to modify anything further now let's go ahead and let's create our client.tsx so this will basically be a wrapper a provider of TRPC and Tstack query which we're going to wrap our entire app around uh if this is your first time ever seeing Tanstack query or TRPC this is a lot of information at once uh but if you've ever worked with uh React Query or something like SVR I promise it's a similar API it is just uh a bit more advanced data access layer format that we are doing here so as much as this setup seems a little bit complicated it is definitely worth it you will see how easy it will be to build your API routes and your procedures later on you will thank yourself for going through this because of how easy it will be to maintain this project going forward right so just stay with me i promise it will be worth it so let's create client.tsx inside of here client.tsx so this extension is important because this will be exporting a component so since this is a bit of a larger file I'm going to go ahead and explain what it is so first of all we are adding use client because this has to be a client component you can see it tries to access the window here and it's also using some uh hooks like use state that can only be achieved using a client component that's why we are using use client at the top and you can also see the explanation here so we are importing all of those things we should not have any errors because we either created or installed these packages so one thing that we are going to change is this so I don't like how this is specifically tailored for Versell because I don't know where you want this deployed so don't worry i'm going to show you how you can modify this so it works well regardless of where you deploy so let's go inside of our let's just save the file uh and let's go inside of environment here and let's simply add next public app URL and this will be the following when you go ahead and do npm rundev you're going to see where your app is being run so go ahead and copy this and simply paste it inside then I always like to copy from here and then paste it rather than type it out because you can do some typos if you're not careful and you can see how complicated this is right so it recognizes Versell URL and then it has to append the protocol and then it has to add this because Versel URL doesn't have the protocol otherwise it has to guess that we are using the 3000 port it's just completely unnecessary we can do this much easier you can return this completely and instead of using this you can just do process environment next public app URL so then when you deploy you will simply change this to your production URL regardless of where you deploy and this will work just fine and in my opinion it's much simpler to work with and this is important right you can see that this will attempt to load the URL from localhost 3000 /trpc so it's important that you didn't do any changes herec that's why this structure is important and then in here we just have some regular uh trpc and uh tanstack query setup but we have to enable the transformer superjson because we did enable it here so we have to enable it here as well so let's do the following at the top here i'm going to import superjson from super JSON and I'm going to go down here remove this part and simply uncomment so we are using the super JSON and you can ignore the error for now it's because we need to enable it in some other places as well to get it to work so once you've done this we didn't do any changes besides this and this right that's the only thing we changed so now as per their instructions we have to go ahead and wrap this in the root of our application when using Nex.js since we are in Nex.js JS let's go inside of the root of our application and that's inside of the app folder layout so in here simply go ahead and wrap the entire application so be careful with the component you are importing it is TRPC react provider from TRPC client the reason I'm telling you to be careful is because there are similarly named imports from packages we are not importing from any npm package if you need to be able to command or controlclick here and it should lead you to this exact component which has this little superjson error that's the one we need to import and wrap our application around because if you just do TRPC provider you can see that that also exists but that's the incorrect one right it's TRPC react provider from TRPC client component that is currently throwing the error that's the one we need once you've done that we have to create a server.tsx and this is where things become interesting so let's just do that now i'm going to go inside of DRPC and I'm going to create server.tsx and I'm going to paste this here and you can immediately delete this part so this is just an example if your router is on a separate server not case for us so we can remove this so you can see it's much simpler now again we have all of this either installed or already created great so now that we have that uh let's go ahead and just fix this little super JSON uh issue here that I'm having so I'm using super JSON in client.dsx i'm using it in queryclient.ds and I think I should also be using it in init.ds you can see that I have it commented out here so let's enable this and let's import super JSON from super JSON this basically helps with serialization when it comes to passing specific props from server to client components with complex objects right like well object array date things like that super.json helps sparse those things uh great so we now created server.dsx and this is actually a very very uh interesting file and I'm going to try and do my best to explain why so that is basically it for the setup we are now ready to use this API so let's go ahead and let's do that in here I think they've added the most complicated example so I'm going to try and use a more familiar example first let's go inside of source app folder and let's go inside of page.tsx and let's try and do the following let's add TRPC using use TRPC from naturally client right that's our client.tsx component this is where we import everything client related so now we have access to TRPC you can see that I can find my hello and I can go ahead and pass in the query options inside i can find the greeting or the text and I can say hello right this isn't doing anything now i'm just showing you the API and how it works so let's just quickly go inside of our routers here so you can see this change in real time and so I can give you a little tip if it doesn't change for you so go inside of TRPC routers app and rename this from hello to for example create AI something like that you can see how immediately I've gotten an error here because that's how TR the RPC works so instead of having to do localhost 3000 / AI slashcreate dash AI right which is most of the time a literal string right so it's very hard to u it's very easy to make mistakes right i can accidentally do this and this is now an invalid API route but I wouldn't know until I see a 404 error so what the RPC does is it enables full stack type safety from start to end so if I accidentally make a mistake here it immediately throws an error like this route doesn't exist that's what the RPC is and it is much easier to build your apps when you know that you can rely on your code rather than having to see it break in production and then go and fix it right so if it works inside of your IDE if there are no errors here it will pretty much work everywhere that's the power of having uh end to end type safety and let's go ahead and change one more thing inside of this input here this basically represents things you can send to your API so let's go ahead and imagine an API post request again for example this would be create AI in here we would send something like body and then we would somehow you know stringify this with text hello right this is a stupid example right but you know what I mean uh this is also very easy to break but in here you can see that if I try sending a number here I'm getting an error why because we clearly defined this needs to be a string so if I change this to uh number now you can see that it works right but if I try string it will break So what happens if you are not being able to see the same result as me right when I hover over text I can see the text is a type of number when I hover over create AI I can see the input and text number and output is a greeting of string right exactly as I'm typing it here if you are seeing type any for everything you could be having a problem with your setup so what you can do is you can go uh inside of extra information and go into frequently asked questions and here we have it it doesn't work i'm getting any everywhere so there are a couple of things you can do the first thing is you can check your tsconfig.json and in here make sure you have strict true enabled the second thing is to make sure that you are using the proper TypeScript version and make sure your editor is using the same TypeScript version as package JSON so for me none of these things were ever an issue but I did have this as an issue and this is what actually fixed my types so go inside of your VS Code settings.json let me just go ahead and try and do this so settings let me Oh I think that yeah you can just create it if you want to so go inside and create a VSS code like this and then settings.json and you can paste this inside and then you can click allow if this happens and let me go back to page.tsx so nothing changed for me because this worked from the start but if you're having any problems when I say any I mean this you're getting the type any all over your project it could be due to these missing settings so this actually fixed my problem once so that's why I am sharing it with you and you can always do commandshiftp and then reload window and this kind of restarts the TypeScript server so then it could work maybe great so now let's actually see the result of this query so make sure that you have your app running and that you can visit uh your root page and first thing you should see is this very big error why because by default in Nex.js every page and component is a server component unless specified differently or if it is a direct child of a client component so let's go ahead and add use client to the top this will then turn it into a client component and you can see we no longer have these errors we can now use hooks as much as we want so what I want to do now is show you how we actually get data from our API using a very familiar use query from the package 10stack react query and in here you would usually create you know your own fetch method which would then call forward slash AI create AI and then you would pass in the body right and you would have the JSON stringify blah blah blah what you can do now is the following you can just use the TRPC oneRPC create AI and pass in the query options inside text and let's try Antonio here let's go back inside of Yeah you can also commandclick here and it will take you directly to the router so I'm going to change this back to string and then what we can do is simply render data let's just do JSON stringify data there we go and there we go greeting hello Antonio if I change this to John it will change to hello John that's how we're going to fetch our data this is our data access layer great so this is the most simple way of fetching data using a client component right everyone knows this but let's go ahead and cover two more examples which I think are important right so we've kind of set up the RPC and we experimented with a client component now let's experiment with a server component and then finally let's experiment with pre-fetching and I'm going to try to explain what it is and why it is important so basically server components have several advantages over client components uh they are not of course one is not a replacement of other they work together but server components have that advantage that they are well on a server which means server components have direct access to the database for example but in our case what's important is that they render sooner than client components right so what is currently happening is that our application has to wait for page.tsx to be rendered from the server and only then does it start fetching the data but what if we could start fetching the data on the server and then continue using the data using this familiar API within a client component that is prefetching but in order to understand pre-fetching let's first remove use client like this and let's break our app so immediately our app is broken right we can't use tRPC here at all right so now what we have to do is we have to learn how to use TRPC inside of a server component and let me just show you uh I'm going to try and do this so if I add console log here and just remove these things and just refresh I think that you should be seeing server component inside of your terminal how come you're seeing it in the terminal because it is a server component right because if I change this to use client now and change this to client component and refresh I'm pretty sure we can still see it here yes this is a bad example my apologies previously in the past you could not see it if it was a client component uh so yeah ignore this i tried to do an example but I used a wrong one let's just learn how to fetch data from a server component so in here we actually have some guides let me just go back here there we go so uh in here getting data in a server component so let's go ahead and simply create this little caller inside of our server.tsx so go inside of tRPC server.tsx and at the end here export const caller call the app router create caller create trpc context right so there is a way you could you know fetch data from a server component and that would be either you know directly calling the database like calling Prisma or there is nothing stopping you from fetching inside of a server component so you could again do create AI and then the body blah blah blah right but that is unnecessary overhead because server component already has access to the database right no point in doing this that's why TRPC has invented something called a caller so what you can do now is let me just confirm the API you can import the caller so let's just do that so I'm going to do cons data and turn this into an asynchronous server component component and await caller from DRRPC server create AI and let me just see do I have to do it like this i have to Antonio server and then I believe let me just check is it data like this there we go json stringified data so this is how you would fetch from a server component using TRPC using a caller so this isn't doing a network request on the server component this is server component literally directly having a remote procedure access a remote procedure protocol to TRPC that's why TRPC is so powerful because I think it's one of the only RPCs available that has these types of callers i could be wrong but it's the only one I've seen that performs this well and this isn't so impressive right now but if you've worked with server components before and you tried any kind of RPC here you would almost always encounter an issue that you lose authorization headers right uh the server component would never know if the user is logged in or not trpc solved that problem as well that's why I love TRPC so much because it allows us to leverage server components so now let's finally do the uh way we are going to use the RPC and that is using pre-fetching so we would do things like this const query client would be get query client from gRPC server we're not going to call the caller here but we will import tRPC from here and then in here we're going to do void t uh queryclient dot prefetch query drpc create ai query options text Antonio and this time prefetch and then in here what we would do is we would add a hydration boundary from tanstack react query we would pass the state to be dehydrate again imported from tanstack react query and pass in the query client and then in here we would render a client component so let's go ahead and create that client.tsx this is not a reserved keyword so this is just a component which needs use client at the top and then in here what we would be able to do is the following we can now get the data by using use suspense query from tanstack react query and let's add our TRPC from the client and pass in TRPC create AI query options and important you need to have the exact same text here otherwise the pre-fetching will fail because this would usually be some kind of filter for example instead of text you would most likely have page one limit 10 so if you prefetch one thing and then expect to have something in suspense in the client component it wouldn't work that's why it is super important that your query options are exactly the same in your prefetch and in your client component and then in here you would be able to do JSON stringify data and now let's go ahead and let's do this so let's go inside of here let's import client from dot /client and let's wrap this inside of suspense from react and let's add a fallback here loading so what's going on here basically instead of directly calling the data inside of a server component what we are doing is we are leveraging t uh we are leveraging tanstack queries cache and state and we are immediately populating it the moment server component gets created the moment server component loads because this will then allow the client component to load whenever it loads because we know a server component will load sooner than client component but this time the client component won't have to wait until it gets loaded and only then initiate a network request instead it will already have the data ready even though because we prefetched it inside of a server component and it's very important to use a void here and this prefetch query actually doesn't return anything so even if you tried things like this this wouldn't work it doesn't return anything they've done that on purpose so you don't uh so you don't actually use this data because pre-fetching query all it does is it initiates a call on a server component but only for the sole purpose of populating uh tanstack query which can then be accessed in a client component so we are leveraging server component to start fetching our data immediately and then we are passing it down to the client component which uses a familiar API so because this is use client we can now go ahead and have a use effect here right we can go ahead and we can have a state here right we can do all of these things and it would work as fast as if we did the entire thing in a server component so we don't lose the familiarity of client components and we also don't lose the speed of server components we basically get the best of both worlds by doing this and let's finally try it out you can see it works just fine i know this is still a bit confusing i try to explain it the best I can i would highly suggest you know reading about prefetching and just going through uh this documentation in the first place perhaps Dave explained it a bit better but this is how I like to explain it basically we are now getting the best of both worlds both the speed of server components and the familiarity of client components and I think that this officially uh marks the end of this chapter right so let's just remove these things because we don't need them and what we're going to start doing in the next chapter is finally initializing our uh background jobs and start introducing some background actions we now have our database we have our OM and we have our data access layer so those are the three things that we need so we can start saving uh some data in our database properly right so let's go ahead now and mark this as completed we did all of these things and let's go ahead and branch out now so I'm going to go ahead and go down here and create a new branch i'm going to call this 03 DRPC setup i'm going to go inside of my source control here and I'm going to stage all changes and then I'm going to add 03 TRPC setup comment and I'm going to commit and then I'm going to uh publish the branch then let's go ahead to our GitHub to open a pull request so in here compare and pull request and let's create a pull request and as you can see I have something that you probably don't in your pull request and that is an AI code review using code rabbit as you can see not only do I have a complete summary of this pull request as you can see we introduced TRRPC integration for type safe API calls between client and the server and we also added some chores not only that but I have a change file by file summary so you can see exactly what I did in each file and I also have a sequence diagram explaining exactly how every single component works in which order and how it responds with data and result which is especially useful if this is your first time working with the RPC and Tanstack query and I also have some potential issues it caught for example we added this dummy TRPC context from the documentation right so it noticed that and it told me that I should replace this hard-coded user ID with proper authentication in this exact case it is okay for us to proceed because this is just uh our initial TRPC code we will replace this later when we add authentication but you can see how it already started noticing some potential issues in our code and then it also told us to change this further on when we update this React context so it actually understands our code very very indepth if you're interested in having the exact same code review you can use the link in the description or the link you can see on the screen and create a Code Rabbit account but that is not all so now I'm going to go ahead and merge this right here let's merge this pull request i'm not going to delete my branch simply so I have access to it right here so this was our previous chapter and now we have TRPC setup and you can see that I got this popup in my Visual Studio Code as well asking if I want to start a review inside of my Visual Studio Code so since I just reviewed my code uh in a pull request I'm going to click no but I'm going to show you in a second what this is so before we proceed go ahead and make sure you change back to your main branch and then just click on this little button to synchronize the changes and then when you click on a graph here you should see our last one was a database commit and then we merged that and now we branched out for TRPC setup and we merge that back inside and what I suggest you install is Code Rabbit extension so Code Rabbit is a completely free VS Code extension you can go ahead inside of your extensions here Code Rabbit and install it and if you don't want it connected to your pull requests you can have complete free code reviews in your Visual Studio Code all you need is an account with Code Rabbit you can use the link you can see on the screen and you will get amazing pull request reviews but also you will get completely free code reviews in your IDE we're going to try that in the next chapter because we just reviewed our code in a pull request this time so again just confirm you are on your main branch and you have synchronized all changes and that will allow us to continue to the next chapter so let's go ahead and mark this as done amazing job we now have the database access our ORM and our data access layer we are finally ready to start doing some AI related things and background jobs amazing amazing job and see you in the next chapter in this chapter we're going to learn all about background jobs we're going to learn how to add them to an Nex.js GS application and we're going to learn what they are and why we need them in order to understand that let's first look at a normal example imagine a login form you enter your email your password you click login we send a network request and we get an instant response success or fail we've already seen this a million times but now imagine you have a more complex task at hand imagine you offered your user an ability to generate a summary of a very very long YouTube video imagine my videos for example they are sometimes 12 24 hours long so this time we send a network request and in order for our backend to generate this summary it can take well over 30 seconds to do that because just imagine everything that needs to happen we first have to download the YouTube video then we have to transcribe the video and only then can we send that to an AI model to generate the summary so depending on the size of the video depending on the AI model you will use and depending on your overall infrastructure it can take well over 30 seconds for that to finish and if you have a task that's running for so long within a normal network request like this one you know something completely normal you risk your user never getting the result so the problem is not that the user has to wait the problem is this network request can time out the user can accidentally close the tab or the user can lose their connection if any of these things happen the user will never get the result back and we have to start the entire process again that's why we have something called background jobs so let's imagine this again the user clicks generate summary this time we send a network request again but instead of using our backend to generate the summary we use our backend to invoke a background job and the moment we've done that we are finished with our network request which means that we immediately return back to the user and say the summary is being generated and the user can now close the tab they can go for a run they can do whatever they want what's actually happening is that the moment we invoke a background job the background job now runs in a separate environment independent of the user's session independent of the user's connection right and we can simply notify the user when we are done this is the structure you have to understand if you want to build AI apps because depending on the model you will use and the complexity of the app you will build most of your tasks will be longunning tasks we will achieve this in our project using ingest so let's go ahead and create our first function and let's trigger a background job from nextjs you can use the link you can see on the screen or the link in the description to let them know you came from this video and once you're here you can immediately go inside of the documentation select NextJS and select app router here and then let's go ahead and install inest before you do that just make sure that you are on your main branch and you can click synchronize changes just to confirm uh you didn't have any unsaved changes here you can see my last chapter was TRPC setup and yours should be as well so I'm going to shut down my app now and I'm going to do npm install injust and now that I have this installed let me quickly show you my package JSON so you can see the version that I'm using once you have installed Injust the second step is to run the Ingest developer server the version that I will be using is 1.8.0 but you can see that in here they simply target the latest version so when you see me now doing this npx inest- cli at latest the latest is equivalent to 1.8.0 zero just in case you were interested in my exact version so npx inest- cli at latest or a specific version and then dev and when I start this you can see that it says injustdev server is online at localhost 8288 and if I visit the project here well you can see that not much is going on here it is a developer server but nothing is here for us to do so what we have to do now is we also have to have our app running so let's do mpm rundev and in here you will start to see something you will start to see a bunch of 404 pages here that is because the ingest developer server is trying to find our inest initialization in our project but since we haven't done that we just have a bunch of 404s so let's go ahead and continue with the documentation here i'm going to go ahead and create an ingest folder and then put a client.ts inside with this simple code snippet so let me go ahead here inside of source and I will create a new folder called inest and I will create client.ts and I will paste this inside i'm going to call this vibe project or vibe development something like that basically the name of your project here and once you've done that you should oh actually not yet sorry so this is the first step and then we come to the second step which is creating an API endpoint for ingest so you can copy this snippet as well and go inside of app API create a new folder ingest and inside go ahead and create route ts and paste this inside and you and replace this with an add sign and a forward slash there we go it's basically using this inest which we just created and the moment you save this file if you have named it correctly and put it in the API folder you should go here and you will see that now you finally get 200 here because it finally found the ingest integration and now it will only try to hit that endpoint instead of all of these other ones great but we still don't have anything useful in the developer server here so let's go ahead now and let's continue by creating the first ingest function so I'm going to go here inside of source ingest functions.ts and create a new function so inside of ingest folder in the source make sure you don't accidentally do this inside of API inest so in here create functions whoops functions ds import the client and a simple hello world in just create function we give this an ID we give this an event name and we have a very simple step which waits for 1 second and it then returns a dynamic string which uses the data we can pass to this background job so this is an example so they show us how easy it is for us to pass some data to this background job this would be for example a link to a YouTube video we want to summarize right that's what this data object would hold for example I think I have a typo in my functions here so let me just fix that and then let's go inside of the app folder API inest route and inside of here let's import hello world from that inest functions file and now if you go back here you should be seeing uh your app here available auto detected you can see everything is fine it found it at API inest framework next.js and one function found hello world because we just added it here so if I rename this to hello world 2 it immediately renames here as well and now instead of these functions let me just refresh so it's back to this name i can now click invoke here and you probably have empty data but you can go ahead and add email and pass in I don't know it it can even just be the name it doesn't matter and click invoke function and you will see how it went from ceued to running to completed so that's the status that just happened it happened very quickly because uh there wasn't no no no one there was no function before this so the queue to running went very fast and the running only took 1 second because we only wait for 1 second for example let's now increase this to 10 seconds and save the file and let's go inside of our functions invoke and let's click this again you can see how now it keeps running it's running for 5 seconds 7 seconds and finally after 10 seconds it's finished is this getting familiar to what we just discussed this is a background job the only problem so far is that we are not invoking this function from our network request we are manually clicking on invoke here how do we invoke this from in our case TRPC procedure let's go ahead and let's do that so I'm going to go inside of source trpc routers_app and in here I'm going to call this invoke this will be base procedure and let's add an input here z.object and let's pass in the text to be z dot string like this and then instead of dotquery let's add dot mutation this time it's going to be asynchronous here let's extract input from here like this and this time what we're going to do is await inest from injust client the name of the function you can find here this is the name of the function you will run so pass that here and then you pass in the data and the data can be anything you want but we know that we accept email here uh so let's go ahead and pass email to be input.ext because we defined it as text here and this is how you invoke a background job from TRPC so now let's go ahead and actually use this invoke method i'm going to go inside of source at folder and I'm going to go inside of page.tsx here and uh well we already have this set up but since we are not going to need it I'm going to delete it for now i'm going to delete this client.tsx i'm going to go back inside of the page here and I will simply return a div here test and I will remove everything from here we only use this to learn about the RPC so let's mark this as use client so this becomes a client component the use client is very important for our demonstration here so please do it now when you refresh on your local host 3000 you should just see a test here so now let's go ahead and let's create a padding for maximum width 7 XL MX auto and in here let's add a button component invoke background job and there we go we now have a button to invoke a background job so let's go ahead and add TRPC here use TRPC and let's add invoke from use mutation from tanstack react query pass in tRPC.invoke and pass in the mutation options here and then in here on click call invoke and call mutate and pass in the text to be test or John something like that so what I want to demonstrate to you now is how quickly this background job uh lasts in comparison to the network request so I'm going to go ahead and open my developer console here i'm going to go inside of the network tab and I will click invoke background job and let me just see did I even do anything now or not because I I'm definitely expecting to see something here but it is not uh happening let me refresh the page all right so my website froze so what I did was I simply shut down my app and I did npm rundev again so I'm hoping to try it out again this time successfully there we go now when I click on invoke a background job you can see how quickly this finished let's just see 468 milliseconds that's how long this network request took but we know that the actual background job took 10 seconds so that is what we wanted to achieve if I go inside of the RPC invoke again uh and inside of the ingest and go inside of the functions let's change this to 30 seconds and add a comment here you know imagine this is a u download step right here in here we are downloading a video then in here imagine this is a transcript step another 10 seconds and then finally you know imagine this is a summary step and this finally then takes 5 seconds this is what we want to achieve right the moment we click on generate summary we send a network request we trigger a background job and we immediately allow the user to close the tab right so let's try it again uh in order if you want to you can also do this you can go inside of your layout in app folder and you can add a toaster from components UI soner like this i just like to order the components like so and now once you've added the toaster you can go inside of the page here go inside of mutation options and add on success here and you can add toast from soner.su success background job started and now you will see the following if your app gets stuck you can go ahead and just do mpm rundev again uh I did get this happen a few times and I think I solved it when I removed the turbo pack but we'll see basically if your app hangs on loading don't worry you can just uh restart it it will not happen in the actual app so let's try this now uh we can also do disabled here and let's do invoke is pending like that and we can also go inside of invoke function here the RPC invoke and after a wait let's return okay success like this so now if you click invoke background job you can see this is it the request is finished right the user can now close their tab and what's happening is in the background right we are now doing the first step which would be 30 seconds of downloading a YouTube video after that we're going to go ahead onto the second step right which would be transcribing a video so let's see after 30 seconds here is finished we go to the second step and this step will last for 10 seconds because we just wait for transcription to happen and then finally we have a third step and in here we would do the AI summarization and that's it hello John or this would actually be the summarization right so that is how background jobs work and that's how you add them uh in a Nex.js environment right and it doesn't matter if the user lost their internet connection it doesn't matter if they're closed the tab because the moment they invoke a background job the background job has started they can lose their internet connection obviously in development mode if you lose the internet connection your dev server would fail so yes in development technically you need you cannot really shut down your laptop but in production it will run on a separate server in a separate environment right and from this inest developer server you can easily cancel things if you don't want to you can rerun them uh you can go ahead and look at the payload that was added you can do a bunch of things here uh and one cool thing about ingest steps is this will later be of course more complex things than just sleeping for 30 or 10 seconds this will be API calls database requests and if they fail it is crucial to well retry them and that is what inest does automatically for you uh they actually have a cool example on their landing page here they have uh and yes they have agent kit this is something I didn't want to talk about immediately because I don't want to confuse you right so uh alongside background jobs we're going to use injust to build autonomous agents right so AI and background jobs go hand in hand and Injust is the platform to do both of that but I first want to introduce it through background jobs because it's easier to understand right and in here they have three very cool examples so this is the transcription example you can see that uh they have a step called transcribe video so it's very similar to step.slip slip but instead it is step.run and they call it transcribe video and in here they simply return a deepgram SDK with a function to transcribe a video URL and once this steps finishes they call an LLM chat GPT uh GPT4 to create a summary so exactly what we did so this would be the two steps right this would be the first one you know transcribe the video and then the second one summarize the video right I just use a download step as well so looks like we don't need a download step right so this is what you can use in just for the second one is to build AI with automatic retries cach caching and improved observability right so it's way more powerful than I can showcase in this short chapter that's why We will have more chapters later on to build the actual agent networks agent router and agent tools right and of course you can do sleep which right now seems only for fun but sleep can be very useful for example you can send a welcome email to a user then wait a week and then send a follow-up email so yes that's how long these tasks can wait they are background tasks uh perfect yes and for development you don't need any account yet but later uh for production for deployment we're going to have to create an account with ingest but for development there's going to be no need for that as well and I think that's great because we can get started right away just by running this perfect so I think that was the goal of this chapter i think we achieved this exact thing right here so we set up inest let me just change the color so we've set up inest we created the first function we explored the ingest developer server and we triggered a background job from Nex.js now let's go ahead and branch out and push this to GitHub so let me see this chapter name this is 04 background jobs so I'm going to go ahead and click here you can see that I have 10 unsaved files and I also have this little database in the inest folder if you're wondering what that is I'm just guessing it's cache for the inest developer server and now I'm going to go and click on the main here i will click create new branch and I will do 04 background jobs after I've done that I'm going to stage all of my changes and I'm going to create a commit message and I'm going to click commit and then you can see that code rabbit extension if you remember from the previous chapter uh you can install this a completely free AI code extension which allows you to review all of those files so let's go ahead and review all of these files and while this is doing its own thing which is most likely a background job on its own so you can see uh you can see background jobs every day right you probably just didn't know they were called background jobs while that is going on let's go ahead and let's create a new pull request inside of our repository here so let me go inside of pull requests here uh new pull request uh oh looks like it won't push until uh this reviews so I'm going to go ahead and review first actually it will i just have to click publish branch yes I forgot to click that so make sure you click publish branch and you can see that this is still doing its own thing in the background and I think now that we have a new branch there we go i forgot to do that my apologies so now we're going to have two uh AI reviews here one is going to be from here and the other one is going to be from here and you can see how cool it is that it can add comments on my code locally here in my There we You can see fox fix duplicate step ID so it noticed that all of my steps are called wait a moment uh which is very you know not useful uh when you were reading inside of the ines developer server so it already detected that for example so you can see how cool it is and it also fixes some wrong things here payload mismatch with ingest function this is of course not something that uh we need to fix right now simply because this is a demo but it is very useful as you can see it detects pretty much everything so if you don't want it here in your pull requests you can have it here in your uh IDE and here we have our pull request summary which is pretty much identical as you can see uh to the reextension for Visual Studio Code you're going to see in here we have fix duplicate step ids and you can see that here at the bottom I have the exact same issue here so you can choose which one do you like more do you like your pull request reviewed or do you want to submit clean pull requests by having this run before you push a pull request so in here I'm going to read through the pull request simply because we have the summary here so we introduced an API endpoint to handle background jobs using inest we added a button on the main page to trigger a background job with real-time toast notification on success we use this to visually measure how quickly the network request is finished in uh comparison to how long the background job actually lasts right and this is what I like the most i like the sequence diagram because it is exactly what we discussed in the beginning of the chapter so the user clicks on invoke a background job we send the invoke mutation with the text and then our TRPC router which is our network request simply sends the event with that data this can basically read as invoke a background job and the moment we do that we can send back the user okay success so this part right here is identical to what I wanted to achieve here the user clicks we send the network request we forward the data to a background job and we immediately respond to the user so they can close the tab and move on and the fun thing about this background jobs is the way Code Rabbit just reviewed my 10 files here is by using a background job they definitely didn't have a network request which went on for 30 seconds they had a background job which did this exact thing so I went through this potential changes they are all very correct but since this was just a demonstration it makes no sense to fix them right now because we will remove the whole page entirely uh in the first place right so we are good to go with merging this pull request right here i'm not going to delete my branch simply so I can go back to this part whenever I want uh and let's go ahead now right here let me close this let's go back to our main branch let's click this and let's synchronize our changes and after that I'm going to click no on this i'm going to go inside of my source control on the graph and you can see that I have 04 background jobs now merged right here and you can see that I'm on the main branch and I should have access to my inest folder here which basically means we fixed all these things perfect i'm also not going to do uh anything regarding this code rabbit uh comments here simply because all of this was just a demonstration amazing amazing job let's go ahead and mark this as complete now and see you in the next chapter when we are going to extend the use of our background jobs with AI amazing amazing job in this chapter working to implement AI background jobs in order to do that the first thing we're going to have to do is choose our AI provider in here I have added a list of all the options that we have and some comments for each of them starting with the best choice which is Open AI it is by far the most reliable the most normal rate limit with a fast reset and a very very good coding model this is the coding model that I have chosen GPT4.1 and it is almost perfect the absolute best coding model though is cloth specifically set 3.5 or 4 they are kings of coding models the problem with anthropic is a very strict rate limit and when you hit the rate limit it will take you longer than 24 hours for that rate limit to reset so it's it is just very very annoying to work with if you want to you can choose anthropic but you will almost certainly hit a rate limit and you're going to have to either change the model or create a whole new organization and account so basically Anthropic allocates their resources to uh higher paying customers right which are this very very large companies so it's not exactly suitable for tutorials as per Grock or XAI I'm not sure i haven't worked with it it is on the list of the supported AI models so I don't know i won't recommend it and I won't tell you not to use it i I'm not sure and as for Gemini or Google the great thing about Gemini is the amazing free tier the biggest problem with it for our use case it is just not good for calling tools it will straight up be errors all around so because of that at this moment I just don't recommend it uh I've heard that Grock AI has free tier so I would rather you use Grock than Gemini so unfortunately at this point I cannot recommend Gemini it is okay for this simple chapter that we're going to do now but later when we use AI for the thing we will actually need to use it for it will simply not work so if you really need a free tier you can try and use Grock rather than Gemini the absolute best choice and the choice that I will be using is Open AI specifically this model as I said there is a chance we might hit the rate limit here but the reset is around 2 seconds which is completely fair and it will happen rarely only when we are doing some very very large uh tasks with Enthropic we get the amazing results it completely understands Nex.js ecosystem it understands what chats and UI is but once you hit a red rate limit and you will hit it very soon it is almost impossible to get rid of you will almost be stuck in a rate limit so in my opinion choose Open AI it is the simple best solution for this project if that is possible for you you will have the best uh experience using Open AI and now I'm going to show you uh how you can find if any changes have been made regarding this uh if you're watching this tutorial in the future so you can use the link in the screen uh again or link in the description to visit ingest and in here go to the documentation and then go ahead and find agent kit and in here go ahead and click on this support for openai anthropic and gemini or click on the models here so in here you will see all supported models as you can see open AAI anthropic Gemini and Grock as I said even though Gemini is supported here I just wasn't able to get it to work if you want to you can try but I wasn't able to get it to work anthropic worked amazingly especially the 3.5ET versions but the rate limits were very easily hit the Open AI I initially tried with 4.0 and I really was not satisfied with the results it's not that good but even though it's not on this list you can try 4.1 so that is confirmed i tested it myself and it works no problem and it's amazing not as good as Enthropic 3.5 but very very good and very reasonable rate limits so what we have to do next is we have to create our account in one of these providers i'm going to show you what I do with OpenAI and then you can do whatever you want to choose here in my case I'm going to go ahead to platform.openai.com you can use the link you can see on the screen or link in the description once you've created your account you're going to go ahead into settings once you are in the settings you're going to go into billing in here it is very important that you have a credit balance so maximum of $10 even less will be enough for you to complete this tutorial many times which will of course depend on how often you create uh new uh websites and uh apps with this project but I barely spent that amount and I tested pretty heavily once you have uh filled your account you can go ahead and obtain an AI key if you're using Grock or Gemini you have a free tier but as I said Gemini just doesn't work uh and Grock I'm not sure you can try so let's go ahead and let's create a new secret key i'm going to call this Vibe development i will use the default project and I will select all permissions and I will create the secret key i will then copy this key and then what we have to do is we have to add that to our IDE I mean to our project as always ensure that you're on your main branch and you can synchronize the changes just to make sure you're up to date as you can see my last chapter was background jobs so now what I'm going to go is I'm going to go inside of environment here and I'm going to create open AI here open AI API key and I will paste it inside like this if you're using something else let me show you how to add that so I'm going to go inside of the inest uh agent kit documentation here and here you have it environment variable used for each model provider if you're using OpenAI it is OpenAI API key if you're using Anthropic it's Enthropic API key if you're using Gemini it is Gemini API key or if you're using Grock it is XAI API key so make sure that you've added one of those here perfect now that you have done that let's go ahead and do the following uh go inside of the agent kit by ingest and go inside of installation and let's go ahead and install inest agent kit so I'm going to go ahead and install this and I'm going to show you the version once this has been installed I'm just going to go inside of the package JSON and show you the version 0.8.3 that's the version I'm working with now let's go ahead and let's use the agent kit in order to do that I just want to do the following let's go ahead and do npm rundev and let's go inside of source app folder page.tsx and in here what I'm going to do is the following i'm going to add a simple input from components UI input and above this tpc methods I will add value set value and a simple use state from react make sure you import that i'm then going to give the input a value and on change a simple event calling set value and setting it to event target value you've probably done this 100 times and this will simply be uh it can stay invoke background job it doesn't really matter great so now let's go ahead and run npx inest cli latest dev simply so we have both our app and the dev server running and now let's go ahead and do the following let's go inside of our inest functions here and let's just remove this one leave this one for 5 seconds like this and change this to um let's just say input let's call it that and then I'm going to change this to be input as well actually I'm going to change it to be value so we control it from this input here i'm going to go instead of the invoke tRPC method so it is inside of routers here i will change this to be input i will change the input to be input well I just call that in a dumb way didn't I why don't we just call it value that would be better sorry so let's go inside of invoke change this to value input dov valueue and call this value and then make sure to save this file go back inside of the functions and change this to hello event data value so let me show you the changes again inside of the page we added use state and the input with value and set value we then added a control to this input with those fields and we modified slightly the invoke.mmutate to pass in the value to be the value from the state we then modified our TRPC router to accept value in the Z object and we've accepted we changed uh the ingests send to pass in value in the data object and of course we modify the function to read dot value and we removed an extra waiting step so now that you've done this let's go ahead and let's run our app on localhost 3000 and let's open our uh development server here so now I'm going to call this uh test value and I will click invoke background job and then in here in the running uh text I should see value test value here and in finalization hello test value so exactly what we pass here perfect that's a very good setup now that we have agent kit installed let's go ahead and do the following in the inest documentation which is outside of the engine agent kit you can find a very very simple example by going inside uh let me just find inest functions step and workflows AI interference here and in here where they show you agent kit for the first time uh they show you this very very simple uh way of doing it so this is what we're going to do I'm going to add the following import so let's now go inside of inest functions here and I'm going to add this agent agentic open AI as open AI and create agent from inest agent kit and then I'm going to go ahead and open this function it's already opened right so basically I'm going to now write inside of here you can leave this hello world this can be unchanged let's create a new agent like this so let me just show you this and you can remove this it is directly open AI right and you can remove the step here as well so instead of writer let's call this summarizer the name will be summarizer you are an expert summarizer you summarize in two words so something very obvious right a very easy task you can give it a model GPT40 if you're using Open AI and let me just remove the things I don't need for now let me remove the step from here since I don't need it so in here we open a summarizer agent like this and since I'm using open AI these are the models that I can use one of them is CH GPT40 if you import anthropic from here you can see that then you're going to have to choose one of these models so just pick the one you like and same is true for XAI or Gemini whatever you ended up using so now we have to find a way to invoke this summarizer with event data value and since you saw when I copied this import I had to fix the invalid OpenAI import because I've copied it from here right so it would be best if you follow the instructions for agent kit on the actual agent kit documentation again you can find it right here under agent kit i simply used this one because I thought it was a very similar example to what we discussed in the previous chapter with the summarizer right but I think it would be better for you to follow the agent kit documentation here because this is the one that is kept up to date constantly so please follow this one so you can again go inside of the agents here and you can find this exact thing we just did we created an agent we called it summarizer and we gave it uh a system prompt and then we gave it a model so we did that correctly now what we have to do is we have to run it so let's go ahead and do that right here i'm going to go ahead and add this summarizer summarizer.run like this and let's go ahead and learn what to type here so I'm going to go ahead and add summarize the following text and I'm going to open back so I can insert event data value like this and now let's go ahead and add a weight here and now we have access to the output here uh so let me just see i'm not sure if I know the API by default but let me try output first in the array is it uh like that i'm not exactly sure let's try and let's just say success okay here and let's rely on the console log or perhaps we can just return out the whole output like this maybe this would be easier to work with so we just created a very simple summarizer agent which is an expert summarizer and can summarize in two words we imported open AAI and create agent from inest agent kit new package that we have installed we specified a GPT40 model another hint here uh I mean just I'm basically just repeating what we previously went over make sure that your environment variables are properly set because as you can see we did not define the API and variable here so it will search for it itself so the name is very important but if you want to name it differently for whatever reason you can do that and I think that inside you can pass the API key and then you can call this you know API key if you want to or if it's not managing to find your environment variable for whatever reason let's try this out now so I'm going to go ahead um and honestly I don't know how this will perform so I'm going to call this I am Antonio and I am a developer let's go ahead and try and doing that so in here as you can see it immediately finished and you can see the step was called summarizer and you can see the content inside so the content is you are an expert summarizer you summarize in two words and then we passed in the role user summarize the following text i am Antonio and I am a developer and in here I think we can already see the output and there we go the output was Antonio developer and if you actually look at the finalization step I think that is exactly what you will find so output.content is Antonio developer amazing so we officially created our first AI background job so now just for fun let's try and change it up just a little bit how about we change the system prompt here actually let's change the name of the agent to code agent and let's call this code agent and call code agent.run and now we're going to say you are an expert Nex.js developer and let's go ahead and just say something like you write readable maintainable code and let's go ahead and also answer you write simple Nex.js snippets like button component Nex.js and React snippets okay let's just do that and then write the following snippet like this so this is still called hello world that's perfectly fine we don't have to change anything else but let's just see what we've achieved now for example I'm going to say uh create a button component i'm going to click invoke background job and you can see this is a bit longer running task and let's see what it created i'm not really sure what the output would be here but here we have it here's a simple and reusable button component using Nex.js and you can see how it actually writes code import react const button with props on click children type button class name and it returns JSX button on click it has class names it uses tailwind it added a class name prop it has children in the button export the default of the button so basically a fully working button so we are you can say halfway there right we just made AI create a React component so the next step that we have to learn is how to make it use tools and run this code snippet it just created inside a sandbox inside of a cloud environment that we can then show to the user as a result so that's what our next chapter will be about and I think that in the this chapter we've done what we aimed to do so let me just check this we chose our AI provider and we've set up in justest agent kit and we even tried a very simple AI step right so basically that's how you're going to write uh agent kit tools and we are then only going to extend it by introducing tools one of the tool can be terminal usage another tool can be create files a third tool will be read files right that's what we're going to do and then we're going to explore networks and routers so we can keep the uh agent in a execution loop so it consist so it constantly creates new components until its task is finished you saw that in the intro video of this tutorial i had a lot of uh coding steps that's by because it is in a execution loop until it completes its task so that's what the tools will be used for we're then going to have the state history a bunch of things and then finally we're going to have the finalization step where it will save to the database and it will uh save the URL of the sandbox so we can show that to the user so in order to advance further and create these tools and things like that we're going to have to establish our sandbox because without the sandbox we can't work right so that will be our next step for this chapter uh we did a very good job we created a very simple interface here on the front end and we are now able to call AI background jobs and we are able to get some AI code right here so later on when we actually connect this to a proper network the function will say coding agent right you're going to see it's very very cool amazing uh so now what we have to do is we have to uh open a new branch and push to GitHub so let's go ahead and open 05 AI jobs branch I'm going to go here and as you can see six files changed one of them was the ingest database upgrade which is Again I'm guessing some cache for the ingest developer server so in here I'm going to create a new branch and I'm going to call it 05 AI jobs i'm going to stage all changes here 05 AI jobs and I'm going to go ahead and click commit and then I'm going to publish the branch and if you want to you can press yes and then this code rabbit uh free code rabbit extension will analyze all of these files or if you prefer you can go to uh where we are now going to open our pull request and in here we're going to have that very same review and here we have the code rabbit summary so we added an input field allowing users to submit custom prompts for code generation so you can see how it connected all of those separate entities of ours from the front- end input to the TRPC invocation of a background job to the actual content of a background job and we now generate code snippets dynamically using an AI agent specialized in Nex.js development so in here we can see step by step we can see the sequence diagram as always you can see how it now features the new agent kit right here and in here we have some potential issues so you can see how it cares about our TRPC value because we are uh lacking any kind of validation we're not even requiring a minimum length so obviously it is telling us that that's something we should add of course and we will later on we're going to change our form schema entirely so you don't have to worry about that right now it's just for demonstration purposes in here it's recommending using constants instead of hardcoded strings and that is exactly something we will do so later on I have prepared very very large system prompts which I have tested on which gave me the best results so I will share them with you and then you will paste them in your app and you will be able to use them as constants and in here it again suggests some sanit sanitization and uh some other limits on the front end uh my apologies in the background job i thought that this was the submit function it is not we will take care of that as well uh and yeah no need to do anything else here because this will not look like this we are going to modify it quite heavily in the next few chapters when we introduce the actual agent network great so I'm going to go ahead and merge this pull request so 05 AI jobs i'm not going to delete the branch simply so I have everything here and then I'm going to go inside of my IDE here and I'm going to go back inside of my main branch and I'm going to synchronize the changes like this so everything is now up to date i'm going to select no for uh this trigger of the code rabbit extension this time simply because this is a merge which we just reviewed right i'm going to open the graph here just for a sanity check to confirm that my last changes were 05 AI jobs and they are great so that marks the end of this chapter and in the next chapter we're going to learn how to create uh online sandbox cloud sandboxes which run Nex.js JS applications which in the following chapters will be something our agents will work on and create new components and run terminal commands into amazing job and see you in the next chapter in this chapter we are going to explore E2B sandboxes this will be the environments where our AI will generate files and create a working Nex.js application in this chapter our specific goal is to create an E2B account learn how to use their command line interface and create a Docker file template for our Next.js project and then push that template to E2B and then we're going to preview that Nex.js application inside a sandbox so we're not going to make AI create any new files and run any terminal commands right now the goal for this chapter is to learn more about the sandboxes how they work and basically to create a template that we are going to use moving on to uh create working Nex.js applications so we're going to start by creating an E2B account you can use the link in the description or the link you can see on the screen to let them know you came from this video as you can see uh in short E2B allows you to run AI generated code securely in your application it's an opensource runtime for executing AI generated code in secure cloud sandboxes it is made for Agentic and AI use cases and some of the uh uh some of their customers are Perplexity Hugging Face Manus and even Grock so these are very very big names in AI here and my experience with E2B was nothing short of amazing right so they are built for AI use cases so for exact thing that we are building here it is generative UI this is pretty much the thing that we will be building here but they have an even deeper use case which I highly invite you to explore yourself so let's go ahead and create an account and let's go in the dashboard after you create an account you will probably be redirected to your sandboxes which looks like this and at the moment you will probably have zero sandboxes running if you head into templates you will probably have less templates than I do you might have three i have five templates because well I explored E2B while I was developing this project you can see that I have this code with Antonio Nex.js thing you don't have this so I have this because I tested it same thing with this no-name template right you probably have desktop code interpreter and base i assume that's the things you have you probably don't have these two so no worries about that and I just want to show you uh inside of your budget you should see your credits so you should have $100 uh free for your new account and as you can see I tested E2B pretty thoroughly so I I really really tested it all day every day and I barely spent $9 so it is quite well optimized for tutorial making so ensure that you have that in your budget make sure that you have the credits uh and now let's go ahead inside of the documentation here and specifically let's go in the CLI installation so you can use brew or you can use npm i used npm here and once you do that you should be able my apologies for this you should be able to run E2B right and you should see a bunch of options on how you can run it and you can shut down your app right so basically E2B should become available after you install uh either via npm or using brew so what we have to do next is we have to authenticate right so E2B O login uh should open up you can see that I am already logged in so uh in here I get that message but you should get a not you probably won't get this message instead you will get redirected to E2B page and from there you're going to have to uh approve the login and then you'll be good to go so once you've logged in uh what I would suggest is try uh listing sandboxes or just try listing something just to confirm that you are logged in so I have no running sandboxes so this is my message i believe that if I wasn't logged in I would get some kind of error here right so just make sure that at least you get a message like this which means okay you're logged in but you have no running u you have no running sandboxes great so now uh what we have to do is we have to learn how to add a new template because right now you can see that inside of our E2B here templates uh you probably have three of them as I said desktop code interpreter and base but what you need is a NextJS template now they do have their own Next.js template which you can use but I don't want you to do that i want you to learn how to create your own template so for this we're going to have to go into the second uh step so we've created CLI and we've connected to our account now we need to create a Docker file template now I have provided you with a GitHub repository with two files that we are going to need for this not because uh I don't want to write this with you but because we have to be very careful about writing these files right so this is what I suggest we do now as always ensure that you're on your main branch you can synchronize changes just in case and then go inside of your source source folder here my apologies outside of source folder so completely outside create a new folder called sandbox templates like this and inside create a new folder which we're going to call nextjs and then in here you are going to create e2b docker file like this you don't have to install any extensions at least I didn't use any for this now this docker file has the content that you can find in the public repository sorry that which you can access by using the link in the description or the link you can see on the screen and when you're in here you can access that file so just go ahead and copy it entirely and paste it here and now we're going to go ahead and uh explain what it does so the first thing we do is we set the environment in our case that's going to be node after that we run a terminal command to install kernel so we updated the system we get the install method for curl and then well whatever else we need to do here i'm not too familiar with configuring docker environments but basically in this part we configure curl after that what we do here is we copy another important file a bash script compile page which we currently don't have so let's create it compile_page.sh make sure to not misspell this because we need it right here and you can find the content in the same uh public repository here i'm going to explain what this does as well but for now just make it like this after we copy this compile page and we put it in the environment right in this docker environment we run this command on it to make it executable then we change our directory to next.js app and then inside of that next.js app we run a command which you've already seen a couple of times create next app so basically the same way we started this project we are now creating a docker which is going to start the project the same way the versions I'm using are 15.3.3 with chat 2.6.3 the reason I'm using these versions is because when I started making this tutorial uh those were the newest versions you already know that now that I'm recording this tutorial there are newer versions than this so if you want to you can upgrade but I'm going to stay with these versions for now simply because I know that they work for me so later on when we finish the project you know feel free to upgrade this to 7.0 and this to 7.0 zero and this to whatever is the newest version but for now I want to stick with these versions because they worked for me initially now let's explain these flags so why do I add d- yes after npx and why do I add d- yes after create next app the reason I'm doing that is because you have to remember these commands will be running in a container in a dockerized container which means no user will be able to interact with them remember when we started our Nex.js application we had a bunch of questions do you want to use tailwind do you want to use slint do you want to use this that so because of that uh I have to uh just agree to all of those things so the terminal doesn't hang right so it doesn't block it can keep moving forward because if it blocks it will not work that's why we have to add both d- yes in front of npx and in front of our command because npx might ask you to upgrade right so we will also agree to that right whatever you ask me I agree to and same is true for running chaten in it and for adding all shatzen components and then what we do is the following we move the content of that new folder nextjs app where we just added Nex.js and all of its components and we move that entire content into home user directory and then we remove the old folder the reason we do that is simply because it is easier for AI to understand that the the place where it's located because initially it will be loaded here we just tell it wherever you are this is where you have the next.js application you don't have to go to any other directory trust me that is much easier for nextj for an AI to understand because otherwise it will hallucinate things this way it's just easier to work with so you might be wondering why did we then even open a new folder if we're just going to bring all the stuff back here because if you try to initialize this command the dot basically means in this folder if you try to do that inside of home user it would fail because in order to initialize a next app it needs to be an empty folder and home user has some hidden files right so it's never really empty that's why we needed to do this trick so that is basically our docker file now let's explain the compile page so the compile page is a little trick that we are going to use to ensure that the next.js JS application is running and that the root page is compiled so basically in here we have a function called ping server which uses curl which we install right here and we are attempting to ping localhost 3000 and we are doing an iteration of 20 uh I'm not sure not too familiar with the bash shell language to tell you if this is seconds milliseconds I'm not sure but basically it's more than enough time for the server to start so it gives it 20 attempts right to try and get a 200 response and once it does it simply uh uh marks it as done and then it runs that method ping server and it goes inside of home user where we just said that we create this project and it runs npx nextdev- turboac so the turbo pack is uh really cool here because it speeds up the uh the start of the dev server so it's actually very useful in this case great so once you have these two things the second part is very important and that is that you set up Docker inside of your project so here I am on the Docker landing page you can use the link you can see on the screen to let them know you came from this video uh and basically the way I set up Docker in my project is by downloading Docker Desktop i use a MacBook so I download it for Apple Silicon if you use Windows you choose your architecture here or if you use Linux uh well you probably know what you're doing then so after you've done that make sure that you have Docker uh installed so in here let me just try and open it back here uh since if I go inside of uh let me just try and find the documentation here docker desktop let's go into overview and in here somewhere we should have setup install and in here there we go so in here we have some deeper documentation here uh on on Mac and on Linux it's pretty straightforward right if you install it uh with a DMG it will add it to the terminal uh as well but if you don't here's how you can add it from terminal as well also if you want to you can use orb stack that's a Docker alternative all right but the reason I kind of don't know how to explain how to install Docker is because I don't know if I'm talking to a person who has a Windows who has Linux or who has Mac OS right so that's why I'm kind of don't want to give you too much information and I don't want to tell you something incorrectly but basically try to research yourself you know uh what you are using right so try and install that and your goal is basically to be able to have docker available right that's kind of the goal you should not get an error in docker and on windows In here you can see pretty similar instructions uh I'm not too sure what this means i don't use Windows uh but in here I think it is important for you to be able uh to run Docker from the command line as well uh but at minimum you should be able you you need to install the Docker desktop package and you should be able to start that application at minimum that's the minimum thing that I expect right so now I'm going to go ahead and start my Docker application actually the first thing I'm going to do is I'm going to try without Docker started simply so uh we can test if uh if the command fails so I want to show you what happens if the command fails first so let's go ahead inside of SDK reference CLI template and let's do template build so in here we have E2B template build command and the way we're going to do this is the following go inside of sandbox templates and go inside of next.js like this so I'm going to try and run B2B template build here and I'm going to give this a name and I'm going to call it vibe next.js test so that will be the first thing I'm going to try so in here you can see how uh it found the E2B docker file and it requested build for the sandbox template ID with this name login succeeded and then it attempted to run docker build and then it failed right so this is the error you will see if your docker is not running so now I'm going to start docker for me very simply I'm just going to open the application docker and then in here uh I will have docker desktop available you can see docker desktop is now running so uh let's see if that will be enough for me to run this and try it so let me see e2b template build let's see this time and there we go so all I had to do was install Docker Desktop and I need to make sure that I have Docker Desktop running that's the important thing for me so you can actually stop this now because it will take some time to build but it's not going to work correctly i just wanted to show you how it looks like when your Docker is not running basically this is the error you will get so just make sure you have Docker running you don't even have to create any image on Docker or nothing we are doing that now right so just make sure you have Docker installed on your system and make sure you open whatever application you installed it can be Orbstack it can be Docker Desktop right uh I'm not sure if you need it inside of here right as I'm I I keep saying that because I don't know what machine you're on i have it inside of my terminal as well i'm not sure if that matters right because you can see that in here it does run the Docker command so it probably does matter the fact that I have it inside of my terminal so uh make sure that you have Docker CLI installed as well if you don't you might even see a different error showing here great but once you get to this part once you get to the fact that after Docker build is being fired you start seeing these kinds of messages right something resolving something transferring it means the Docker is working and then you can cancel it using command C or control C uh and then we're going to run a proper command with a proper uh start command so now in here here's what we have to do this basically uh we have to add E2B template build-ame vibe next.js js test two dash cmd and you have to add compiled_page.sh so now uh let's go ahead and run this again so I'm just going to wait to see this succeed there we go and now I'm going to pause until this part completes because it is a little bit long you know it needs to upgra it needs to upload the entire Nex.js project there with all the packages and everything and it needs to you know install curl and all of that so I will pause until some interesting things show here so you can compare with your process as well so here's an interesting part uh it is running npx create next app and you can see my result typescript types node types react tailwind CSS so it is obviously successfully installing this with no questions asked that's why these parts were so important because if we didn't include this uh it would be blocked by waiting for the user input right that's why that is important it was also successful in copying compile page.sh so we did this correctly as well now I am running chaten in it i'm selecting neutral color i'm forcing everything to install here right so I'm just making sure that I'm not adding any prompts and there we go it's succeeding it uh checked the reg registry it found app globals CSS and now it's installing all dependencies so so far so good now it is adding all components you can see again very successful it found global CSS it is upgrading it and it is installing all of those radics packages which we use for our component so it's we are basically doing the same setup we did for our project but this time inside of a docker container great and now it has finished that part and now it is moving the entire content from Nex.js app into home user and removing the old folder now this is this command actually failed for me a lot during the initial development of this project and the reason was actually because I was missing this d- yes commands so if this part is successful for you as it is to me right now you have pretty much succeeded in doing this so if this part fails for you it is almost certainly because uh you forgot to add d- yes to some of this basically it's hanging on some command and it didn't create the Nex.js app uh great so now what's happening I think you know I'm I'm new to Docker as well i've briefly experienced it before but now what's happening is obviously pushing all of that data to the Docker container on the E2B app and just to confirm in case you're wondering this part does take a while after that part has completed it is triggering the build and here you can track the progress of the build itself so this is more specifically a build of the docker image we're not building the Nex.js app right those are two different things our Nex.js uh app is just a development instance we are building the Docker image here all right so mine uh failed so I will uh it looks like it failed because it is missing the compiled_page.sh command not found and that's definitely because of this i should have uh done this differently i have to find a way to execute this in a different way something like this i will test it out so I know for sure and then I will tell you the correct command so I think that the start command should be this forward slashcompilepage.sh and let me just show you something uh regardless if this part fails or not i mean depending on how I edit this video perhaps I told you not to even run this command in advance right but you can see that I have something called e2b.tl generated in here you can see my start command is compiled_page.sh sh so I have two ways of changing this now i can either change it here or I can change it here but you can see how it remembered all of these things but for now basically this should be the working command so I'm going to pause and try it again and this time it worked you can see that right here it is waiting for the template to be ready and then it is waiting for server to start a couple of times and then finally we can see next.js 15.3 and that signals that it is done template is ready pausing sandbox template so be very very careful here during my initial development of this project I was able to get to template is ready and pausing sandbox template and uploading template but I actually never saw this part let me just go up here it is very important that you can see this part in your terminal because this means that it's actually working if you can't see this everywhere even with this saying it's ready it will actually not be working so just make sure you did this correctly and also on the second run this runs much much faster because half of the I mean the entire project is already uploaded right so you won't have to wait that long but basically this was the final command E2B template build and the cool thing now is that you actually get instructions on how to use this you can see that you can use the name or you can use the ID so I don't know what this actually tells us is the name unique or not i think it might be unique per team uh which then again you know uh depends if you're going to publish this or not uh what does publishing mean well I'm going to explain in a second but basically now you can go find your E2B.l file and in here you can see all the information team ID start command docker file template name template ID and from now on if you ever want to do any changes to here you can just do template build that's it and you can just modify whatever you want from here want to change the name just change the name here and run template build so right that the in the tommo file that's basically where the configuration is now uh great so before we move on now let's go ahead inside of E2B inside of your project go inside of templates and refresh and now if you have done this correctly you should see vibe next.js test dash2 right here and you can see that this says private so just to make things easier for now I want you to do the following i want you to copy the ID of vibe next.js test 2 and I want you to go and go to E2B template publish here and let's go ahead and do the following so actually we need the team ID my apologies so just go ahead and find I think it's inside of your team here find the team ID and copy it and inside of here so you are inside of this uh Nex.js template so you can just do E2B template publish D and then paste the ID of the team and this will make the template public to everyone outside of your team the reason you're doing this is simply because uh it will be easier to connect to it at least that was my experience later on we can easily unpublish it or you can delete it the reason this is kind of uh you know you should be wary of this you should not share your uh template ID with anyone because I can use it and I can uh use your credits right i can spend your budget here so be careful make sure that only you know about this and later I will make sure to find a way to unpublish this so that only you and your team can use this great so now what should happen is inside of your templates when you hit refresh and find that vibe nextjs test 2 it should say public under visibility and that basically means you did it this is now working so now what we have to do is the last part of this chapter we did this we did this and we even did this it's time to actually start this sandbox right let's see if that next.js JS app is actually working or not and lucky for us this is quite easy to do so what we're going to do now is we're going to go inside of source inside of ingest and inside of functions here uh and I think I completely forgot but yeah we have to uh we have to install uh E2B i think I forgot that entirely so let's add E2B code interpreter to our project and make sure you go in the root of your app like this and I'm going to show you the version of this package now so let's go inside of package.json quickly so it is 1.5.1 that's my version now let's go inside of our functions here and let's import sandbox from E2B code interpreter package which we just installed and then what we're going to do is the following let's go ahead and before we create an agent let's do const sandbox ID await step.r run and we can extract the step from here we removed it in the previous chapter I believe so step.run run get sandbox ID that will be the first step we're going to run and in here we're going to attempt to get the sandbox by doing await sandbox.create and inside of here you will simply pass the template ID so in your case this will be vibe next.js test 2 now you will probably have a different name for this because I think if they allow public templates there probably has to be some kind of originality here I guess so once you've created that go ahead and simply do await sandbox set timeout uh actually you don't have to change the timeout i'm going to explain what the timeout is in a second but for now let's just do sandbox.box ID so this will be the step which we are actually going to preserve here and keep throughout uh this entire project because we will always need the sandbox ID and now that we have the sandbox ID uh what we have to do is we have to create a sandbox URL so after the agent finishes let's pretend that this agent now actually connected to this sandbox and then added a bunch of files then what we would do is we would generate the sandbox URL using await step.r run get sandbox URL in here we would get the sandbox again using await and then in here uh we need to create a util called get sandbox so let me just go ahead inside of the ingest and create utils ds and export asynchronous function get sandbox which accepts sandbox ID which is a type of string let's get the sandbox using await sandbox from E2B code interpreter.connect sandbox id like this and then in here just return sandbox so basically I'm writing a function to make this uh reusable you're going to see why later and also let's import this like so so the structure now that you have get sandbox you can do await get sandbox here and pass in uh the sandbox id and then return sandbox.get host 3000 so uh basically what this is it creates the host under the port 3000 why 3000 well we know why because of our uh sandbox template right inside of here we know it's running on port 3000 that's the only port it can run on it's a Nex.js app and this is actually only the host so let's do con host to be that and then return open back https and then post like this and then in here sandbox URL like this are you ready to try this out now make sure you have imported the get sandbox right so let's go ahead and do it npm rundev in one npx ingest cli dev in the other it is running perfect let's go to localhost 3000 make sure you have your ines development server here and I'm just going to do uh create a button component again why not and let's go ahead and see what's going on here oh so there we go it is failing so something uh you can see the error invalid API key so we can cancel this run because I forgot to add the API key uh I'm constantly not reading this the way I should so let me just go ahead uh and add click on API key here uh and we can find it at the dashboard so let's go back inside of our dashboard here uh you can see I already have some so I'm going to click create new key here and you can find it here under API keys so create new key vibe dev and I'm going to click create key here i'm going to copy that key and let's go inside of environment here e2b and let's add it so it's going to be E2B API key like that and if you add it like this I don't think you have to explicitly add it anywhere because this is what it will be looking for so uh I'm not sure if I can find the documentation for this specifically but I think that now it will be working let's try again invoke another background job and let's see do we get any errors or do we successfully get a running template we're going to see get sandbox ID has succeeded and now it's doing the coding agent thing it's generating some code and now it's grabbing the sandbox URL and in the finalization here you should see the output of an AI who created a component and you should see an actual URL let's try and visit this URL fingers crossed and we should now see a Nex.js application and we are a completely empty Nex.js application hosted in E2B started from our background job you are halfway there you can already uh kind of tell what the next steps are we are going to dive deeper into E2B sandbox API now and we're going to learn how to run terminal commands how to create files how to read files basically how to translate what it's now doing here very simply as an output into actually modifying the code in this sandbox amazing amazing job i know this chapter wasn't too easy a lot of new things Docker Docker files all of those things but if you've come this far you did it amazing amazing job so let's go ahead and mark this as complete and yes this uh will stop working after some time and that's completely normal so after about 5 minutes I think by default uh this link will show an error right so that's normal don't worry we can change the timeout later so now let's go ahead uh and let's merge this so I'm going to go ahead and I'm going to open my source control here i'm going to go ahead and create a new branch 06 E2B sandbox let me just confirm that's my chapter name so sandboxes i'm going to go ahead and stage all of my changes including the Docker files of course and I'm going to do 06 E2B sandboxes here and I'm going to commit and I'm going to publish my branch again there is a free code rabbit extension you can use if you want to review your changes and learn about all the things you can do differently in your code so if you want to you can click review all changes or if you're like me and you like to see uh the summary and all other things you can use their pull request function so now I'm opening my new pull request here which I will merge so let's go ahead and review it and here we have the code summary so what I'm very impressed with is how well Code Rabbit understands what we just did so we introduced a sandbox environment for Nex.js allowing users to create and access isolated Nex.js instances we added functionality to generate and return a unique URL for accessing sandbox next.js app so quite impressive that it understood the entire context of this pull request with nothing more than files very very very nice so in here we even have an entire sequence diagram demonstrating how that happens so once the user triggers a hello world background job we go ahead and create a new sandbox with our template name after that we return the sandbox ID and we have it for that session of that background job we then use our new package E2B code interpreter to return a sandbox instance and from it we extract the sandbox URL amazing and you can see how it even has some related pull requests it detected where we initially added hello world so if you were working in a team if this was some big operation you can now link pull requests automatically with this extension amazing so in here it has some potential issues regarding our TOML file but that doesn't matter because this file is not generated by us in the first place so it is okay for it to be like this in here it is suggesting improving the compile page shell script which could be completely valid i'm don't know bash i'm I'm also mixing bash and shell i'm not even sure what is the correct name so for all I know this could be completely correct but since I want to be very careful about this part you know I'm not going to change it because I know it works right so good enough for me at the moment uh great uh so in here it recommends adding some try catch all of the things which we will add later but in a different syntax because we will implement the agent network and the agent retrying and it's going to work in a different way it's going to be using tools so overall pretty good summary pretty good review let's go ahead and merge this now as always I'm not going to delete my branch simply so I have access to all of my progress here amazing amazing job so as always go back to your IDE here and change to main branch and then click on synchronize changes and as a final sanity check you can go ahead inside of source control inside of graph and you will see 06 E2B sandboxes have just been merged amazing amazing job i believe that marks the end of this chapter and see you in the next chapter where we are going to learn how to make our AI use tools such as terminal to install some things and actually modify these sandboxes amazing amazing job in this chapter we're going to add tools to our AI the tools we are going to add are going to be the terminal tool which will allow the agent to run commands create or update files tool which as its name says will allow the agent to create or update any files within its environment and finally we're going to have read files which will be able to read files we are then going to add a completely new prompt for our agent and we are then going to implement the agent network and the routers so we are going to heavily rely on agent kit by ingest you can use the link you can see on the screen or the link in the description to let them know you came from this video so in here what we are going to do is we are going to uh add some tools tools are used to extend the functionality of agents for structured output or for performing tasks so for example they are used to call code enabling models to interact with systems like your own database or external APIs like B2B so let's go ahead and let's create a very simple tool which will be allow our agent to interact with the terminal so the first thing we're going to do is ensure we're on the main branch and we are going to synchronize our changes and just confirm your last merge was E2B sandboxes after that let's go inside of source inest functions now in here we're going to do the following after you create the coding agent uh go ahead and do the following right after your model add tools open this array and let's create tool which you can import from ages uh a inest agent kit in here let's go ahead and give this tool a name it will be called terminal add a description use the terminal to run commands and add the parameters which the AI will pass to this tool it will be a very simple command which is a type of string and after you have added the parameters and the handler method extract the command from the first argument and extract the step from the second argument in here you are going to return the step execution await step question markr run the reason we need to use question mark is because step can be undefined so let's go ahead and run a step called terminal it's going to be an asynchronous method inside of this step and the first thing we're going to do is we are going to create an object called buffers inside of here we are going to set std out to be an empty string and std error to be an empty string as well now let's open a try and catch method instead of the try let's grab our uh let's get our sandbox here using await get sandbox and pass in the sandbox ID then let's grab the result of await sandboxcomands and pass in the command so we are reusing our get sandbox method from utils i also imported zod so make sure you add this as well uh and we are basically doing the same thing we're doing right here we are establishing the connection with our sandbox using this simple util here so we don't have to repeat this every time and now what we are doing is we are running a command so you can learn more about this uh by going inside of the E2B documentation and simply learning about the command let me see if I can find that here here we have the commands so this is how you basically run commands in your environment perfect so now let's go ahead uh and define some more settings here so after we run the command let's define on std out grab the data which is a type of string and for buffers std out simply add that data and the same thing on std error so data is a type of string and in here simply add buffers std error plus equals data so we are handling all of the results of running the terminal commands in this object so we're going to know if the terminal command succeeds or if it fails that's why it's important to keep track of the result and then let's go ahead and let's return result std out and then in the catch method let's extract the error here first let's do console simply so we see this in the terminal open back and you're going to say command failed render the error and then you can use forward slashn to break into new line so it's more readable std out will be buffers std out and then go ahead and break line again std error will be buffers std error so that's going to be the console log and then you're going to return the exact same thing this will basically tell the agent what went wrong with additional information about std out and std error so yes just make sure that you don't accidentally type this incorrectly as it is important for AI to understand what's going on and that is our first tool our agent now has the ability to use the terminal it uses sandbox API for this and it will keep the results of this uh terminal execution so either a success message or an error with detailed information about what happened because commands can fail and thanks to ingest they will automatically retry but now with the context of what happened so if you're building nex.js with me for some time you know that sometimes when we install a package which doesn't support next uh react 19 it fails because we need to add d-leacy pure depths so if that happens here it will first fail and then the AI will read the message and say oh okay I need to add d- legacy peer demps and ingest will automatically retry the terminal step with that new information and then it will succeed so that's how powerful injest background jobs are and now they're amazing inest uh agent kit so now that we have finished uh the terminal tool let's go ahead and create a new tool this one will be called create or update files the description will be and let me just see i think I'm doing something yes I'm doing something incorrect here i think it needs to be here and add a comma here there we go so yes so just make sure you're doing it at the end of this create tool bracket right here the description will be create or update files in the sandbox let's go ahead and let's add the parameters it's going to be an object of items and it will accept the files files are going to be an array of objects and inside we're going to have path which is a type of string and content which is a type of string as well and it's going to be the only thing we will accept so now we can build our handler method inside of this handler method let's go ahead and let's extract a few things the first things will be the files and the second thing will be step and network and now in here let's go ahead and let's get the new files by doing await step question mark run create or update files open the asynchronous method here and let's go ahead and open a try and catch block let me just add catch here there we go instead of try let's create updated files by first looking at network.state.data.files or an empty array then let's get the sandbox here await get sandbox and pass in the sandbox ID and now for const file of files await sandbox files write file.path file.content updated files file.path is now file.content so basically when the agent gets access to create or update files tool it will give us a structured input of files it just created so imagine this first part which we already have we've already seen it create a a few files I think there we go so here's a simple button component and then it just returns jsx so now it will do exactly that but it will recognize the input this accepts uh accepts so what it's going to do is it's going to return back an object let me try like this it's going to return an object like this and it will have app psx and then in here it will be you know paragraph app page this is how it's going to look like and then the same thing for any new components right this is what it's doing now and then we're going to iterate over each of that and we're going to write that to the sandbox file explorer using files.right which is the similar API like sandbox commands so that's how we know which file to write where and then we just keep a track of updated files internally in our network state simply so we can later tell the user which files were changed because technically we could just ask it in the prompt hey you know when you finish also tell me which file you changed but you can't really rely on that because AI has a token limit it can only talk for so much but for this part you can rely on this right so each file it actually writes in the sandbox box in the file explorer we are going to save it we are going to keep track of it and the reason we are choosing the format of an object rather than an array is because this way it is very easy to to overwrite any files if they change by invoking this step again because this step can be called 50 times for all we know that's why we are choosing an object rather than an array so we can just simply overwrite any path if it changes and then let's go ahead and do return updated files and then in the error here let's return error and simply render the error perfect and then uh outside of this if type of new files is equal to object network state data files will be new files so why are we waiting for this to be an object so the new files are basically the return of this step this step can either be an object or it can be a string so we are basically waiting for it to be an object and only then do we store it into our internal network state perfect so that's another tool finished now let's go ahead and let's create another tool with a name read files now in here let's add a description read files from the sandbox parameters Z dot object files Z dot array and Z dot string inside now let's go ahead and let's add a handler method again an asynchronous method and in here we are going to return await step and we just need to extract the step from here so let's do that first extract the files from here and then extract the step from the second step be mindful if you forget to do this you won't get an error simply because we have a step defined elsewhere we have it here so be careful you always have to extract the step from the tool because it holds different context so step.run read files asynchronous and in here open a try and catch block in the try block connect to the sandbox await get sandbox sandbox ID in here open the contents array and for const file of files push to that contents array so const individual content is await sandbox files read file so we read the file and then we simply push the path to be file and the content next to it so in here it doesn't really matter how we store this data because this is not for us this is for the AI if they if it needs to read data so yeah let's just fix this path so if we in our prompt instruct the the the AI agent to read before they do something they're going to use this why would they need to read something well so they don't hallucinate right so we tell it if you attempt to use a chat component make sure to read inside of the components folder so then it's going to use this tool to attempt to read a file and if it doesn't exist it's going to say "Oh okay then I need to create it or I need to use something else it's basically not going to hallucinate or assume a tool exists that's why this step is quite useful and also why we don't really care about the format too much because AI can read from various formats here and if this fails we return an error like this and that is the last tool that we need what we have to do next is we have to update our prompt and tell it that it can use these tools i have prepared a prompt for you in my public GitHub of assets you can use the link you can see on the screen or the link in the description to access it now be mindful of something i am not a prompt engineer i have no idea if this is a good prompt or a bad prompt i have generated it using AI itself so I assume it's okay i have found it to work quite well for my use case but you are free to modify it however you want it i I started out very simple like it was almost just like one or two lines and then I had to addit more and more and more instructions until it understood things very well and I found this to be kind of a very very good uh at least starting point if nothing more right but the cool thing about this project is your app can get twice as good just by adding a new model so if OpenAI or Enthropic release a new model all you have to do is use that new model and your app is suddenly twice as good so that's the cool part about working with AI right so copy this prompt from my assets let's go inside of source and let's create prompt.ts and let's paste it here so I'm going to slightly go over it just so you understand what I'm doing here so you're a senior engineer working in a sandboxed Nex.js 15.3 environment why that environment well because that's what we define here so I'm telling it exactly where it is running and then I tell it some tools you can write files with create or update files you can execute commands via terminal i also tell it to use d- yes simply because uh it's not a human so it uh basically we we must not get it in a position where the terminal waits for human input then I tell it you can read files with read files so those are the first three instructions that I give it i then tell it you know some general rules don't install package JSON or log files directly you can install packages but don't modify the these directly i tell it the main file is in the app folder page.tsx i tell it that all chats components are pre-installed and imported here and then I tell it some general rules like you must never add use client to layout this must always remain a server component uh I tell it to never create any CSS or SCSS files styling must be done strictly with Tailwind and basically some rules like that so you can of course tweak this if you think you you can modify it a little bit of course maybe I will modify it during this tutorial but basically it's just a bunch of rules that I have added after I experienced it fail so after I saw that it does something incorrectly I added a new rule for that and this is important the final output so after it's fully completed I instruct it to return this type of format task summary and inside uh a description of what it just did so it needs to return with this and you're going to see why in a second this is super important and this is why I'm very strict about it because this is the only way to terminate the task if it omits or alters this section the task will be considered incomplete and it will continue unnecessarily so now that we have our new prompt let's go inside of inest functions.ts and let's go ahead and change our code agent here and let's extract the open AI here a little bit and now what we are going to do is we're going to change this model to be GPT4.1 default parameters here will be temperature 0.1 now if you're using uh something that is not open AI this might not exist and that's completely okay you don't have to modify this what temperature means is randomness so the larger the number here the more random is something going to be and when it comes to generative UI I kind of want it to be deterministic and reliable rather than completely random but I give it a little little little chance of randomness so if you're using grock or anthropic you don't have this probably so that's that's that's completely okay right you can even do without this in open AI and the reason I changed the model is because 4.1 is much much much better at generating UI than 40 and for Antropic the better model is 3.5 set for Grock or Gemini I simply don't know and as I said with Gemini I have problems running these tools you can try but for me I just got errors so now let's go ahead and modify the system here to use our prompt constant from at prompt which we just added so just make sure it's this one perfect now let's go ahead and let's add a slight description here an expert coding agent there we go so I'm just going to bring back this temperature 0.1 if you're using Open AI you can add this so both you and I will get similar results i hope great now that we have these tools we are still not ready to try them out just yet because what we have to do now is we have to add life cycle here so after the array of tools ends so make sure that you find where the tools end right go to the bottom here we're going to add life cycle and in here we're going to get on response and from here we're going to get the result and network and now what we're going to do here is we are going to check if the last message that is in this cycle because this is a cycle right this is not going to be linear it's not going to go uh using the terminal then create or update files and then read the files and we're done no it has access to all three tools equally and it will create its own plan it might use them 50 times in a row that's why in the prompt we tell it when you are finished when you know that you're done go ahead and return the task summary so now in the life cycle we are going to uh extract the last message from the assistant and we are going to check if that message includes the task summary if it does we will break the cycle and then we can go ahead and do these steps where it actually shows to the user what it generated so in order to implement that part we have to go inside of utils here in the inest where we have get sandbox let's export function here last assistant text message content it will accept a result which is a type of agent result from inest agent kit let's go ahead and do const last assistant text message index which will be resultput find the last index extract the message and we are going to find the index of a message whose role is assistant so we know okay this is what assistant said last then let's extract the actual message content from that index so result dot output last message index as a type of either text message again from ing inest agent kit or unde so it can even not exist right and then let's return message question mark.content and we're going to add a turnary below it if type of message.content is string we're going to simply render message.content otherwise we will do message.content domap get the individual inner content and simply return that inner contents text and then we're going to join it all in a single string and then finish the outer turnary by adding or undefined here like that perfect i'm going to pause the screen just so you can double check your code now let's go ahead here and let's use that inside of here so I'm going to do const last assistant text just this last assistant uh let's do message text and in here we're going to call our last assistant text message content which we can import from the utils and pass in the result like this and let me just see if I did something incorrectly here so uh life cycle on response uh I have to end this here there we go perfect and then we're going to check if last assistant message text and if we have network if last assistant message text doinccludes task summary add to the network state in the summary key last assistant message text like this and then outside of this outer if clause return result and let me just see what I did incorrectly here so I think I have to end this maybe like that let me just try and fix this quickly so let's see i think I don't need this part do I need this okay so that was the extra perfect so basically what we're doing here is we're extracting last assistant message text using our util last assistant text message content which simply finds the index of the last message whose role was assistant and then if it is type of text message and if it's string it just returns that content but there is obviously a special type of message where it can be an array of strings so in that case we simply join that into a single string using a very simple method and then once we parse that message if we have network available and if we have last assistant message text and if that message includes task summary which is our rule here right to return that if it's done we store the network state data summary last assistant message text and we return the result and what we will be able to do now is the following go below this entire coding agent and create a network the network will be create network from inest agent kit like this and in here go ahead and add the following the name coding agent network agents will be our coding agent or whatever we called it it we called it code agent so let's just add it here code agent max iteration will be 15 now this will basically this is a number that will uh limit how many loops the agent can do so what is a loop as I explained previously the agent can pretty much do things indefinitely if it wants to right we need to find a way to tell it to stop so we are doing that currently using the task summary right but there has to be some kind of limit we cannot really let it go forever so I'm going to say if you reach 15 iterations you're doing something wrong you should have already been done and this is too much and I have to stop you because you will use all of my open AI credits that's what max iterations is now let's add a router here which is an asynchronous method and it can extract network let's add the summary here to be network data summary and if we have the summary we are going to break this network otherwise we are going to return uh the agent and the agent will be code agent like this there we go so this is how we break the loop if we detect this summary in the network state we break the network otherwise we return code agent right so the code agent will call itself many times until finally we detect there's a summary if we detect a summary we say great you are done perfect so now I have a bunch of these errors that I have to fix so I'm going to go ahead and just see did I maybe remove an important bracket or something uh because something seems to be wrong here i'm going to start by trying to reload my window just to see if that maybe fixes it looks like it did not fix it so I'm going to go ahead and see uh exactly what I did wrong okay I think I found it it's all the way uh up here uh somehow this happened i'm not sure how so create network there we go perfect and now the only error in our app is this unused network variable everything else seems to be working no errors seem to be flying around perfect so once I have this network what I can now do is I can run this network instead of running the actual code agent so I will remove this now and I will do con result that comes from the entire network and I will simply pass in event data and I believe it was value that we pass so let's go ahead and do that and then in here what we are able to do is this part can stay the same and in the result part uh we can actually do the following we can show each file that was changed so next to sandbox URL let's do it like this so URL is sandbox URL the title will be for now just a fragment files will be result state data files and summary will be result state data summary so right now these are a type of any depending on the version you use maybe they will even become errors don't worry we will add the types later so if we've done this correctly we should have working code now especially after you change this and if you add this prompt I believe this should be working now keep in mind uh it is hard to be reliable and deterministic with AI agents i might get one result and you might get a completely different result and that will actually quadruple if you're using a different AI model than me so again the my biggest advice is use the same model I'm using use the same open AI you even put the same temperature this will make it much more easier for you uh to have the same result as me let's try it out now so uh I have my app running here and I'm going to go inside of here and I will create um create a calculator app let's try this and let's invoke a background job let's see maybe it fails immediately maybe it works we're going to see uh let me refresh the runs are they working are they not working not sure okay it seems it seems like there is some kind of error happening here so let me just try and debug this all right so what I did is I've shut down the npx inest cli i have shut down npm rundev and I restarted both of them so do that shut them down and restart them and let's see what's going on so I managed to get the sandbox ID that's a good start it means we successfully started the sandbox and now we are running the code agent and you can see here we are running it with all the tools available the tools to use the terminal the tools to create or update files the tool to read files and now it will use those tools so there we go it used create or update files let's see what it created it created calculator.tsx tsx and then it imported that calculator from that file at least that's what it says it did and it returned back the code sandbox URL let's check it out i'm going to click here and if it worked we should now be seeing a simple calculator app fingers crossed and looks like something went wrong so what happened here what happened is that it forgot to use use state but here's the cool part for you maybe this doesn't didn't even happen i don't know right uh it can behave randomly so how do we fix this thing well we can fix it in two ways we can fix it by uh making the prompt even more strict right we can find the places where I add for example in here I added you must never add use client to layout tsx line 13 maybe it's confused because of this it reads this part and then it gets confused let's remove that part let's search for use client again file safety rules again never add use client to app layout tsx maybe it gets confused by this so I'm going to remove this where it says never add use client because it seems like u it is avoiding to add use client in that case i have another instance of use client here where it says if building a form or or interactive element include proper state handling and add use client to the top perfect that's a good example only add use client at the top of files that was react hooks or browser APIs never add it to layout tsx so I will remove this part as well simply because I feel like it is leading it away from using use client properly so let's see if our next iteration will be better so I will add it again create a calculator app uh and if it doesn't work then we can instruct it in this prompt further right and as I said for you maybe it worked first try i don't know that's kind of the part about building this type of apps um you have to simply rely on luck sometimes right sometimes the agent will perform very well sometimes it will perform very bad and the better this models get the better your results will actually be and as I said uh your prompts will also get better with time right so let's go ahead and see if this was any better let's see if it added use client this time and there we go i have a working calculator app generated by AI can you believe that AI has generated this now as I said I have no idea what kind of result you are going to get right i don't think you will get the same result as me your might have some colors your might not work again if it doesn't work again you know you can try and go inside of here and then explicitly tell it you know uh be mindful of use client where it needs to be added right you can tell it that and then it definitely won't make that mistake or you know uh read through my prompt and see if there's something you don't like here or maybe paste my entire prompt inside of chat GPT and tell it to improve it somehow so for me I removed those couple of lines for use client perfect uh let's try build a landing page so you can now pretty much you know you're pretty much let's say finished when it comes to backend side you can now only improve these tools and improve the prompts so what we're going to do next is we're going to implement saving this to the database and we're going to implement creating a summary of what it just created so we can save that to the database and kind of return a message back to the user and if you want to uh you can instruct it to use some package like use drag and drop use framer and then you will see it use the terminal tool so let's see if it managed to create a landing page there we go and may I say a pretty good landing page right very impressive perhaps you should try with the landing page example because it doesn't use any use client or things like that i'm very very impressed by this is better than I expected so let's try telling it to use framework this time build a landing page use motion package let's try this so in here we can see that now it is using terminal and we can see the result added three packages right so let's see if it actually used uh that or something else i think you can also click on the code agent right before it uses the terminal and click on the output and in here you can see npm install framer motion so that's what it run i'm not sure if that's the newest version of framer maybe this won't even work i don't know but let's click on get sandbox URL let's click here and let's see maybe it will be broken yeah looks like this doesn't work it should use motion package not framer motion so as I said uh it's not perfect right you can break it every now and then but you can also improve it just as easily right as I said Claude Sonnet 3.5 is by far the most reliable coding agent because it just it is up to date with everything it just knows everything right but you will hit limits very very soon so your best option for now is to create this kind of app right using open AI and simply improve the prompt as much as you can so I did this myself and I am not a prompt engineer so you can definitely create this better than me your starting point uh should be this you're a senior software engineer and the most the other important part is this give it a very important ending so this should be your ending everything in between after before final output you can change so I wrote all of this with the help of AI and I basically added more things as I saw uh they as I saw some things fail so for example sometimes it attempted to run dev itself or build so I told it you must never do that right it's always working uh so yeah you can learn how to prompt a little bit better and you will get better results or you can simply use a newer model so how about we try build a conbon board use react beautiful drag and drop let's try that maybe we will have some uh better results with this package so this is the result of the query to build a conbon board as you can see the first terminal command actually failed and we can actually see the error here so let's go ahead and scroll down here error error unable to resolve the dependency and it probably told it that it needs to use uh legacy peer depths you can see this retry this command with d-force or legacy peer depths and then what happened is it simply retried that and you can see then it worked so that's the power of ingest and that's the power of returning the result of the terminal tool right so we tell it the command failed and we tell it why it failed so that way it knows how to retry and my get sandbox URL uh was this what seems to be a working conbon board test amazing it seems to have some issues it's missing a prop set here but honestly other than that pretty damn good look at this amazing right it even highlights where it's going to land very very cool uh great so I think that marks the end of this chapter uh till we finish this project we will add some methods to improve the failing builds right we will allow the user to tell the AI like hey you forgot to add use client so it understands what happened previously and then it can just easily fix the issue that's at least what we are going to attempt to do so even if something fails uh we will allow the user to instruct the AI and tell it hey it failed can you please fix it because you know I saw lovable fail i saw replet fail i saw v 0ero fail all of these apps fail right they are just AI it's a it's a language model after all right so it can definitely fail but I think it is super impressive given the fact that we built it so soon and so fast amazing amazing job let me mark all of these things as complete here and now let's go ahead and branch out so 07 agent tools i'm going to go ahead and create a new branch 07 agent tools i'm going to stage all of my changes 07 agent tools i will commit and I will publish my branch as always you have a completely free code rabbit extension you can install inside of Visual Studio Code if you wanted to review your files and now let's go ahead and let's open a pull request so we can merge our changes and so we can review them here with a summary and here we have the code rabbit summary so we have enhanced agent capabilities with multi-tool multi-agent network for sandbox interactions including terminal commands file operations and summary extraction we also introduced a comprehensive system prompt outlining coding standards and environment constraints for improved code generation and consistency perfect so that's exactly what we did and in here we even have a sequence diagram of how it happens so once the background job is triggered we can see that now the coding agent can use the terminal create or update files or read files as needed and then the tools return results using std out using files contents or anything else and depending on that the code agent is either calling another tool or finally it returns with the last message which includes the task summary tag signaling that it is over and then we can return the sandbox URL so in here it actually uh recommends not doing a double turnary instead ending early here so that's quite a good suggestion we could possibly do that then below here it fixed a typo to agent that is definitely a mistake great uh and in here is something quite interesting so what I do here is if I fail I simply return an error so I practically never store anything if it fails but in here it recommends actually doing partial saving right so if there is at least some files which were successfully created save them but still throw an error so quite a good suggestion but in my experience if it fails on one file it will fail entirely because uh this doesn't mean that it wrote incorrect code if it throws an error here it means it lost access to the file system that's why I'm not exactly worried about this i will pretty much always expect it to be able to write all files it needs but very good suggestion here to handle partial success i will look into that let's go ahead and let's merge this pull request here i'm not going to delete the branch as always so I have access to it right here and now that we are here let's go ahead and go back inside of our main and let's go ahead and synchronize our changes and that should officially mark the end of this chapter just a sanity check here there we go we just merged 07 amazing amazing job we are now ready to start building our UI see you in the next chapter in this chapter we're going to implement the messages entity this will include creating the actual message Prisma schema the fragment Prisma schema and then we're going to modify our current TRPC procedures and our background jobs to use those new schemas and save user prompts and AI responses in their appropriate models so let's start by creating a simple message schema in order to do that we have to go ahead and visit our schema file before you do that as always confirm that you're on your main branch and if you are unsure if you have any unsynchronized changes you can always click this and confirm and just make sure that chapter 7 is your last merged change here great now let's go ahead inside of Prisma and schema.prisma if you have a folder with migrations here you can delete it because we're going to remove pretty much everything inside of here right so we're going to create a whole new schema now so let's go ahead and create a model message inside create an ID which will have a type of which will be a type of string is going to be an ID with the default value of uyu ID after that let's go ahead and create a content which will be a type of string let's go ahead and add a role which will be a type of enum so let's create an enum message type and let's give it uh my apologies not message type message role which can be a type of user or assistant and then you can go ahead and use that right here so simply assign the role to be message ro just like that and now we're going to do what I started to do which is the message type so the message type will either be a type of result or a type of error and let's go ahead and give this a type of message type so in case the AI response fails we are going to treat it as an error meaning that the AI will simply return uh I wasn't able to do this generation for whatever reason please retry and now let's add the usual created ad field which is a type of date time and the default value of now and let's add updated ad which is a date time as well and it has a special decorator updated ad which is a very cool decorator because what it does is it will automatically update this build when we update the message model and now let's go ahead and let's create a fragment model so the fragment model will also have an ID of string and the default value of UU ID and it will have a relation to the message so let's add a message ID to be a type of string and it needs to be unique now let's add a message here to be a type of message give it a relation decorator targeting the fields message ID which we defined above referencing the ID field in the message model and let's add on delete here to be cascade so if this message gets deleted the fragment gets deleted as well and now we just have to fix this error by adding a proper relation here in the message so the message does not have to have a fragment if the user is sending a message there will be no fragment only for the AI response will there be a fragment that's why we're going to create a fragment field and we're going to make it a type of fragment but it's going to be optional like this and then let's go back inside of the fragment model and let's create a sandbox URL to be a type of string the title to be a type of string and files to be a type of JSON so this is quite cool uh it's very nice that possess allows this and it's perfect for our use case because files is not exactly something that in my opinion makes sense to create a whole new model for because it's just a simple mapping of the file path and the content and it can be pretty much infinite in size well obviously not infinite but you know what I mean so I think this is a very good use case of using JSON in posgress and then we can just copy the created ad and the updated ad from the model above just like that now in here you should have no errors and again make sure that you're using the Prisma extension simply so you have the syntax highlighting and it will tell you in advance if you've done anything incorrectly here so what we have to do now is we have to push this so let's go ahead and shut down our app make sure you have shut down your ingest server as well and I will now run npx prisma migrate dev and let's just wait a second for this to connect to our database so I have gotten an error in your case you might not get an error but I think this is because yes it detected some drift your database schema is not in sync with your migration history that's because I told you to manually delete the migration folder this is not a problem we are working with development data here so let's use npx prisma migrate reset first and let's just reset the entire thing so let me just confirm this um and even if this doesn't work you can always just create a new postgress database and then just go instead of environment and just use a new database URL right that's like the ultimate brute force you can do so after I've done my migrate reset I will try migrate dev again and this time with no problems I'm going to call this message-fragment and there we go just like that we have created new schema here and now you can go ahead and run the npx Prisma studio and in here you should see the fragment and the message as the models meaning it successfully created that perfect so now let's go ahead and let's actually use these things so what I want to do now is I want to go inside of source and I want to create a new folder called modules so I like to have a module-based structure in my application so instead of having my procedures written here randomly I will have them in their own module so I like to separate modules either by large chunks of my application like homepage landing page pricing or by entity models that I have in my database so for example let's go ahead and let's create messages in here so inside of here I will keep everything message related so for example one of those things would be all the things that go on the server uh regarding messages specifically all our procedures so now that we are inside of here we're going to import uh initc router or create tRPC router from trpc init and let's export const messages router here to be create trpc router and then inside of here let me just quickly check inside of my TRPC routers app i seem to have this existing one called invoke so now what we're going to do is we're going to create a create procedure so this will be accessed through as message.create this is how you will call this that's why it's called create and not create message because it would be redundant message dot message create or create message right makes no sense so let's add a base procedure which will of course be a protected procedure later on in the tutorial for now it's perfectly fine to be a base procedure let's go ahead and define an input here and I'm going to set this to be uh the value it can be the value it can be the prompt i think value is good enough and let me just import Z from zod let's go ahead and set it to be a string and let's give it a message is required error great and then let's go ahead and let's chain mutation here is going to be asynchronous let's dstructure the input from here like this and then inside of here what we're going to do is we're going to create a new message by using await Prisma from lib database and then go ahead dot message dotcreate and pass in the data inside and let's add the content to be input value here like this and let me just see what else do I have to add inside because I already forgot how my schema looks like so I have to add a role and I have to add a type so my role here will be user and my type here will be result right there's no loading this is an instant message created by the user perfect so I think I actually don't even need to uh put that in any type of constant i think this works just fine and what I'm doing after this is I'm actually invoking my background job so let me go inside of the routers here and let me just copy this part inside of procedures and let's go right here so let me import inest from the inest client let me show you my imports a bit simply so you're on the same page there we go and obviously we're going to have to change this as well it makes no sense to be called test uh and uh this is what we should actually do we should keep this as created message or new message and then simply return created message simply so our API response has some kind of well response for the user back perfect now that we have the basic message router created with some basic validation here let's go ahead inside of TRPC routers and let's remove everything inside of here and then in here add messages messages router you can import the ingest you can you can remove zone you can remove inest and you can remove the base procedure just like this and this is how we're going to add all other uh module related things inside so later when we add fragments it will be fragments router and we will control all procedures inside of its own module right like this great so now obviously we need to fix some things in our page I believe so let's go inside of source app page and in here this is now create message this will be TRPC dot messages.create and the on success is the same in here we can just say on success message created and then let's go ahead and let's use create message is pending and create message.mmutate just like that so right now uh this should still work exactly the same right let's go ahead and just quickly try it out uh just to make sure we didn't accidentally break something so npm rundev in one npx inest cli latest dev in the other one let's go and we can install the new one if it appears it's okay and let's go ahead and open local host 3000 here and I'm going to do create a landing page simply because this is the simplest thing that most likely won't go wrong there we go looks like it is created so I'm going to click invoke a background job here and looks like message was created i'm going to go inside of my inest developer server here and I'm going to wait for this to complete and here we have it it is complete and quite a nice result i'm always impressed by its landing pages it seems to have uh gotten that it seems to have gotten very good at creating landing pages uh great so looks like everything is still working and now what we have to do is while we are storing the messages from the user we are not storing the messages from the AI so in order to keep track of that how about we extract the messages here by using use query from tanstack query so just make sure you add this import here pass in tRPC do messages and I just remembered we didn't create any so let's simply go inside of the messages router which is inside of your modules here and simply create uh let's call this get many base procedure the input doesn't really matter for now let's just do a query here again it's going to be an asynchronous method and in here what we're going to do is get the messages to be await Prisma message find many and how about we do order by and let me just see I have to use updated at or created at let's use ascending and return the messages like this and just like that we have our get many procedure so now we can go back here and add it there we go get many this will be query options here and then inside of here let's go ahead and do it below the button json.stringify messages null 2 so now you can see that I just created this create a landing page with the ro user so if I go ahead and do create a red landing page and invoke this background job and refresh this page you can see that now I have create a landing page and after that I have a create a red landing page so let me go inside of my procedures and change the updated ad to be descending and refresh and then the newer message appears at the top and if you want you can wait for the result but uh you know it's it's not that important right now but it definitely created a red landing page great so now again I'm expecting that besides having these steps to get sandbox ID create our update and then finalize i also needed to save this entire thing to the database so that we can access it from the UI and not from the inest developer server so let's go ahead back inside of ingest functions here and then we're going to create a whole new step here at the bottom so after we get our sandbox URL we have to go ahead and actually save this to the database so let's do await step.r run save result asynchronous method like this and in here let's return await Prisma dossage whoops we have to import Prisma from lib database so just make sure you add this import and we're basically going to save the content so prisma dossage.create the data will be the following content is going to be result state data summary and role will be assistant and type here will be result like this and let's also extend it a bit further by also creating the fragment relation let's pass in the sandbox URL here uh sandbox URL doesn't exist did I do something incorrectly in my schema or is it just the syntax that I didn't finish it definitely does exist here so perhaps I just have to do result actually sandbox URL like this oh my apologies this is not how you do it create and then sandbox URL sandbox URL and let's go ahead and add the the title of the fragment to be just fragment and files can be result state data files there we go so now let's go ahead and try and do this again so use a simple prompt again build a blue landing page so basically something simple and then wait for this to finish and after it finishes you should now see another step happening here which is to save the result in Prisma it should create a assistant message and it should also create a fragment with the sandbox URL and all the files that it created there we go so we have the save result step and now if I go back here there we go you can see I have a new message here at the top the content includes the task summary created a fully responsive production quality blue themed landing page in app page tsx the layout includes a navbar hero section favorites pricing contact form and footer uh and we don't really have access to the sandbox URL here that's because what we have to do if we want to see that is go inside of the message router and we have to add include fragment true and after you do that you will see the entire fragment content so you will see the entire source code actually and you will see the sandbox URL so if you try adding that here we now have the blue landing page and that is basically what we now have to do so uh let's remove the fragment for now we can easily add it later because I'm not sure if we need it and it's taking up a lot of space uh perfect so this is what I actually wanted to do for this chapter i wanted us to add the messages router and I think that we can do one more thing while we are here and that is the following we can go inside of ingest here instead of functions and let's just change this right let's stop calling it hello world let's go ahead and call this uh code agent the ID will be code agent and let's also change the event to be code agent run like this and now just make sure that you go back inside of your modules messages server procedures here and when you invoke it make sure to change this like that or any other place where you do this make sure to change it for me it's only one place code agent run uh okay and now we have to also go inside of app API ingest route and we have to replace this with code agent there we go go ahead and refresh uh if it's still stuck you can always shut this down and I would recommend shutting both of them down and let's go ahead and refresh again build a green landing page message created and I recommend waiting it out just to confirm it works since we just changed this to be a code agent function there we go seems to work quite well and I think that is it for this chapter oh this one's nice uh we've basically created the message model the fragment model which basically puts it puts us in a position where we can start creating proper UI around this because uh by having the fragment and by having the message we can create the file explorer we can create the I frame where we render the URL and we can create the message containers on this side and while we are here it is important to do uh one more thing go inside of your functions.TTS in the ingest here and after you do uh the result from the network run define an is error constant and it will be an error if we don't have result data summary result data.state state my apologies state data summary or if object do keys result state data files or an alternative empty array.length is equal to zero so if any of those two are missing it means something went wrong so inside of here when we save the result what we're going to do is we're going to check if is error we're going to return content whoops my apologies we're going to uh return await Prisma message create data content something went wrong please try again like this let's give it a role of assistant and let's give it a type of error like this there we go so we do an early return if we detect it is an error so we don't create the fragment if we don't have the information to create it and the one thing I completely forgot about is the types here so right now files is a type of any summary is a type of any right and while this seems to not create any problems for us I want to show you that there is a way so that you can properly type your entire network state because I think that is important and it will make your project more maintainable so let's go ahead above the uh code agent here and let's create an interface agent state and let's go ahead and do the following let's make a summary a string and let's create files which can be mapped as a record string string but I don't like this simply because there is a way to make it uh closer to what we expect and it's basically opening an object and then defining path as the key and simply the content as a string i think this more closely resembles what we expect rather than record string string now that we have the agent state uh we just have to find all the places to use it so starting with uh oh yes I really don't like this we should not name our function and our agent the same so how about we rename one of them let's call this uh code agent function like this and then go back inside of your uh source app API inest route code agent function code agent function like this way safer like that okay now let's go ahead and use the agent state instead of the code agent here we can open uh pointy brackets and pass it inside so that's step one then the next place we can use it is in the tool create or update files so In here we have step and network and you can see that files here are undefined even though we added it to the agent state that's because what we have to do here is we have to define this step as a type of tool from inest agent kit so just make sure that you import the type tool from inest agent kit i think you can specify type like this let's go back here so it's going to be a type of tool dot options and pass in agent state inside and then when you hover over files you will see that it has the correct state so that's the second place and the third place is in the network here so open this up agent state like this and then data dos summary is a type of string now and you will see that you now have autocomplete and if you type something else you should get an error now right so when you clearly define your state it is much stricter and you will not be making any mistakes now uh perfect so I think that this is it for this chapter then uh and let me just check uh how does this look like summary so this looks like it doesn't need anything because life cycle seems to infer properly from create agent agent state here right so if I change this I'm getting an error perfect great so I think that this could be it for this chapter so I'm going to stop here let me just fix this fix this description coding agent like this and of course yeah if you want to you can change the name of this i told you you can always go inside of your let me find the folder sandbox templates toml file and you can change the name here and then simply run inside of this folder E2B template build great so now that we have this let's go ahead and open a pull request if you want to you can also you know try another one just to confirm it works because we changed again the name of our function but at this point I think you know how to fix it but let's just try build a yellow landing page just for sanity check so I don't end the chapter and things are broken and seems to work just fine let's go ahead and see the yellow landing page perfect so let's go ahead and open a pull request so this chapter is 08 messages uh we just created the message schema fragment schema we're saving the user prompt and we are saving the user response perfect so I'm going to go ahead and I'm going to create a new branch 08 messages i'm going to stage all of my changes i'm going to add a commit message and I'm going to commit and publish the branch if you want to there is a free Code Rabbit extension which can help you review all of your files here now let's go ahead and go inside of our GitHub and let's go ahead and open a pull request and let's review with the summary and the diagram here and here we have a summary so let's quickly go over it so we end this chapter we introduced a new messages system allowing users to create and view messages with associated metadata and fragments messages now display additional details including message type and role and we did some refactors such as we streamlined the backend procedures and routing for the message management and we removed the legacy user and post data structures perfect so in here we have the diagram but nothing much has been changed from last time except this time we have additional step before we invoke the code agent run which is that we save the user message in the database and we have one more step in the background job where we save the uh message to the database to the Prisma here great and in here we have uh some comments but all of these things will be changed the on error will be added here later this will basically not be in this component at all so that's the only reason why I keep you know not fixing this comments uh not because they're wrong they're completely right but it's not the component they are going to be in anyway this is just for demonstration right we are now going to start and build the proper UI in here uh I'm pretty sure this is not needed simply because uh inest events have their own try catch methods so let's go ahead now uh and go through the rest of these so in here it recommends pagionation that's something we can look into later but yes it's very easy to add pagionation with Prisma as you can see they have take they have skip and that's pretty much all you need here uh in here it recommends limiting the length of the message and that is definitely a good thing yeah we don't want any user to be able to spam our app with a huge number of tokens so we will have to limit this to some reasonable number this is a very good suggestion here let's go ahead and merge our pull request as always I'm not going to delete my branch instead what I'm going to do is now I'm going to go back to my main branch here and I'm going to click on synchronize changes and once that is finished I can go inside of my source graph and confirm messages are the last merged chapter amazing amazing job and see you in the next chapter in this chapter we're going to add the projects entity to our application so this chapter will be quite similar to the previous one where we introduced the message model so in this chapter we're going to add the project schema we're going to add message relations to that project and then we're going to create a new project on user prompt and the last thing we have to do is preserve project ID in background jobs so we know where to store that AI result basically each message needs to belong to a project so we can keep track of all of our uh AI generations so let's go ahead and start by adding a new Prisma schema as always confirm you are on your main branch and if you haven't synchronize your changes you should have 08 messages as your last merge so I'm going to go inside of Prisma i have some migrations here because we added them last time and now let's go above the message here and actually let's go above message type and above message ro and let's add a model project the ID will be the same as the message so you can add it here the name will be a string and then we're just going to have created at and updated at so we can add this and then down here add messages which will be a type of message like this and now we have to create an equal relation in the message model so let's go inside of the message model here and let's go ahead and add project ID to be a type of string and below that project to be a type of project give it a relation decorator with fields project ID references ID and on delete cascade so exactly the same as the message relation in the fragment right we are aiming for project ID field referencing the ID field in the project and if the project gets deleted the message gets deleted as well and then the fragment gets deleted as well perfect so now that we have this we have to push that to our database so I recommend shutting down both of your uh servers here and let's first do npx prisma migrate reset simply so we remove everything from our database because we have invalid data at the moment and once this is deleted let's go ahead and do npx prisma migrate dev and once it connects to the database let's go ahead and call this migration project there we go so I'm going to call this projects like this and that should apply the migration perfect now let's go ahead and start this server and let's start the ingest server here there we go so now what we're going to do is the following we're going to go inside of source inside of modules and let's copy the messages and paste it here and let's rename it to projects let's go inside of server procedures make sure you are inside of projects here we're going to change this from messages router to projects router like this and then we're going to modify uh how this works as well so for the get many change this to be projects and then in here await prisma.pro find many so that's the get many procedure for the project's router for the create here uh the value will also be uh the message right and actually I'm not even yeah so we are going to create a project by entering a prompt right so we are not going to create a new project and then give the project a name instead we're going to have a big landing page like this and we will simply say hey enter something like create a Netflix clone and then we're going to click create and this will create both the message and the project at the same time so in the create we actually only have the value right the prompt so that's going to be this so we're going to do the following const created project await prisma project create and then for the data uh we have to give a project a name so for this we're going to add a generator package to our project so let's go ahead and let's quickly do npm install random words slugs random word slugs you can of course use a billion other uh generators but this is the one I found that looks the most like uh all the other apps I can find so this is the version 0.1.7 in case you're interested and let's go ahead and use it now so let me just add it here generate slug from random words slug and then in here uh in here the name will be generate slug and pass in two words and let's go ahead and open the settings and pass in the format to be ke like this so that will be it for the name and now we have to immediately create the message so we can do that either uh separately like this or we can just pass in the message messages here and then open the create inside and you can just copy this exactly like this and then you can remove this and then we start the ingest here and besides sending the value we will also send the project ID to be created project ID and then in here you will have created project as the return and that's it that is our create method for the project's router so in here it would be a good idea uh to limit the length as our code rabbit suggested previously so let me add maximum here and let's add I don't know 10,000 maybe that could be the good upper limit message is too long this is not actually the message this is prompt right or value since this is called value so yeah it's either going to be required or if it's longer than 10,000 characters we're going to say okay that's too long uh you can of course modify this later to however you like perfect so you can of courseh also play around uh with this right it even has some more options which you can do but I found this to be sufficient and also in our Prisma schema the project name is not unique so it doesn't matter if there are conflicts with this right great so now that we have this we also have to modify our messages procedures here because right now uh they are not exactly working so let's go inside of the create base procedure here and for the value well we can just copy this just so we're on the same page here so either min or max and then let's also add project ID here which will be a type of string with a minimum value of one and a message project ID is required like this and then in here when we create a new message we will also assign project ID to be input project ID so each message will be stored in an individual uh agent in an individual project right and now what we have to do is also modify the ingest send to also accept project ID from input project ID like this there we go and now what we have to do is we have to modify our ingest functions to accept the project ID so let's go all the way down here to when we actually save the result and you can see we have an error here that's because this message is missing the project ID so project ID will be input my apologies it is event let me just find it uh how do I do this just a second event data value so this will be event data project ID like this and do the same thing here so basically you have to make sure that anytime a message is created you add project ID so you can highlight this part and use command shift F to search it through your entire project and basically every place that you find this it should include project ID so just be extra careful in the functions of the ingest here so you don't forget to uh so you don't accidentally misspell this right because there are no strict typings here we can improve this later on but for now just make sure you didn't misspell project ID when you extract it from event data perfect and now let's also do inest dot send simply so we see that we are sending project ID in all places that we need great so in here we are extracting it from the created project but in here it is from input project ID perfect so now what we have to do is we have to go inside of source app folder page.tsx and we have to modify this so this will no longer be creating messages and we no longer have to query messages we only did that before because we were interested in seeing them so we can remove this and instead we can do create project and this will be TRPC uh projects which doesn't exist the reason it doesn't exist is because we forgot to add it so inside of TRPC folder routers app add projects projects router and you can import it from modules projects server procedures basically this thing we just created and now that we have that we have a proper working projects create we can remove uh on success and instead we can add on error here and you can do toast error error dot message like that and now that we have the create project let's go ahead uh and let's do create project is pending and create project domutate and this will be submit like this and let's go ahead and just modify this slightly by adding height screen with screen flex item center and justify center and inside of here let's do this let's give this a class name maximum width 7 XL MX auto flex item center let's do flex call and gap Y for an items and justify center and now when I refresh this there we go it looks like a centered little prompt we can maybe expand this let's see maximum width okay uh screen let's just keep it at 7 XL like this and when you write test now and click submit uh it should say well nothing nothing for the success message but now what should happen is the following it should create well I have no idea what it's going to create now because I just typed test so let's actually see okay so the it returns the error something went wrong please try again right even though it generated something in the sandbox I have no idea what that is i think not a single file was modified yet so it's just an empty Nex.js page but if you look at your Prisma Studio now and if you actually start it so let's do npx Prisma Studio you should now have a project and inside of that project you should have There we go i have a name uninterested plastic so a new project was generated and I have two messages inside the first is the message from the user who asked test and then a response from the assistant which is a type of error because something went wrong because this is clearly not something the AI can generate right so let's try build a landing page and let's click submit and what should happen now in the Prisma Studio here uh this one is that we should have a new project now modern London with one message as you can see let's just refresh there we go so build a landing page by user we are running this and now we should have a successful example and all the messages for this project will be stored in that project so you can see how our submit data was a project ID and the value build a landing page so there we go now when I refresh this again I should get another message from the assistant with the task summary and this message also has a proper fragment and inside of here we should be able to see let's open in new tab this fragment and in here I have the sandbox URL and I should now see the landing page there we go perfect so now that we have this uh let's go ahead and just do one more thing so we can start building the UI for these messages so let's go inside of source app folder let's create a new folder called projects and in here open project ID so this is basically a dynamic URL part uh it's important how you write this so curly brackets uh square brackets are extremely important and then how you type inside is exactly how you're going to extract this value so be mindful of casing right now add page.tsx here and export uh do a page export like this and a div like this and this will be project ID and then to extract the project ID you simply create an interface props with params which are a type of promise and inside project ID which is a type of string and then in here you can extract the props you can extract the params and since this is a server component you can make this an asynchronous component and extract the project ID from await params and then you can set the project ID to be project ID as simple as this so how do I know that it is project ID how do I know it's not project ID 1 2 3 because of how we named the folder so if you name this with a lowercase letter I then you need to change this to lowerase letter I so be mindful of how you name this dynamic folder and once you've done that go back to your page here and go ahead and add router from use router from next navigation like this and then add the on success here which I'm going to transform into an arrow function simply because I prefer them no other reason we only need the data here and let's do router.push forward slash projects and then data id so how come that we have the data ID available for us because in the create procedure we return the created project so this new project that was just created we have its ID right here so now if I do build a blue landing page and click submit right here there we go i'm redirected to project ID and that new project and now in here I will load only the messages for that project so in the next chapter we will go inside of our modules messages procedures and we will modify the get many to accept a specific project ID and then query by project ID instead of loading all of them but that is for the next chapter amazing amazing job so you just added project schema uh in our uh entire application we will have one more model in the database but this is pretty much it amazing so we added the project schema message relations new project on user prompt and we preserve the project ID in background jobs now let's go ahead and commit this so I'm going to open a new branch 09 projects i'm going to stage all of my changes 09 projects and I'm going to click commit and let's go ahead and publish the branch and then let's go ahead and open a pull request just like that and let's see the summary of this chapter and here we have the code rabbit summary we introduced support for projects allowing users to create and view projects each with an associated initial message we also added a dedicated project page displaying the project ID for now this will later be the actual interface where you will chat with an AI and see the preview of your work and in here we have a couple of uh recommended changes so in here it recommends throwing an error in the background job if it cannot find the project ID and this is definitely the a good idea but I would rather we don't even invoke a background job if we don't have a project ID because where do we even save this message then right so we have to think of a different way to improve this but a good suggestion nevertheless and another suggestion regarding the migration since this is just you know development migration I really don't uh care about this one since it's not really dangerous for our use case so I'm going to merge this pull request and that marks the end of this chapter as always make sure you go back to your main branch and make sure you click on synchronize changes so you pull that new merge and once that is done you can go inside of your source control button here go inside of graph and you should see that we just merged projects amazing see you in the next chapter in this chapter we're going to develop the messages UI this will include creating the project view the messages container message card and the message form components and for the API changes we're going to have to slightly modify the get many procedures of our messages so before we do that let's go ahead and ensure that we are on the main branch and you can click synchronize changes just to make sure everything is up to date and in your source control your last merge should be 09 projects so I'm going to go ahead and go inside of source inside of modules messages procedures and in the get menu let's add the ability to add a project ID so I'm just going to copy the input from the below create procedure and I'm going to add it here and I'm going to delete the value because it's not required here only project ID is required and once we have the project ID we can extend this to add a where and let's go ahead and add project ID to be input project ID now let's go ahead and actually dstructure the input from here so we can use it properly just like this perfect so now we can load messages for an individual project let's go ahead and let's do that so now I'm going to go inside of source app projects project ID page.tsx and since this is a server component what we are going to do is we're going to leverage prefetching so I'm going to go ahead and do const query client and I will do await get query client from the RPC server and this is not a promise so we don't need a weight here you can usually see that if you type an await on something that does not need a weight you will see little three dots here which will tell you that it has no effect on this but you can also see that when hovering on something you will see that there is no promise wrapping this for example when I hover over params you can see that there's a promise of wrapping this so a weight makes sense right in here nothing would happen if I used await but we don't have to use await and let's now add a void TRPC which you can import from the TRPC server same same as get query client and let's go ahead and actually do void query client prefetch query tRPC dot messages get many query options and pass in the project ID which we structure from right here perfect so now what I want to do is I also want to add inside of my modules projects server procedures I want to add a get one like this and I want to add an input here and I want to call this ID ZR with a minimum value of one and a message ID is required so should you call this ID or should you call this uh project ID well since this is regarding fetching a single project in my opinion it is kind of redundant to call the property project ID here uh and let me just see what I did incorrectly here so this is not how you open this you should add Z.Object and then wrap this in parenthesis like this this is the input and then in here you can go ahead and import uh extract this input and you would find existing project here to be await prisma project find unique like this and you would just do where ID is equal to input ID and then go ahead and return the existing project and you can add if there is no existing project throw new TRPC error which you can import from TRPC server and the cool thing about this is that you have strictly typed codes so in this case this would be not found and then we can specify our message which can be project not found great so now we have a procedure to fetch an individual project by its unique ID so we can leverage the find unique which uses the index ID now let's go back inside of the page here and let's also prefetch for that so TRPC projects get one and instead of ID uh instead of project ID we are using the ID field because just think of it when we are fetching messages it makes sense that the prop is project ID because it's referring to an entirely new entity but when we are fetching projects we already know that ID is referring to the project ID that's why in my case it makes no sense to call this project ID we already know it's a project at least that's kind of my idea of naming a convention here in here basically we are doing this just in case you were confused but yeah you can do a shorthand operator if the key and the value are named the same so now we are prefetching these two which means that we can now create our project view component so I'm going to do that by going inside of modules projects and I will create a new folder called UI and inside of here I will create views and then inside of here I will create project- view.tsx and I will mark this as use client and I will export const project view and in here I will create an interface props project ID and I will call this a string in here you could also technically use ID since we know what it's referring to but I originally built the project using this so I just don't want to alter the source code and now in here we are going to rely on getting the data from use suspense query and from using const tpc usepc like this trpc dot projects and here I have it get one query options and pass in the ID to be project ID and let's go ahead and remap this to project then let's copy this and let's change this to messages get many and this will use the project id key and we are going to remap this to messages and now in here we can return a div project JSON stringify project and then below JSON stringify messages null too just like that just make sure you've marked this as use client And now inside of the page here what you can do is you can change this to be hydration boundary which you can import from tanstack react query you can pass the state here to be dehydrate again from tanstack react query and simply pass in the query client then inside of here render the project view component and pass in the project ID to be project ID just like that and there actually is another reason why I don't want to use ID here simply because ID is reserved for u HTML elements right you often see things like form ID and then something so because of that I want to explicitly use project ID here and let's go ahead and wrap this inside of suspense which you can import from React and let's give it a fall back of loading like this there we go perfect so now if you have your app running and if you go to localhost 3000 and if you create a new project here build a yellow landing page and click submit the project ID was just loading for a second and as you can see the first thing we have is for me it's freezing tent that's the random name that we generated and then immediately below that I mean after that we can see an array of messages the first one is build a yellow landing page by the user and in a couple of seconds we will get another message which will basically be the response and here we have it the task summary it created a landing page blah blah blah perfect so this works just fine and it leverages pre-fetching in the server components just be careful that your query options are exactly the same in the prefetch as they are in the use suspense query so they need to be identical so make sure you didn't accidentally mess them up now I'm going to add some resizable panels inside of this project view you already have this installed when we added all Shatsen components so you can import all of these from components UI resizable so you can control-click to confirm that you have it it is inside of source components UI resizable and now let's go ahead and actually build uh our resizable panels so I'm going to give this div here a class name of height screen i'm then going to add a resizable not handle panel group and I'm going to wrap these two elements inside i will give this a direction of horizontal and I will then add a resizable panel and let's go ahead and wrap the project in one resizable panel and then another one for the messages like this let's go ahead and give this one a default let's actually collapse this default size will be 35 minimum size will be 20 and let's give it a class name of flex flex column and the minimum height of zero and now let's go ahead uh and let's do the following in between these two resizable panels add a resizable handle and add width handle like this and for this resizable panel give it a default size of 65 and a minimum size of 50 like this so now you should have this type of resizable panel and you can already see how this is going to look in here we're going to have our messages and in here we will have the project preview right now it is the opposite but you know it's I just wanted to use it as an example so that's how we're going to do that and by default you can see it has what I think is a kind of fair ratio this size for messages this side for the preview you can of course change the default size to whatever you like uh but you know just make uh the the the total number of these two panels needs to add up to 100 so you know just make sure you are using the proper calculations great so now that we have this let's go ahead and let's develop this side of the resizable panel so I'm just going to change this to be to-do preview and this here will be our messages container so right now we have an error because messages container does not exist yet so now let's go ahead and do the following i'm going to still stay inside of projects inside of UI and I will create components now you're probably wondering why am I creating a message container messages container.tsx inside of the projects module when I clearly have the messages module right here well it's not the name that decides where you put something in module-based architecture it is its purpose and this specific messages container purpose will only be used inside of the project ID page right so this project's project ID page is obviously the project module so just because we are rendering a component called messages here messages container doesn't mean that it belongs in the message uh module right but something that's re reusable like the message API that belongs in the message uh module but messages container is just a container to render messages in the project so that's why this is the place I'm putting it in the name doesn't matter I can call this project message container maybe that would be uh a bit more visually attractive but just to explain why I'm putting that here now let's go ahead and let's build the messages container so we are actually going to do the following messages container and then I'm going to copy a couple of things specifically this because this is where I will load the messages if you can it will it will always be better to load the messages to use it to use use suspense query in a deeper component because the deeper component you use it in uh the the faster the page will load and I'm going to show you why in a second so let's call this use TRPC from TRPC client like this and in here we need an interface which I can just copy from the project view here and let's go ahead and destructure the props and get the project ID like this and now we have the messages here so let's just return a div with JSON.stringify messages there we go and now we can import the messages container here from components messages container and we can remove the suspense query for messages like this and pass in the project ID here to be project ID and now what's important is that you wrap this inside of suspense as well and give this a fallback of loading messages like this so now the cool thing that's happening I don't know if you will now see this and yes uh yeah so let me try and demonstrate yeah it's kind of hard uh to do right now perhaps because I don't need this what if I comment this out yes you can see that when you comment this out in the project view the page loads much quicker that is because if we are using a use suspense query inside of the project view then it means that this suspense will fire and that blocks the entire page you can see that while that big loading is active let me just write loading project so while this loading project text is visible the entire page is blocked but if you move the suspense in an deeper cont uh component like the message container like we just did with loading the messages here and wrap that inside of suspense so let me now simulate by commenting this out you can see that we are not blocking the entire view only the messages view so that's why I told you that it will be faster it's not really faster it is just visually faster so we are going to do the same thing for loading the project so yes for now we can actually remove this because we will not be loading the project uh inside of the project view let me just move the suspense right here perfect so now let's go inside of the message container and let's develop it i'm going to start by giving the most outer div a class name of flex flex column flex one and a minimum height of zero i'm then going to add another div with a class name flex one minimum height of zero and overflow y auto and then inside of here another div with a class name padding top padding top two and padding right of one and then finally inside of here I will go over my messages i will get the individual message here and I will render a new component so in here we're going to render message card component and you can remove the JSON stringify here now let's give this a key of message do ID let's give it content of message.content roll of message roll fragment of message fragment and now we have a problem fragment is not loaded here so let's go ahead and fix that by going inside of messages get many procedure it's inside of uh modules messages server procedures and simply do what we did in the previous chapter add include make sure you're doing this instead of get many add include fragment true like this and now let's go back inside of the messages container here and as you can see now we no longer have that problem right so now message fragment exists let's add created at here to be message.created at just is active fragment for now to be hardcoded to false on fragment click will be an empty arrow function and the type will be message.ype now let's go ahead inside of the components and create the message card again we are doing this inside of the projects module because even though these components are called message they relate more to the product to the project entity than they do to the message entity and inside of the message card component we are now uh going to do this the uh the following first let's create the props content which is a string roll which is a type of message roll you can import from at generated Prisma so this is the generated folder of Prisma which you can find in your source folder and you can see that you don't really touch this folder right you don't modify this folder because it is automatically generated every time you do npx prisma generate or npx prisma migrate dev which in background runs npx prisma generate right you can always do npx prisma generate yourself this will simply update the entire prisma right so in case yours didn't exist now it will exist so message ro was directly generated from our schema message role so if yours is called something else you're going to have to import something else same thing for fragment from message here and same thing for message type so basically content ro fragment which can be null created at is active fragment which is a boolean on fragment click which accepts the fragment as the value and type which is a message type now let's go ahead and let's export the message card here and let's assign all of those props from above and let's dstructure them all here perfect now inside of this let's go ahead and do the following if roll is equal to assistant we're going to return a paragraph assistant otherwise we are going to return a paragraph user and let me just fix my uh typo here so we have this uh I don't think I need this there we go like this and it's okay that all of these things are unused now let's go back to the messages container and import message card from dot / message card let me just separate my imports here no need for use client in this component simply because the uh project view where it's rendered is already use client so its children will be as well and as you can see I have two messages the first one is from the assistant and the other one is from the user and I think that in this case we would actually need the opposite to happen so let's go inside of the messages container go inside of messages get many and change the order by to be ascending so the first one should be from the user and the second one should be from the assistant all right now let's go inside of the message card and let's actually develop this so let's do the user one first because I believe it is a little bit easier so we're going to do user message here and it will have one prop which is content so let's pass in content here and we're going to develop this uh just above this con user message and let's create an interface uses me user message props like this and then just extract the props here it's just content and in here return a div with a class name flex justify and padding bottom of four PR of 2 PL of 10 and in here add a card from components UI card you already have this as well it comes with chat UI you can find it in source components UI card now inside of the card render the content and give the card a class name of rounded large background muted padding three shadow none border none maximum width of 80% and break words like this so the user message will be rendered every time the user sends a message and we should be able to see that now build a yellow landing page that was my first message and you can see how my message is moved into this corner we are now going to render the assistant output so in order to do that we will render the assistant message like this assistant message and the assistant will have uh some different props so we're going to pass the content to be content fragment to be fragment it will have created at it will have is active fragment and it will have on fragment click and it will have a type basically all the other props are related to the assistant message so now let's go uh below the user message let's create an interface assistant message and in here we can just add all of those props content fragment which can be a type of fragment or null created at which is date is active fragment which is boolean on fragment click and type i'm not sure but maybe these are identical to message card props uh it doesn't have roll so yeah one less prop i'm not sure if this is the best way to do this but you know I think it's fine now let's go ahead and actually do const assistant message like this let's destructure assistant message props oops yeah I should call this props yes like this and then inside let's just add all of those things content fragment created at is active on fragment click enter and type and inside of here we are going to do the following let's add a div with a dynamic class name which means open curly brackets and import CN from lib utils if you don't remember this but we got this when we installed shot cnui and I told you we are going to use this when we need some dynamic classes and this is the first time we need that so the way you use this library is very simple you open it up as a function it can accept an infinite number of parameters so the first parameter the second parameter the third infinite number what I like to do is I like to reserve the first one for my static class names so flex flex column group ex 2 and padding bottom of four and then in the second argument I like to do dynamic ones if type is equal to error I'm going to render it differently i'm going to render text red 700 and on dark mode text red 500 like this and then inside of here I'm going to add a div with a class name of flex item center gap 2 pl 2 and margin bottom of two now I'm going to add to-do add logo because we don't have it yet and I'm going to add an image component here uh actually we can do that only when we have the logo so let's add a span for now and our app name in my case this will be vibe text small and font medium like this then copy this span and in here you're going to need to install npm install date fns this will be used to parse dates and let me show you my package json date fns 4.1.0 zero and I'm going to import something from date FNS so import format from date FNS like this and inside of here I'm going to format created at like this and I will format in this format like this and then I'm going to slightly modify this to be text extra small and text muted foreground and then then I'm going to give it an opacity of zero and I'm going to give it transition opacity and since I have given this outer parent div a group class name I can leverage that by doing the following i can do group colon my apologies group dash hover so when the group is hovered change the opacity to 100 like this and that's how I'm going to make this appear when we hover on the parent element perfect and then outside of this div let's go ahead and let's actually render the content so div class name pl 8.5 flex plex column and gap y of four and inside of here a span with content inside and let's go ahead and make sure we are using the assistant message we are perfect and there we go you can see build a yellow landing page and then vibe answers at this time which only appears when I hover with a task summary like this perfect so now let's go ahead and continue uh developing this uh and let me just see so in here we have flex item center gap 2 PL2 margin bottom of two okay i think I think this is okay i am just this this spacing seems a little bit odd i'm not sure this is how it's supposed to be but yeah go ahead and try and collapse your page a bit it should work fine it should normally break words it shouldn't add any scroll bars except the the the one from up down right that one should appear but no one on the x-axis should not happen uh great so now let's go ahead and let's obtain our app logo so head to the assets page you can see the link on the screen or you can use the link in the description and in here you can find logo.svg i found this logo from logo Ipsum so these are amazing placeholder logos you can use for your projects uh and I use them in pretty much every project they are amazing so I slightly modify them to match the color scheme of the project you can download them or you can copy the SVG since the code is in SVG and you can then go inside of your project and what I like to do is go inside of public create a new logo svg here and then I click this open file using VS Code standard text binary and I paste it inside and save it and that creates the logo or you can just download it as a file normally without all that trouble so now let's go ahead and let's add our logo to our message card specifically in the assistant message I added a to-do here now let's add an image here from next image so make sure you have added this import here and then we're going to add the following source will be forward/lo.svg alt will be vibe width will be 18 height will be 18 and class name will be shrink zero and let's go ahead and try again and there we go so now this space makes more sense because the logo perfectly pushes the text to be aligned with the content right here amazing and don't worry about this task summary tag we will get rid of that later uh using something else but this is basically how our chat will look like and if you're wondering the colors don't look exactly as your demo don't worry we're going to change the entire theme of the project later but this is what I wanted to achieve so now what I want to do is I also want to add a little uh message on the bottom here i mean a little form on the bottom uh but just before I do that I also want to create a fragment component so after we render the span content let's check if we have the fragment and if type is equal to result only then are we going to render the fragment card the fragment card will accept three props the fragment itself is active fragment and on fragment click and we can create the fragment just above here so first the props fragment card props fragment is active fragment and on fragment click and then the fragment card component so let's just use the props and extract them here and then inside of here we're going to return a button but a normal HTML button like this we're going to give it a dynamic class name using the CN library in the first argument I will add flex items start text start gap two border rounded large background muted width fit padding three hover bg secondary and transition colors and then I'm going to check if is active fragment And I will do the following background primary text primary foreground border primary and hover bg primary like this and on click here I will call on fragment click and pass the fragment as the prop inside of the button itself I will add code to icon so from lucid react let me just fix this uh invalid fragment end here i don't need this there we go the code to icon will have a class name of size four and margin top of.5 i will then open a div with a class name flex flex column and flex one and inside of here I will have a span which will render the fragment title and the class name text small font medium and line clamp one below this another span with a class name of text small and the text preview i think we should already start to see this because this message from the AI assistant has the fragment and it is not an error so we can see it right here make sure that you are doing this on a successful response so you have the fragment generated in your database if you are unsure if you still can't see it npx Prisma studio to show you what I'm talking about so your message whatever one you're doing should have a fragment you can see how some of my messages don't have fragments because they are by user or they are errors but the ones that are successful have a fragment right so that's what you need to do you basically need to create uh a background job with a successful generation something that has a fragment so now after the preview here outside of this div I'm going to add another div with a chevron write icon from lucid react with a class name of size 4 so the same import place as code to icon and let's go ahead and give this a class name flex items center justify center and margin top of 0.5 and I think that marks the end of the message card component i think we have everything we need now the only thing I don't like is that this doesn't have the pointer cursor it doesn't look clickable but you don't have to fix that by adding the pointer to uh this because this is already a button so what we're going to do is we are going to change the global CSS so that it shows the pointer when this is hovered like this i mean not this one but you you get the idea right perfect so now what we can do is we can create the form here at the bottom and that will uh complete the message container so let's go ahead and go inside of the components and let's create the message dash form.tsx so this will be rendered at the bottom of the message container let's go ahead and just copy the props from the previous components and let's export message form inside of here go ahead and assign the props and destructure the project ID and return a div message form and now let's go inside of the messages container and now we have to render this so I'm going to render it uh after the last div here i'm going to open a new one with a class name relative padding 3 pt1 and then I'm going to add message form and I'm going to pass in the project ID project ID like this so make sure you have added this import and now at the bottom you will see message form in order to complete the message form component we're going to have to install a new package react text area autosize so go ahead and install this and I'm going to show you the version so package JSON 8.5.9 that is my version and now let's go inside of the message form and we're going to need a couple of things from React hook form so use form and then we're going to need Zod resolver from hook form resolvers zod and if you're worried where do these packages come from we already have them cook form and form react cook form so all of this already exist and they came with chatnui when we added all components and the new one is this one text area auto size from react text area auto size and besides this let's just see uh what else do we need let's also add use state from react like this let's also add zod and let's add post from sonner and let's also add some icons so that's going to be arrow up icon and loader two icon from lucid react and from tanstack query we need use mutation use query and use query client from tanstack react query then let's add cn from lib utils use trpc from at tpc client the button component and form and form field from components UI form this is another shhatsenui component and when you installed that which you did using the d-all command you also got use form and you got the zod resolver and also zod and that is it for now so now let's define form schema here to be z.object and what you should actually do is you should visit one of your procedures in messages specifically find the create procedure and you should copy the value from here so you have the limit right so like this now how you're going to call this value string um I really don't know so you can do value you can do content whatever you want and let's go ahead and do the following now that we have this form schema con form use form pass in Z.infer infer type of form schema like this and add resolver here to be zod resolver and pass in the form schema object and the default values will set the value to be an empty string by default great now that we have the form let's build the UI so the outer div will be the form element from here from components UI form and we have to pass the entire object that we created here using use form and then inside we need a native HTML form element like this and in here we need the following we need onsubmit to be form handle submit and then we have to create a custom submit form so const onsubmit here we'll accept the values which are basically this so you can copy this from above and for now just console log the values the reason we are doing this infer is because when you hover over you can see that it is exactly what you define here so now use that onsubmit and pass it here so now this onsubmit will only trigger this which will actually initialize the network call when the validation passes so that's why we are wrapping it inside of here perfect and now let's go ahead and do a class name here cn relative border padding four padding top one rounded extra large background sidebar dark bg sidebar and transition all like this and then if is focused which doesn't exist yet we were going to do shadow extra small and for show usage we are going to do a rounded top none so now let's go ahead and just quickly uh fix these things so for is focused it is an easy fix all we are going to do is add a new use state here with is focused and set is focused with the default value of false from use state react and for the show usage I'm going to manually set it to false for now so now you should have no errors here and periodically you can check on this just to see how it looks great now that we have this let's go ahead and add the form field component which is a self-closing tag just make sure you have imported it give this a control of form give it a name of content and give it a render of field like this and inside use the text area auto size self-closing component in here you can immediately spread everything you have from the field above and then go ahead and give it the following and give it an onfocus and on blur to modify the set is focused state like this and the name should be value my apologies so already when you hover over this I'm not sure if you can notice but that's there's an ever so slight shadow change to the entire object now we have to fix this so it doesn't look so weird so let's go ahead and give this a minimum rows of two and a maximum rows of eight and then a class name adding top four bore resize none border none width full outline none background transparent and a placeholder of what would you like to build and then let's go ahead and do on key down get the event and check if event key is equal to enter and open parenthesis we are also holding control key or meta key so this will basically be control enter we prevent the default and we do form handle submit onsubmit oops onsubmit and pass the event as well so the onsubmit is this just like that so now uh outside of this which is form field I believe yes outside of form field but still inside of the form let's go ahead and do the following let's add a div with a class name flex gap x2 items end justify between padding top of two then another div with a class name text 10 pixels text muted foreground and font mono and just write test here simply so you see where that is so it's right here at the bottom so this will now be the following it will be a uh keyboard sign i think this is for keyboard the the short name for keyboard uh render a span inside and render the following sign like this and then enter and that will turn uh like this the command sign and enter now let's style it the class name will be ML auto pointer events none inline flex height five select none items center gap one rounded just rounded border background color muted px 1.5 font mono text 10 pixels font medium and text muted foreground ground and then let's go ahead outside of the KBD and let's do NBSP to submit so basically command enter to submit we are telling the user how to submit and now outside of this div add a button element and this button element will do the following it will render arrow up icon which we already have imported from Lucid React there we go and now we're going to style it give it a class name of CN size 8 and rounded full like this there we go this is how it's going to look like and now we need to add some dynamic things here so let's start by adding our create message mutation so we need to add PRPC here use PRPC and then we need to add create message from use mutation ERPC messages create mutation options like this and then you can extract the following you can then extract const is pending to be create message is pending const is disabled to be is pending or if not form form state is valid so if form state is not valid like this and let me actually move these two to the bottom here simply so I have all of these things in one place and now that we have the create message mutation let's go inside of the onsubmit and let's make it an asynchronous method and let's do await create message dot mutate async and pass in the value to be data actually this is values so values do value and the project ID like that perfect and now let's use the is pending and let's use uh the is is disabled so first things first to the text area auto size disabled if is pending like that and then let's go ahead down to this button and the button will be a little bit different so this one will be disabled if is disabled so be careful for the text area auto size we only disabled if it's pending so only if the network request is pending but disabled will be for this so you can do is button disabled just to don't so you don't make a mistake there we go uh and let's also do if is button disabled background muted foreground and border like this and then inside of here a turnary if is pending in that case we are rendering the loader two icon which we already have imported with a class name of size four and animate spin otherwise we render the arrow up icon like this there we go so now make sure that you you know restart your server here actually I will restart the entire project as well so npm rundev npx inestdev i will refresh this page here and I'm going to add build a blue landing page and I will press command enter and there we go you can see that that has submitted this for a second it was loading we still have to do the cleanup function but if I look in my inest developer server you can see that this is successfully running amazing and if I refresh here I should actually see my new message here build a blue landing page perfect so now let's go ahead and just add some onsuccess things to happen in the mutation options of the create message right so what should happen after we submit so the first thing that should happen is on success here once we get the data of this new message let's go ahead and let's first do form.reset like this so make sure that form is initialized above and then let's do query client which uh I'm not sure do we have it we don't so let's let me just add const query client to be use query client so you have this imported from tanstack react query so in here what you're going to do is queryclient.invalidate invalidate queries and then pass in TRPC messages get many query options project ID data project ID or you can use the project ID from here yeah maybe that's even easier to do and then you can use the shorthand operator that's the first thing we are going to invalidate then the second thing uh we don't have yet so I will add a to-do reinvalidate or invalidate uh usage status we don't have this yet but we will have it later and now add on error here get the error and do toast dot error error dossage and I will add a to-do redirect to pricing page if specific error there we go and the only thing I don't have left here is the use query and I will remove it for now because we don't really have the entity we need to call and I think that for now this is it i think for now this is everything uh we can do here and there we go we have a response now created a fully responsive production quality blue themed landing page perfect so now what I want to do is just to end this chapter one more thing here I don't like how uh the first thing is when I load the page you can see I have to scroll all the way down and the second thing is when I scroll the text visibly clips here you can see how it's cut so let's fix those two things and let's end the chapter both of these things will be in the messages container so make sure that you have some messages and you can zoom in a little so you have the scroll bar like I do the first thing will be a very simple self-closing div just above the place where we render the message form inside of this relative div and give it a class name of absolute minus top minus 6 left 0 right zero height of six background gradient to bottom from transparent to oops to dash background forward slash70 pointer events none what this will do is it will create an ever so slightly white shadow i'm not sure if you can see it but it kind of melts the the overflow so it doesn't look as obvious that the text is clipping here if you want to you can improve this and change this to two background and then you can see you can't you can't see the clipping at all it's like it fades into some kind of fog right so just a slight effect to make this look better so it doesn't clip now let's do the thing that when we load we scroll to the bottom here so in order to do that we first have to add a bottom ref so let's do that here const bottom ref will be use ref from react with a default value of null and the type of HTML div element like this let me just move this to the top like that and then what we are going to do is we are going to change this to be use effect which you can import from react and let's first do the following const last system or let's do last assistant message and do data Find last my apologies messages find last search through the messages and find the message whose role is assistant and that's how we are going to find the last message that the assistant sends so make sure you're using the find last API here and if we are able to find this last assistant message what we are going to do first is we are going to set the fragment uh to that assistant message now we don't have this yet so actually I'm not sure if we can do that so let me just do to-do uh and let's do set active fragment right so we're going to do this uh well maybe in this chapter maybe in the future i I will see but let's add messages for now like this and then let's go ahead and add another use effect and in here we will do messages.length and we're going to check if bottom ref question mark scroll into view like this and let me just check i think um that for now this is okay if I do a refresh here uh looks like it's not working so So it should be scrolling me to the bottom but it is not probably because I never added that so let's go ahead outside of here add a self-closing div and give it a ref of bottom ref so now when you refresh there we go you can see how you scroll down immediately perfect um so now um yes I think I'm going to end the chapter here simply because it's already been an hour so we're going to end here and in the next chapter we're going to wrap this up by adding is active fragment functionality we're going to add some loading states while we wait for the response and we're also going to add the header here so that we can click the back button to go back to the landing page and so we can uh access some settings here and see the project name great so we've already made some great progress here and you can add something uh like this if you want to see the error state and now you can see how the error state looks like when you send it something that it cannot generate it will simply tell you something went wrong and it highlights the red color perfect so I'm very very satisfied with this so we've done this we've done this this this and even more than this now let's go ahead and open a new branch and merge this so 10 messages UI i'm going to open this i'm going to create a new branch 10 messages UI i'm going to stage all of my changes and I will do 10 messages UI and I will commit and I will publish the branch a quick reminder that there is a free code rabbit extension which you can use to improve your code quality and now I'm going to go and open this pull request here and we're going to review the summary of this chapter and everything we did and here we have the code rabbit summary we introduced a chat interface for project pages including a message list message input form and support for assistant and user messages with styled cards added support for displaying message fragments and interactive fragment cards we implemented a horizontally resizable panel layout with a dedicated area for future preview features that is exactly what was the point and goal of this chapter and may I say we did a pretty good job because no comments only some nitpicking comments like we could save some time by doing project ID instead of project ID equals project ID so overall amazing amazing job in here of course we have an in-depth diagram explaining exactly how everything in this page happens including pre-fetching including invalidation including refetching everything amazing amazing job i'm going to merge this poll request once the poll request is merged I'm going to go back inside of my IDE and I will go back to the main branch after that I'm going to synchronize my changes and I will check the source control and the graph so I can see that I successfully merged chapter 10 that marks the end of this chapter I believe amazing amazing job and see you in the next chapter in this chapter we're going to continue the UI development from the last chapter we pretty much completed the messages container at that point but we do have some things missing like the fragment selection and the loading state but after that we're going to focus on the project header component which is the component above the messages container which will tell us which is the currently active project and the buttons to go back so let's go ahead and first handle the leftovers from the previous chapter as always make sure that you're on your main branch and clicked on synchronize changes just to confirm everything is up to date so now what I want to do is I want to go inside of my project view inside of projects UI views project view and in here let's go ahead and let's introduce an active fragment and set active fragment state from use state and by default let's set it to null and the type can be a type of fragment from Prisma or null so just make sure you added this imports here once you've added that let's go ahead and let's modify the messages container component to have a few more procs let's add active fragment to be active fragment and let's add set active fragment to be set active fragment now go inside of the messages container and let's improve these props so I'm going to add the active fragment prop to be fragment or null and make sure to import the fragment and add the set active fragment right here and then you can extract them in the new props here active fragment and set active fragment just like that and then inside of use effect here if we detect the last assistant message call set active fragment and set last system message my apologies last assistant message dot fragment inside but only if we have last assistant message fragment uh well actually since it's going to be null h yeah let's go ahead and we can just do this it's okay and call this there we go so now one of the fragments will always be selected what we have to do now is we have to go to the message card and set the active fragment question mark ID to be identical to message fragment question mark id and set active fragment will um on fragment click will call set active fragment and pass the message fragment inside like this so now inside of your project here when you click on a specific fragment it should be highlighted like this perfect and when you load the page since this is an error right now nothing is highlighted here but if you try this again build a landing page for example i'm going to wait for a second for this to respond and you're going to see that then when you refresh it will automatically select that fragment thanks to this use effect right here which searches for the last message which role is assistant and perhaps we can even improve this by searching for the last assistant message with fragment and then we can do this and message.fragment fragment and just turn this into a boolean and then just do this so you can see that now when I refresh this fragment is automatically selected perfect exactly what we need so now that we have that let's also create a loading state in order to do that let's go outside of the use effect here let's create a constant to find the last message instead of data let's use messages like this and then we are going to find the last user message so if if is last message user so if last message role is user it means that we are the one who sent the message last so that's going to be the system we are going to rely on for now to display loading later we can improve it more so let's do this let's go just above the bottom riff and let's do if last message is user add message loading state like this now let's create message loading tsx here and in here this is what we're going to do so import image from next image and import use state and use effect from react now in here first define shimmer messages function and in here add an array of messages this can be anything you want so I'm going to add thinking loading generating analyzing your request building your website crafting components basically things like that and then what I'm going to do is I'm going to create a state for current message index and set current message index with the initial value of zero and then I'm going to create a use effect here like this and the use effect will do the following it will create an interval set interval and inside of this interval every two seconds I'm going to call set current message index previous + one modulus messages.length like that and inside of here I'm going to add messages.length and in the return method here call clear interval and pass the interval constant like this and then inside of here you are going to return a div and a span and inside render the currently active message like this now give this a span a class name of text base text muted foreground and animate false and give the outer div a class name of flex items center and a gap of two like this and now finally let's export const message loading inside of here we're going to return a div with a class name flex flex column group px of two and padding bottom of four then a div of class name flex items center gap 2 pl2 and margin bottom of two then we're going to render an image component with a source of logo SVG out of our project name width of 18 height of 18 as well and a class name of shrink zero after that a span with the name of our project with a class name text small and font medium outside of this div we're going to open a new one with the class name pl 8.5 flex flex column and get y of four and inside render the shimmer messages component and then inside of the messages container here you can import message loading component like this so now if you try and do build a yellow landing page you will see this thinking loading generating analyzing your request so something for the user to look at while this generates uh and if you really want to immediately see the results of this so right now we have to refresh we have to wait for some kind of refetch what you can actually do inside of your messages container is you can add a refetch interval for example every 5 seconds so now even without you refreshing it's going to refetch the messages every 5 seconds and there we go we get a result so we can add a to-do here temporary live message update like this but just so you can start showing this to people so you don't have to refresh your page every time so yes now if you take a look at your network request every 5 seconds there there will be a network for refreshing the messages but don't worry uh since we are using React query a lot of this will be cached great so now let's go ahead and let's build a component which will be above this and it will be used to display the project name and the ability to go back so I'm going to go back inside of the project view component and just above the suspense for loading messages I am going to add project header component i'm going to pass project ID to be project ID like this and after you've done that let's go inside of components and let's create project- header.tsx like this now inside of here let's go ahead and add the following imports link image used theme from next themes so you already have this inside of your package JSON this will be used to enable dark mode use suspense query from tanstack react query some icons chevron down chevron left edit sun moon icon and then let's add use tpc from tRPC client button from components UI button and all of these imports from the drop-own menu the menu itself content item portal radio group radio item separator sub sub subcontent subt trigger and menu trigger all of those things now let's go ahead and let's create an in interface props here and let's go ahead and define project header right here now when we are inside of here we can add tRPC use TRPC and we can go ahead and fetch our project using use suspense query TRPC projects get one query options ID project ID and now we've done what we did initially right remember we had the project loading here but now we moved it here so it's time to do the following first import the project header from docomponents project header and after that wrap it in its own suspense like this and give it a fallback of loading project like this and now that we have this let's go ahead and add a header tag right here let's give it a class name of padding 2 flex justify between items center and border bottom and let's call it header and let me just refresh here uh and looks like it's not showing now uh it is but it is very small I believe so let's go ahead uh and let me see let's Oh my apologies no it is not visible we are not rendering anything i thought it was just very small but it didn't make sense make sure to return it there we go now we can see header in the text there we go perfect so now let's go ahead and develop this header even further so I'm going to add a drop-own menu here we have all of these components imported now inside of here add a drop-own menu trigger and give it an as child property this will allow it to become the button which is inside and then let's give this button a variant of ghost a size of small a class name of focus visible ring zero hover bg transparent hover opacity 75 transition opacity and pl2 with an exclamation point at the end in Tailwind this means important we are basically overriding some classes in here you're going to render the image with the source of logo SVG out of the project name width of 18 height of 18 then a span element with the project name the project name coming from the query which we just loaded this will have a class name of text small and font medium after that a chevron down icon and there we go this now becomes a drop-down menu it doesn't have the uh proper cursor but don't worry we will fix that later great so now let's go ahead and go outside of the drop-down menu trigger and let's add drop-down menu content and let's give this a side of bottom let's give this an align of start let's get the drop-down menu item here let's give it an as child property let's make sure we close the drop-own menu item component add a link component here give it an href to the root page add the chevron left icon and a span element go to dashboard and there we go now the first item is to go back perfect now we have a way to go to the landing page what I want to do next is I want to create a drop-own menu separator so let's do drop-own menu separator here there we go and below that add a drop-own menu sub and then a drop-own menu subt trigger give this a class name of gap 2 inside of this trigger render a sun moon icon give this a class name of size 4 and text muted foreground and then a span with the text appearance and now you have a submen here and now let's go ahead and go outside of the trigger and add drop-down menu portal inside of the portal add drop-own menu subcontent inside of subcontent add drop-down menu radio group give it a value for now uh of light and on value change of an empty arrow function for now now let's add drop-down menu radio item give this a value of light and render a span light now go ahead and copy this two times the second one will be dark with the text dark the third one will be system with the text system like this and now you will have the option to select different themes in order to enable this we first have to go inside of our layout our main layout in the app folder next to the root page right so this one with the body and everything and then in here add to the HTML tag suppress hydration warning and then inside of body add a theme provider from next themes and encapsulate the toaster and the children so just make sure you have added the import here let me just move this up here oops looks like I did something incorrectly here let me just do it again so I'm going to add theme provider and encapsulate the children now inside of here I'm going to give it an attribute class i'm going to give it a default theme of system and I'm going to give it the enable system option as well as disable transition on change and now let's go inside of project header back and in here I'm going to add const set theme and theme from use theme you have imported this from next themes you can remove the edit icon and now let's go back to our radio here set the value to be theme change this to be uh set theme and I think that is pretty much it if you try clicking on dark mode uh it should use the dark mode try refreshing if it doesn't work there we go perfect we now have dark mode we will of course improve the look of it later but pretty impressive so far great so that marks the end of the project header for now what we're going to do or start doing in the next chapter will be previewing the actual fragments and fix any potential issues that we have this will also include creating the code editor right amazing job so let's go ahead i can see that we have some issue here every time I select this fragment very soon the bottom one starts to select so I'm pretty sure that something inside of my messages container uh oh yes the refetch interval is probably causing this to uh refetch every time so maybe a better option for now would be to not use it so I'm going to comment it out i will add to-do this is causing problems yes it's definitely that refetch interval so now by default no fragment is selected only you can select it it's okay to be like that now uh great in the next chapter we are developing this so let's go ahead and do what we usually do let's mark what we completed and let's open a new branch project header so I'm going to open a new branch here create new branch 11 project header i'm going to stage all of my changes 11 project header i'm going to commit and I'm going to publish this branch then I'm going to go ahead and go in my GitHub and I'm going to open a new pull request so that we can review all the things we did and here we have the summary new features we added a dynamic project header with theme switching and navigation options we also introduced a loading indicator with animated messages during message processing we enabled live updates for messages with automatic refreshing every 5 seconds we improved message interaction by highlighting and managing active message fragments perfect that is exactly what we did in this chapter as always in here we have file by file walkthrough and of course a sequence diagram this time including the periodically refetching messages which we just added amazing and as for the comments we are very good again no comments except some nitpick comments amazing job let's go ahead and let's merge this and after you have merged it go back to your project change to the main branch and make sure to synchronize your changes after you have synchronized your changes as always you can click on the source control graph and confirm that you have just merged chapter 11 and I believe that marks the end of this chapter amazing amazing job and see you in the next one in this chapter we're going to focus on creating the fragment view component and this entire chapter is pretty straightforward we just have to create an ability to view that E2B sandbox URL so let's go ahead and do that as always ensure that you're on your main branch and synchronize changes to make sure everything is up to date the last chapter was chapter 11 so now let's go ahead inside of source and basically just find project view there we go inside of this project view go inside of your second resizable panel and in here render the fragment web component we are only going to render this if we have an active fragment so if you have an active fragment only then render the fragment web and pass in the data to be active fragment as simple as that and you can turn this into a boolean like this perfect now let's go ahead and let's go inside of components fragment web.tsx now in here let's create an interface props with fragment from generated Prisma now let's go ahead and let's add a couple of more things use state from react external link icon and refresh CCW icon and then we're going to use the button component from components UI button now in here let's go ahead and export function fragment web which accepts data and props and in here let's go ahead and start by doing a div with a class name flex flex column full width full height and then inside of here we're going to do an I frame and we're going to add key uh actually we can't do this yet my apologies so for now just do a class name height full width full sandbox allow forms allow scripts and allow same origin and then loading will be lazy and source will be data sandbox URL like this and then let's go ahead and import this from component fragment web and I think that now when you click here you should be seeing a big error saying that sandbox was not found but try creating a new prompt so build a landing page let's go ahead and do that and let's wait for this to generate and once you get a response you can click on the new fragment and in here you are now able to preview inside of the iframe the new landing page which was just created amazing amazing job so you are pretty much halfway there right great so now let's add some features to make this seem like a little browser so inside of this fragment web we're now going to add a couple of things above the iframe add a div and give this div a class name padding two border bottom background color sidebar flex items center and gap x of two so now just above here you have a little bar then in here add a button component and inside a refresh CCW icon give this a size of small a side of bottom oh my apologies no these are completely wrong props uh variant of outline and on click for now just an empty function and now you have a refresh button here perfect so after that go ahead and copy this button and in here you're going to have the following you're going to have a span inside of here like this which will render data sandbox URL it will have a class name of truncate and now let's go ahead and do the following collapse all of these props like so and keep the variant and keep the size so let's just add a class name here to be flex one justify start text start and font normal so now you have a big uh kind of like an address bar right showing the current fragment URL and then let's go ahead and just add disabled prop to be explicitly false and then after this button let's add another one which will have the external link icon and give this one a size of small a disabled if there is no sandbox URL variant of outline and on click will be an arrow function which checks if there is no data sandbox URL return otherwise call window open data sandbox URL blank as the second argument so it opens in a new tab there we go now let's go ahead and go inside of frame and let's add uh I keep doing the key but I keep forgetting to implement the key let's finally do that so go to the top here and add fragment key and set fragment key and call use state like this then let's add copied and set copied use state false let's add on a refresh method set fragment key previous previous + one con handle copy navigator clipboard write text data sandbox URL set copied goes to true and set timeout is fired with set copied set to false with a 2cond timeout out now that we have these two let's go ahead and add on refresh here like so and for this one let's give it an on click to be handle copy and disabled if there is no data sandbox URL or if we just copied something and in here I think it is good enough so now you should have buttons to open this in an external tab like this you should have buttons to copy this so when I paste there we go and you should be able to refresh this but looks like the refresh one uh is not working let me just check yes it's okay if this expires that's completely fine it expires very soon because we don't want to spend our free credits on E2B so I don't think this refresh is working and it's not working because we need to add the fragment E here so now when you hit refresh you can see how it it blinks which basically means it is refreshing perfect so let's try build a calculator app and let's see that and let's see how that displays in something like this and here we have a calculator app pretty pretty cool amazing we can now refresh this and there we go you have a whole new refreshed page uh perfect you can copy this amazing so now what I want to do is I want to develop one simple component called hint and we're going to store that inside of source components hint.tsx so not inside of the UI folder let me just close it here i mean it doesn't matter if you want to you can put it inside of the UI folder and in here we're going to mark this as use client and we're going to import everything tool tip related from components UI tool pip you already have this in it is inside of the UI folder so import all of these things and then create the following interface hint props accepting the children the text and then optional side and align which accepts top right bottom or left and align start center and end and then let's go ahead and export const hint with some predefined props here so basically we have the children the text the side which by default will be top and align which by default will be center and then inside of here what you're going to do is you're going to add the tool tip provider you're going to add the tool tip itself and then you're going to add a tool tip trigger like that as child property and the render children inside and then you're going to add tool tip content you're going to pass in the side prop you're going to pass in the align prop and inside you're going to render a paragraph with a text just like that that is our hint component now let's go back inside of the fragment web and let's wrap it around a couple of items starting with the external link icon so simply wrap your button in your new hint component like this and then you can add a text here and say open in a new tab and a side of bottom and then a line of start just make sure you have imported the hint from components hint and now when you hover it say it tells you what it does right because just by looking at the icons it might not be clear and now let's do that for the rest so find the copy button and wrap it in a hint like this click the copy with a side of bottom so now when you hover over here you can see that you can click to copy and then do the same thing for this one to refresh there we go so now we can refresh as well amazing amazing job in the next chapter what we are going to do is we're going to implement tabs here so we can switch between a code preview and a actual web preview like we are doing now great so let's go ahead and mark this as completed a very simple chapter but a very powerful and very rewarding chapter may I say so let's go ahead and open a pull request so this is chapter 12 i'm going to close everything new branch 12 fragment preview is that the name it is fragment view let's add and stage all of my changes let me just click here there we go stage the changes 12 fragment view let's commit and let's publish the branch and let's go ahead and open a pull request here and let's review what we just did and here we have this summary we introduced a reusable tool tip component for displaying contextual contextual hints we added a web fragment preview component with controls to refresh copy and open the preview in a new tab we enabled a live preview of the project fragments directly within the project view including interactive controls and tool tips perfect as always an an in-depth walkthrough as well as a sequence diagram here and some actionable comments so yes navigator.Clipboard.ext is technically a promise so it can you can do on it and catch on it so it is possible that the copy feature fails so it might be a good idea to add then and catch to uh at least display some kind of error at least internally for you so you know something is going on this is not a bad idea and in here it allows improving uh it suggests improving accessibility for the iframe by adding the title and area labels great i'm satisfied with what we have so I'm just going to merge this pull request and once it is merged I'm going to go back here main branch and refetch and after it refetches there we go fragment view is the last merged one amazing that marks the end of this chapter so let's go ahead and mark this as complete and see you in the next one amazing amazing job in this chapter we're going to implement the code view this will be a slightly longer chapter in comparison to our last one simply because we have a bit more components to create but let's start with adding tabs in our project view component so that we can switch between the fragment web component and code view component so as always ensure that you are on your main branch and you can synchronize changes the last chapter was 12 fragment view now let's go ahead inside of our project view and this time we're going to add a couple of components so let's go ahead and just in between the fragment and the components UI resizable add tabs tabs content tabs list and tabs trigger from components UI tabs you have them installed when you added chats UI and once you have added them it's time to use them so what I'm going to do is I'm going to go below the project view and I will add tab state and set tab state I will add use state here and I will set the options to be preview or code and by default it's going to be preview now Now that we have the tab state let's go in the second resizable panel here and let's encapsulate the active fragment within tabs now in here let's give the tabs a class name height full gap Y zero default value will be preview value will be tab state and on value change we'll get the new value and set tab state to be value as preview or code like this then inside of this tabs let's add a new div and let's encapsulate this once again this div will have a class name of full width items center padding two border bottom and gap x of two and then open tabs list and again encapsulate the fragment inside of the tabs list give it a class name of height zero padding zero border and rounded medium and then finally inside of here we can add tabs trigger the first one will be the value preview with the class name rounded medium we're going to render the I icon here which you can import from Lucid React and while you're here also import icon let me just move them to the top there we go so let me just fix this uh just a second so I think I just have to remove this there we go so inside of this tabs trigger add the eye icon like that and a span demo and then copy this trigger this one will be code with the text code and uses the code icon and then outside of the tabs list go ahead and add a div with class name ML auto flex items center and gap x of two and this button will uh I'm sorry this div will encapsulate a button from components UI button which will uh not serve any purpose now but it will later so give it as child give it size small variant and for now give it well just default a link from next link so make sure to add this with an href of pricing and add a crown icon and upgrade text great and now outside of that div and outside of this div as well so move this outside add tabs content this one will be for value preview so you can put this finally inside and then we're going to have another tabs content or value code and this will simply be a paragraph to-do code there we go so make sure tabs content is still inside of tabs so now when you go inside of your app here you should see a button to upgrade which should lead you to 404 page and you should see that you can switch between demo and between code uh the demo doesn't show anything until you select a fragment right so you can see how you can switch between the two so now let's develop the code part so in here it will be quite similar so let's start by doing the following mpm install prismjs this will be used to uh highlight code syntax so let's go ahead and develop this simple component inside of source components so in here add code view.tsx and in here you're going to need uh just one more thing so let's actually create a folder code view like this and move this inside and you can change this to be index.tsx and then go inside of your uh vibe assets you can use the link in the description or you can see it on the screen here and find code theme.css so it's quite long that's why we are not typing it so go ahead and copy this and create it here so code theme.css and just paste the entire thing inside and save it and now let's go ahead and develop the code view here so you're going to import everything from PrismJS and let me show you Prism.js oh did I install it or not mpm install PrismJS let me see prismjs it is installed but I think I also need to do mpm install-d at types prismjs there we go so prismjs 1.3 and types 1.26.5 and now it works below that import use effect and then import the following things risenjs components and then JavaScript JSX Python TSX or TypeScript you can remove if you're not going to use Python for example and finally import code theme CSS so just make sure this is in the same folder right then export const code view and create a simple interface props which accepts the code which is a string and a language which is a string so assign the props let's dstructure them code and language and inside of here return a pre-tag give it a class name padding two background color transparent border none rounded none margin zero and the text extra small and inside of here add a code element which renders the code and let's give this a class name and let's go ahead and use language dash lang like this usually if this was a TypeScript uh class name you would not do this because this type you shouldn't do this kind of half dynamic class name right you should instead do the full one but this is not a Tailwind class this is a class from Prism right that's why you don't have to worry because you can see that it is exactly what it expects and now let's just use the use effect here for a very simple thing so on load simply use prism and highlight all that's it so that's going to be our code view component and if you go inside of project view uh maybe we can already render it let's try code view and let me try adding language to be JS or let's do ts and let's do code let me just try const a is equal hello world something like that let's see if we are able to preview that and we are there we go and I think that it will also affect dark mode and you can see how the syntax is visible very nice and now let's actually uh use this in a file explorer because that's what we have to do next so we're going to go ahead and create the file explorer inside yes let me just show you how you can import code view so you don't have to go to index index can be uh used like this that's why we named it index so you can just target code view in case this doesn't work for you for any reason you can just name this properly name it code view again and then just import that way and let me just move it up here there we go so now let's create the file explorer component i'm going to go inside of source components file whoops file explorer.tsx and let's go ahead and let's prepare the imports copy check icon and copy icon from lucid react use state use memo and use callback as well as fragment from react hint and button from components button comes from shatzen meaning it has the UI prefix and hint is our custom component which we created in the previous chapter now let's import our new code view which we just created and then let's go ahead uh and add resizable with resizable handle panel and panel group and let's also import everything we need from breadcrumb so both of this come from shatnui so you have them breadcrumb item list page separator and ellipses now let's go ahead and let's define our file collection this is our file collection type it is basically a type of record string string but I like to use this type simply because it uses the path as the key and then the content here i think this kind of visually makes more sense i think we did the same thing in our functions path string yes this is exactly how we defined our files here so I like to do this because I think uh it visually looks better great so now let's go ahead and first create a function which can extract language from file extension so get language from extension accepts the file name and returns a string and what we do here is we simply target the extension part and we take that part and we turn it to lowercase and we default to text if we were unable to do that so basically if we enter something like app.tsx we return tsx as the language as simple as that perfect now let's go ahead and let's create uh a component which we are going to need in order to even render uh which file is currently active so I'm just trying to think what is the best way to build this so that you can see the results as soon as possible because there's a lot of components we have to build and I'm just afraid that um we might have to build for a lot of time without seeing any results so this is what I will do we're going to do export const file explorer like this let's create an interface file explorer actually let's just call this yeah file explorer props because we're going to have many components in this file so I want to name this explicitly to be file explorer props it will accept files which are a type of file collection like this then let's go ahead and let's use this and we can destructure the files from here so now what I want to do is I want to add the return resizable group resizable panel group like this with the direction horizontal and then resizable panel with a default size of 30 with a minimum size of 30 and a class name background sidebar and inside of here a paragraph to-do tree view like this then let's go ahead and let's add a resizable handle here with a class name hover background primary and transition colors like this and then let's go ahead and do another resizable banner like this with a default size of 70 and a minimum size of 50 and in here what we are going to do is try and do files first in the array i'm just thinking of a way okay I know what we can do now let's create a state called selected files so const selected file set selected file use state and it can either be a string or null and let's go ahead and create a function inside of use state to get the file keys by using object keys and pass in the files and then return file keys.length length is larger than zero we can select from the file keys the first in the array otherwise null so this way we are going to pre-seelelect the first file we can find and now that we have this first file I think it will be a little bit easier for us to build this UI so inside of this second resizable panel check if we have the selected file and if inside of files we can find this selected file if we can do that go ahead and render a div code view like this otherwise let's go ahead and render the alternative which is a div which says select a file to view its content with a class name flex height full items center justify center and text muted foreground and I think it's time to render this so let's go inside of the project view here and let's go ahead and render it instead so remove code view and check if you have active fragment question mark files render the file explorer component and pass in the files to be active fragment.files files as and in here you can choose to use let me just copy from here this type basically because the JSON type will be any right so we are now marking it as this make sure to import the file explorer and you can remove the code view now because we're going to use it inside of the file explorer and I think that already just make sure you have a fragment selected here When you click on code you should have a to-do tree view and to-do code view perfect and I've had some trouble uh making this work oh looks like it's working just fine okay my version had some problems i think looks like it works just fine nevertheless okay now let's go ahead and let's actually develop the tree view and the code view so I'm going to go back inside of the file explorer here and I think it might be easier to develop the code view first simply because we already have the code view so I'm going to go inside of this div here and I'm going to add a class name height full width full flex and flex column and then I'm going to open a new div the class name border bottom bg sidebar px4 py2 flex justify center uh actually it will be justify between items will be center and gap x will be two then let's add to-do breadcrump file breadcrump like this and then add a hint component wrapping our button component and give this a text of copy to clipboard and the side of bottom and for this button right here give it a variant of outline a size of icon a class name of ML auto on click to be an empty arrow function and disabled to be false and inside of here render the copy icon so now when you click on code you should have the copy to clipboard button just make sure you have both button and the hint imported great and now below this div we're going to open a new div with a class name flex one overflow auto and render the code view in here select the code to be files and then selected file and the language will be oops the language will use our function get language from extension selected file whoops like this and by default you can see that it selected a specific file right now I'm not able to scroll we will fix this as well by uh let's see it has overflow auto but I think that we are missing uh something obviously because it's preventing us from doing this uh so let's see everything here seems fine but yes I'm not able to scroll to the bottom here so how about I go inside of the project view here and to the value code add a class name a minimum height of zero and I think that now when you select the fragment there we go now I'm able to scroll in all directions you should be able to scroll left and right and up and down so basically inside of your project view in the tab content for the value code add a minimum height of zero and this will allow you to scroll inside of the code preview so this is now showcasing the very first file it selected but now we have to build the tree view so we actually see the file we selected and so that we can choose between other files and then we need a breadcrumb component here to render the current file so let's go ahead and let's build the tree view next so I'm going to prepare that right here in the file explorer right above where we added a to-do to render the tree view let's add tree view like this and let's give it some props data is going to be an empty array value will be selected file on select will be an empty function and now let's go ahead and let's prepare this things here so what I want to do now is the following uh I want to go inside of source lib utils and I will export function convert files to tree items and I'm going to create a JS doc like this simply so you can see what happens so this JS doc is quite useful i don't like I mean I don't use it usually but it's useful when I feel like things are not exactly clear you can see how when you create a comment like this and when you hover over a function it actually tells you that so it converts a record of files to a tree structure so we accept files which is a record of file paths to content so this is the input right source button tsx and then some content and this is the output that it will return so that's what we are building now so let's go ahead and add some props here files which will be a type of path which is a type of string and a string and it will return a tree item so now we need to create the tree item object so let me just uh do this like so I'm trying to think of a perfect place to add this to um how about in source we just create types ds and let's export type tree item and that will be a string or an array of string and tree item itself so it can reference itself right it can be a deeply nested array now that we have this we can go back inside of the utils file here uh and we can set the return method to be the return type to be tree item from the types and it's going to be an array of those three items and it's going to be an error until we actually return that so I want to do this because this way we are certain that we correctly developed this so let's start by creating an interface tree node like this which is basically a key which is a string and then tree node which is itself inside or null then let's define a tree which is a type of tree node and it's going to be an empty object at first now let's go ahead and create sorted paths so we are basically sorting the files alphabetically by their path and then what we're going to do is a for loop so for const file path of sorted paths let's go ahead and this uh split the file path into parts by doing file path.split by a forward slash the current one will be the current tree which is just the empty object for now and then for let index being zero index being less than the parts length minus one and index increasing by one for each iteration get the part so parts and using this index here if we cannot find the path the part in the current object we need to add it there like this and then current is equal to current part like this and then what we have to do outside of here is add the file or the leaf node right so const file name is parts parts.length minus one current file name is equal to null this will basically indicate that it's a file this is quite confusing right but once you see how the file uh structure will look it will make a little bit uh more sense uh okay so I think that this uh let me just see yeah so okay we just finished this for loop right and now we have to uh convert the node so let's create an inner function to do that function convert node the node it accepts is a tree node we have defined a tree node right here and the name is an optional string and it returns back a tree item an array of tree items or a single tree item like this so let's get the entries to be object entries from a specific node if entries.length is equal to zero return the name or an empty string then define the children to be a tree item like so and set it to be an empty array for now and then let's go ahead and do for const they structure the key and the value of entries and do the following if value is equal to null that means this is a file so do children.push key else this is a folder so create a sub tree using convert node and pass in the value and the key so we need to go deeper we need to recursively call this function again until we find a file if array is array subtree children dopush open an array of key and spread the subree else children do push key and subtree like so and then let's go ahead outside of this four and return the children like so and then let's define the result here to be convert node tree and return array is array result otherwise result inside of the array like this and if you've done it correctly you should have no errors here now I completely understand that this was a very complex task and if if you are worried that you did it incorrectly don't worry uh I have added my entire utilus files to my public assets so you can just find it here and you can copy it from here for example I can copy this entire file and I can paste it in here like so so now I have this convert node and I have the convert files to three items right so if you want to do a double check or you just want to copy file uh because it's easier you can do that don't worry uh yes a slight mistake here my apologies uh so don't worry I will fix I will fix this file so it doesn't use this import because our tree item comes from types yes so import type three item uh I will fix that instead i think I can fix it right now there we go like so so when you copy you won't have that problem uh and I will double check by copying this file again pasting it uh oops copy it again i cannot seem to copy it let me try one more time i think the copy button is still using the old one okay finally no errors in the utilus file okay so now that you have the convert files to tree items we can go back inside of the file explorer and in here uh we're going to have to create tree data so const tree data will be use memo and return convert files to tree items and pass files here and in here add files as a dependency so just make sure you imported our newly created function here uh you can either write write that function yourself as we just did or you can copy it from the source code or from the assets folder uh great now that we have this and we have the tree data let's go ahead and let's add the const handle file select to be use call back and inside of the use call back we're going to check the file path to be a type of string and if files file path exists set selected file to be the file path and add files here there we go perfect and now inside of the tree view add the tree data here and on select add handle file select like so and now it's time to develop the treeview component so I'm going to go inside of components tree view.tsx let's go ahead and create the interface tree view props which uses the tree item from our types like so and now let's export const tree view let's assign the props tree view props in here we get data value end on select and in here let's go ahead and let's return a paragraph tree actually maybe we can do JSON stringify data just so we can see what we created and let's import the tree view from dot slash treeview and if you go back to your app here select a fragment and click code there we go i have app folder and page.tsx so those are for me but if I go into one of my older ones well looks like all of these are pretty simple so it's going to keep using just uh a simple example but if you tell it to build something complicated uh you will have more items here so this represents a folder and this represents a file and now I mean this is basically how the file structure should look like and now we're going to use that to properly render the tree view so uh let's go ahead and let's import everything we need from the sidebar component so that's going to be the sidebar the content group group content menu menu button menu item menu sub provider and rail from components UI sidebar you already have this when you added Shatsen UI and now let's go ahead here and let's render that so starting with the sidebar provider and let's render sidebar with collapsible to be none and class name to be width full and then sidebar content like so inside of the sidebar content sidebar group sidebar group content sidebar menu like that so you shouldn't see anything now simply because we didn't add anything in the menu so now what we have to do is we have to develop the tree component so let's do that below here const tree will have an interface tree props which will accept item which is a type of tree item it will accept selected value which will be an optional string or it will be null on select which will be an optional function which accepts the value which is a type of string and returns a void and parent path which will be a string so let's go ahead and add tree props here and the structure the item selected value on select and parent path like so inside of here let's first do a destruction of the name and the rest of the items from an array array is array item if it is we can render the item otherwise put the item in the array then let's get the current path this will check if we have the parent path and it's going to render dynamically using backd parent path forward slashname otherwise just the name of the file if we don't have any items uh this means that this is a file so let's add it's a file const is selected here will be selected value equals current path and in here we're going to return sidebar menu button with is active to be is selected and class name will be data active true background transparent and I'll click Here we'll call on select with a question mark because it can be optional and pass the current path inside of here render the file icon uh file icon from lucid react just make sure you have it like that and below that a span and the name and this will have a class name of truncate like that and then go outside of this if clause and this means it's a folder and in here return sidebar menu item with collapsible uh we now have to import the things from collapsible as well my apologies I forgot about that so just add collapsible content and trigger from components UI collapsible you also have those components so let's go ahead uh down here and instead of the sidebar menu item open collapsible like that uh let me just fix this collapsible give it a class name of group forward slash collapsible and then add the following class name which is a little bit longer and looks weird so basically open curly brackets and this entire thing is inside of that curly brackets and and then if data state is open for this component target the button target the SVG and target the first child and rotate it by 90 and set the default to open inside of here collapsible trigger with the prop as child Add a sidebar menu button component with the chevron right icon from lucid react and give it a class name of transition transform so this is the icon that we are going to rotate by 90 once we open this collapsible and next to it add a folder icon from Lucid React and then a span with the name of the folder and the class name truncate and then outside of the collapsible trigger use a collapsible content and inside of this a sidebar menu sub and inside of here go over items.mmap get the sub item and the index and render the tree again that's right we are rendering itself again and in here set the key to be index item to be sub item selected value to be selected value on select to be on select oops parent path to be current path like that and that's it for the tree component what we have to do now is we have to actually use the tree component and we're going to do that by going back here inside of the sidebar menu and simply do data.m map item and index render the tree component pass in the key to be index item will be item selected value will be the value on select will be on select and parent path will be an empty string so let's see what we didn't use we didn't use sidebar rail so we forgot that so let's go down here after sidebar content and render sidebar rail now let's go inside of the file explorer oh we already have tree view so there we go here we have it and we can open and close it uh but looks like our select isn't really showing it isn't working so let's fix that or maybe this is the selected state i'm not exactly sure so I'm going to try and develop something a bit more complicated so I'm going to try to prompt it to something to create more files okay so what I did is I asked it to build a landing page with each part in its own component and that generated a much better result as you can see so what I'm going to do is I'm going to expand this i'm going to go back to the code and yeah I still am not able to select this so let's go ahead and look at what we forgot to do so okay these breadcrumbs are unused that's okay uh we're going to use them in a moment but it seems like this handle file select uh is not working properly so what I'm going to do is I'm going to first start by adding a console log and rendering the file path so I'm going to open my inspect element here and okay oh so it looks app name is being sent okay so that definitely doesn't exist let's go inside of a tree view and let's see what I did wrong so in here we have on select parent path and then the name yes this this doesn't look correct i think I meant this in the current path let me refresh and check select the fragment check there we go so I'm I'm not sure if you can see well you can definitely see the code is changing right and also the file is is a little bit bold so basically the problem was in the tree view component the current path I hardcoded name when what I should have been doing uh is put it inside of curly brackets like this excellent so now that we have this uh the good thing is no more no need for to do anything more in the tree view uh now let's go ahead and let's enable the copy button and let's create the file breadcrumb here so I want to do the file uh breadcrumb thing first so I'm going to go inside of the file explorer um let's go just above it here so const file breadcrumb like this let's go ahead and create an interface file breadcrumb props which accepts an individual file path let's extract the file path from here and let's go ahead and get the path segments by a forward slash and let's limit the maximum number of segments to be four so if the path goes deeper than four segments we're going to be responsive about it now let's do con render breadcrumb items like this and in here if path segments length is lower than or equal than maximum segments add a comment show all segments if four or less so let's return path segments here map segment index const is last will be if the index is equal to path segments.length minus one and in here return a fragment give it a closing tag give the fragment a key of index the fragment is imported from React right here inside of the fragment add a breadcrumb item check oh let me just fix bread breadcrumb inside check is last if it is render breadcrumb page and inside the segment and give it a class name of font medium if it is not last we're going to render a span element and segment inside and give the span a class name text muted foreground and then outside of the breadcrumb item if it is not last again add a breadcrumb separator like so and this was inside of this if so let's now add else we are going to show the first element and then ellipses if we have more than four of them so the first segment is what we care about path segments first in the array last segment so path segments.length minus one so it's only those two that we care about and once we get those two let's simply return a fragment breadcrumb item a span first segment with a class name text muted foreground and then let's go ahead and add the breadcrumb separator and the breadcrumb ellipses like so so render the breadcrumb separator and then a breadcrumb item which renders the breadcrumb ellipses all of these are imported from the same thing then let's add another breadcrumb item here with a breadcrumb page and render the last segment inside and give this a class name of font medium and finally outside of this function return breadcrumb and then breadcrumb list and then render breadcrumb items like that so a little bit of effort here to create nice and responsive file breadcrumbs and now let's go ahead and let's render them so that's going to be rendered in the code view so there we go to-do file breadcrumb just above this hint let's render a file breadcrumb and let's give it a file path to be selected file and there we go app contact tsx features footer hero navbar and if you create one that's very deep it will show a maximum of four folders before it uses the responsive mode and it will just replace the folders in between with an ellipses which is basically three dots perfect now let's implement the copy feature so we already did this before so we can copy it from that place handle copy use call back if we have the selected file right to the navigator clipboard with files selected file and now we have to add the set copied state so let me just add it here above the selected file copied and set copied perfect so now we have handle copy and now let's use the handle copy for this button right here handle copy and let's paste in copied copied if it's copied we will use the copy check icon otherwise the copy icon like this and you should no longer have any errors in your code because we are using everything so when I click copy it turns into a different icon now and you can see that I just copied that entire thing amazing we just developed a super amazing file explorer so now I'm going to try to prompt it to create a deeper structure but this is pretty much it for uh this chapter all right so this time I told it build a landing page with each part in its own component use deeply nested folders and you can see that I definitely got that so inside of the app folder I have a landing and then I have features and then I have the file and you can see our breadcrumb in action now but for example you can see that I can break it right i if I open this too much it breaks so what you can do is you can remove the maximum segments here to be three and it will be reasonable to change the comment here as well and this is how it will look like then let me just refresh i think the error was because of the hot reload and let's click on the fragment here so let me select features uh okay so you can see it works but it seems like we have some problem here uh okay list cannot be a descendant of list uh okay it's a hydration error it's not exactly too big of a problem but I'm not um I'm not too sure how to fix that at the top of my mind right now so I'm going to leave it like this i think it's not too big of an issue it's a small hydration error but you can see how it looks right and if you click on something simpler like page you can see that it will display the entire thing but for something complicated it will just show you the first and the last segment so you can decide if you want to show that for three segments or for four segments right whatever makes sense for you amazing amazing job so I think this was uh a much harder chapter but I think it was worthwhile we have an actual uh file explorer now that we can copy files from and explore everything that was created we can scroll definitely an impressive result so now let's go ahead and mark these things as completed and let's open a new branch so 13 code view let me collapse this open the source control opening a new branch here 13 code view just to double check that's the chapter's name once we are on the new chapter I'm going to stage all of my changes 13 code view i'm going to commit and I'm going to publish this branch as always a reminder there's a free code rabbit extension you can use to review your files and now let's go ahead and let's see our pull request so I'm going to open this new pull request here and let's review our summary and here we have the code rabbit summary we introduced a code viewer with syntax highlighting and GitHub dark theme we added a file explorer with three view breadcrumb navigation and a copy to clipboard functionality for code files we enhanced the project view with tabbed navigation allowing users to switch between a live demo and the code view of project fragments that is exactly what we did in this chapter as always a walkthrough of file by file and of course a sequence diagram so in here we have this very complicated component which we build the file explorer which renders the tree view and then finally the code view so in here you can see it generated the entire sequence diagram for that component along with the prisjs code highlighting so very very good we have a few comments here um this one is a good comment it's basically telling us to also add an actual type of check the reason it's telling us this because uh it could be anything but then at the same time we know that it's always going to be an object it's going to be a type of JSON right so I think this is a little bit redundant adding it would not hurt but I think it's okay the way it is right now i'm not sure about this change i think uh it works just fine like this and in here I accidentally added two semicolons in the file explorer props so yes of course we can remove that i'm going to do that in the next chapter and there we go let's merge this pull request and let's go back here and let's go ahead and go back to main and let's synchronize our changes again and once you've done that go inside of source control graph and just confirm that you merged the 13 successfully amazing amazing job that marks the end of this chapter and see you in the next one in this chapter we're going to develop the homepage this will include creating the home layout the homepage component which consists of project form and project list let's go ahead and let's start our app running npm rundev in one terminal and starting in justestdev server in the other and now let's go ahead and make sure we are on the main branch and you can click on synchronize changes just to make sure everything is up to date inside of your source control the last merge should be number 13 now let's go ahead and let's fix one thing that's been bothering me so right now uh I'm loading my previous project here you can see that when the project loads no fragment is selected this is because in the messages container here we commented out this use effect which selects the last fragment because it was causing problems you can see that when I enable this then it works this is selected but it's annoying because if I want to select this one and look at it you can see that it automatically moves it after 5 seconds why after 5 seconds because we refetch every 5 seconds so this use effect can obviously be improved so let's go ahead and make it a little bit simpler i'm going to go ahead and remove everything in here for now and I'm going to start by adding a new ref right below the bottom ref add last assistant message ID ref which can be a simple use ref of a type of string and now inside of this use effect here let's go ahead and find the last assistant message so last assistant message we'll use messages find last and then simply find the message whose role is assistant so messages.findlast find the last API is that we are using and then in here we're going to open an if clause and what we are going to do is we're going to check if last assistant message fragment exists and if last assistant message do ID is not identical to last assistant message id refer let me just remove this so if that's the case only then are we going to call set active fragment and do last assistant message fragment and then we have to update last assistant message id ref.curren to be last assistant message id and this way we won't have any unnecessary updates and we can remove this to-do here so let's go ahead and do a refresh again and there we go so you can see how it selects the fragment the last assistant message it it can find but if I manually select this one let's wait for 5 seconds and you can see that nothing will change it right simply because this last assistant message ID ref is stored so the only time that we are going to override users selection is if an actual new message arrives i think that's an okay UX if you want to you can uh improve this logic even further by creating two separate states one for the automatic selection of the active fragment and one for the user selection of the active fragment and then you can overrule one over the other if that's something you prefer because you can see now nothing can change the fact that this fragment is active unless I do build a yellow landing page so if I add this still nothing is happening i'm still uh having this older fragment as selected only after uh this finally responds with some new content will the new fragment be automatically selected because it is constantly looking for the last new assistant message so our message wasn't able to trigger that use effect and if it simply calls the refetch request and it receives the exact same messages we compare the last message ID with our ref ID and if it's the same no we don't change anything and there we go you can see how it works i didn't change anything it just generated a new landing page and it selected that fragment that is the exact behavior we hoped for amazing so what I want to do now which you know you can choose if you want to or not i just want to remove this handle from here i don't like it so this is what I'm going to do i'm going to open both the project view and I'm going to open the file explorer and the only thing I want to do in the file explorer is copy the class name from the resize handle and then I'm going to go inside of the project view i'm going to find the resizable handle here remove the prop with handle and just paste the class name here and there we go now I have this type of resizable and there seems to be some kind of problem you can see when when you have two resizables active you can only move one of them right so you can't move this one i'm going to explore at the end of the tutorial if that's something we can fix there might be some solution but you know it's it's not too big of an issue great so now let's go ahead and let's actually uh build the homepage so we're going to go and do the following inside of your source app folder create a new folder home this is a route group this will not be a part of the URL but it can hold things like layouts so let's go ahead and build a simple home layout here the first thing we have to do in a layout is create props which hold the children and then we have to do a default export like this and in here we assign the props and we extract the children and then inside of here let's add instead of div let's add main and let's give the main a class name of flex flex column minimum height of screen and the maximum height of screen like so and in here let's add a div with a class name flex one flex flex column ex four and padding bottom of four and inside render the children and then what I want you to do once you have this layout tsx it is important that this is called layout this is a reserved file name just like a page right so it's important that you use layout and it's important that you do a default export here what I want you to do now is I want you to uh move the page tsx from the app folder the global one and drag it inside of the home folder so move it inside and sometimes this can trigger some unsaved files so if you get any unsaved files here you can just close them and if it asks you if you want to save it or not you can just click yes if nothing happened you can just continue what basically happens if that does happen to you is cache right the hot reload is currently active so sometimes the cache inside of this folder gets confused when you move a page that's currently uh active so what did we do now well if you go and click back to the dashboard nothing changes right that's because what we just did is we created a layout for all of our uh homebased pages right now this doesn't make too much sense because we only have one page the homepage right but later in here we're also going to have pricing and we're also going to have login forms so that's why instead of copying this code every single time into each page we're just going to uh create a nice little uh reusable layout like so now in here let's go ahead and let's do the following i want to create a uh self-closing div like so and give it a class name of absolute inset zero minus Z 10 height of full width of full bg background on dark use bg radial-ashgradient like so and then inside of here write 39 9 so 3 93 E48_1 pixel comma transparent and then underscore one pixel so this is all one class name dark background radial gradient transparent right so all of this is one class name what's important is that when you hover over this if you have the tailwind extension you should see the underlying CSS if you accidentally add space somewhere that breaks the class you can see how now it's not working so just be careful don't add any spaces i mean this is not important this is just for a cool effect you're going to see in a second uh and now what I want you to do is I want you to copy this again paste it but without the dark prefix here and you're going to change the color of this to not be this one but instead be da d2 and this can still be transparent and then just add another one background dash size 16 pixels underscore 16 pixels and now you will see a bunch of dots all over your page so now let's go ahead and let's actually develop this so I'm going to go back inside of my homepage right here and we're going to do the following i'm going to remove all of these things here because we're not going to need any of them i'm going to well I'm just going to clean the entire thing i don't even need use client here i'm going to open a div and I will add a class name here flex flex column maximum width of five excel maximum width of auto and width full i will then add a section with a class name space Y6 py of 16 pixels my apologies 16 VH to Excel will be py 48 now inside of here I will add a div with a class name flex flex column and items center in here we're going to render an image from next image with the source of logo SVG out of vibe width of 50 height of 50 class name of hidden MD block outside of this div encapsulating that image I will add an H1 build something with vibe or the name of your project and we're going to put this heading give this heading class name text to Excel medium text 5 Excel font bold and text center and you should already be seeing something here now below this heading add a paragraph create apps and websites by chatting with AI and give this a class name of text large medium text extra large text muted foreground and text center there we go and now below that add a div with a class name maximum width of 3 Excel MX auto and width full and nothing will appear now that's because we have to create a new component called project form now the cool thing about project form is that you already built this you just don't know it so what we're going to do is we're going to reuse one component that we already have and we're going to go inside of modules projects UI components and in here we have the message form now technically we could modify this message form with a prop you know I could just pass a prop here like is homepage is landing page and then we could modify the CSS but honestly I would rather keep components separate than creating this magical components which can be used a million times right i'm okay with copying my code if it's for one two three instances i'm I would rather do that than creating this ambiguous abstract code that's impossible to keep track of right so this is what I'm going to do instead i will copy that message form and I'm going to go ahead inside of modules and I will create home module and inside of here UI and then components and then in here I will create project form.tsx and then I will copy everything inside of the projects UI components message form and I will paste it here like this and then I will remove the props because we don't need them and this will now be called project form there will be no props for this the value will still be the same but it will not be creating a message it will be creating the project so this will be called create project so let's go ahead and see what we have to do we will reset the form uh actually we don't have to reset the form and I'll tell you why because on success we're going to uh reinvalidate anyway so let's go ahead and do this after we reset the form the only thing we should actually oh I'm sorry after we successfully create a project the only thing we should do is we should call PRPC.pro and we should just refetch get many that's the only thing that should happen and then also we should invalidate the usage status so we can leave this to do and the same thing for this but also one more thing that should happen here is that we add router use router from next navigation let me just move this here when you successfully do this let's do router.push and we push to the newly created project so that's going to be forward slash projects data id as always we have this data because in the projects create procedure here when we create the new project and then we invoke a background job we return that new created project so we have access to it right here great so on submit we'll be calling create project and we don't need the project ID here at all for the is pending we will have create project is pending like so we can remove the show usage uh from here entirely we don't need it on the homepage so you can remove this show usage here like so uh what would you like to build can stay the same to submit to submit honestly I think everything else here works just fine so yes just a slight modification here and now let's go ahead and use it inside of our app homepage.tsx let's import project form from modules UI components project form and I think we also need to add use client here because it's imported in a server component so it wouldn't work and there we go this is how it's going to look like and you can already try it so build a landing page i like to use this example because I think it's super simple and works almost every time and there we go you can see what happens so from the landing page we create a new project with build a landing page initial message perfect so if you want to you can wait for the result uh I know it's very fun to always see the results so I I completely understand if you want to but I'm going to go back to the project form and what I'm going to do now is I'm going to show you how you can create some predefined prompts for the users so that they can easily click on them here so it's so that they can see the results faster so this is what we're going to do we're going to do this inside of the project form so in here go outside of this native form elements and create a div with a class name flex wrap justify center gap 2 hidden MD plex and a maximum width of 3XL and now in here what you should do is you should create something called project templates so you can go inside of the public assets folder which you can see the link for on the screen or you can use the link in the description and in here you can find uh constants.ts ts and in here I just created a bunch of project templates for you uh and you're going to have to you know test each of these out depending on the model you will use and what works for you and what doesn't because it's a good idea to showcase your project templates on something that you know will always work with your AI model right so I'm going to put this inside of home i will create new constants ds and I will paste that here so basically something like build a Spotify clone build an Airbnb clone build a store page YouTube clone file manager and I'm just using very descriptive prompts here because it will work better if you give it a good description but the cool thing is that you know you have full freedom to improve the prompt in any way in here when I select build a Netflix clone the full prompt will be build a Netflix style homepage with a hero banner uh use a nice dark mode compatible gradient here movie sections responsive card and a model for viewing details using mock data in local state use dark mode right so it's a very descriptive uh prompt but depending on what model you use you might be able to do it with just build a Netflix clone right it will just depend on the prompt that you're using and the model that you're using for example Claude Sonet understands uh your instructions very very well but with OpenAI I sometimes have to tell it you know if you're using dark mode make sure you use Next themes because you have Shhatzen installed right i have to tell it uh a more in-depth about what's going on so make sure you have this project templates and now what you're going to do is you're going to iterate over them so project templates which I've just imported from dot dot /constants here dom and for each template I'm going to return a button component I'm going to give the button a key of template dot title and then I'm going to add some additional attributes to the buttons so variant of each will be outline size will be small class name will be background white and dark background sidebar on click here on select will be called which we don't have yet so let's just leave it as empty and then let's put template emoji and let's put template title and let's see that now and there we go so you can see that now beneath this big input bar uh you can select any of these so let's go ahead now uh and just properly space these things out so what I want to do is I want to wrap my form inside of a section with a class name space Y six like so and just encapsulate all the way to here like that and then you can indent the entire thing and now you have a nice space in between and now we have to create the ability to actually select this so for this I'm going to add const on select content string form set value content or whatever you use let's see so we use uh value is the one we use so set value to be content or you know you can just put value here a lot of value uh and what's important you do is you enable all three should to true should validate to true and should touch to true this will basically simulate it to be in the same state as if the user actually typed this so now what you have to do is you have to add the on select to the buttons so call on select and pass in the template.prompt like so so now when you click on build an admin dashboard there we go you can go ahead and run this so I suggest that you try running this and also keep in mind some of these are larger tasks so they might actually time out right so be mindful of that the good thing about uh ingest is that if it notices a rate limit it won't retry immediately it will it will retry with exponentially longer pauses between each retry which if you're using Open AI is perfect because Open AI has reasonable timeouts so when you hit a limit in Open AI they punish you with like 2 seconds of waiting time so inest will wait for even longer than that and if it happens again it will wait for even longer so you don't have to worry ingest and OP and I are quite a good combination uh and you can see that with this longer prompt right where I told it let me just see create an admin dashboard with stat cards placeholder all of those things blah blah blah and here it takes a bit of a longer time you can see almost a minute but as I said you can speed these things up by using a different model you can create a smoother prompt right a lot of things you can do so let's just see this result i'm very curious if it will work or not and there we go so almost the exact same thing as we saw uh in the initial demo amazing and you can see the code here very very good so I would suggest that you you know try a couple of these and if some are obviously failing well you can try and you know fix them in the prompt or you can simply replace them with something simpler because if you're actually building this as a business it's a good idea that you you know allow the user to select something that will 100% work right you don't want to give them something that might work or might fail right perfect and I'm just super interested let me just go back here i want to change this to dark mode i want to see how this looks like looks pretty good great uh but I actually prefer working in light mode so let's go ahead now and let's develop the bottom part which is the project list so so far we created the project form and the layout now let's create the project list in order to do that we have to go back to our page dsx where we render the project form and we have to render the project list outside of this section so project projects list like this and then let's go inside of our home modules here so home UI components projects list.tsx let's mark this as use client and let's import everything we need here so link from next link and image from next image format distance to now from date FNS use query from tanstack react query and use tRPC from TRPC client and button from components UI button let's export cons projects list here and let's start by defining the RPC then let's define data projects to be use query DRPC projects get many query options like that and then in here let's return a div with a class name full width background color of white dark background color sidebar rounded extra large adding eight border flex X flex column gap Y 6 SM gap Y4 then let's add an H2 element which will just say previous vibes or saved vibes i thought it would be fun to call old projects vibes because the project name is vibe right you can of course just say old project saved projects whatever you want so text to Excel and font semi bold later this will say Antonio's vibes or whoever is logged in but since we don't have out yet we can't display that just yet so now let's just import the projects list simply so we can start seeing the progress so right here at the bottom you should see saved vibes right here it should look like this so now let's go ahead below this and let's create a div with a class name of grid grid columns 1 SM grid columns three and gap of six and then in here check if projects.length this should be a question mark so if projects.length length is equal to zero in that case let's display a div with a class name all span full and text center and inside a paragraph no projects found and a class name text small and text muted foreground otherwise let's do projects do map get the individual project here and then return a button give this button a key of project ID a variant of outline and a class name font normal height auto justify start full width text start and the padding of four and give it an as child prop then go ahead and add a link here with a dynamic href forward slash projects project id and then inside of here create a div with a class name flex item center and gap x of four then add an image here with a source of logo SVG out of vibe width of 32 height of 32 and the class name object contain below the image add a new div with a class name flex and flex column inside of that div they have an H3 element with project.name name inside and give the H3 element a class name of truncate and font medium and below it a paragraph using format distance to now which we imported from date FNS project updated at add suffix true and give the paragraph a class name text small and text muted foreground and that is it so in here now you can see all of your previous vibes so you can go ahead and visit them and in here the source code is of course preserved great so I believe that that marks the end of this chapter where the goal was to build uh a the goal was to build uh a landing page and we added the templates we added the project list we added the ability to you know look at this older projects and I think we did an amazing amazing job here obviously there are some things still missing like the navbar but we will do that later when we add authentication so what I want to do in the next chapter is I actually want to improve the theme of this project because my original theme in the demo was some kind of yellowish color so I'm going to show you how I modify the theme to make it look like that and I'm super interested in the result of this so I'm just going to wait uh hopefully it will work if not you know it's just a lesson that these AI models are a bit undeterministic you can't really rely on them too much but if you spend you know more than uh I built this app in a span of a month right so I couldn't really spend too much time learning proper prompt engineering but if you actually use this for your business you are most certainly going to spend a lot of time on this and you will learn prompt engineering and you will learn how to improve the prompt and how to fix this little mistakes because in comparison to what you've just built an app failing is really not a big issue you can learn how to speed it up you can use a new model uh you can spend you know more credits you can basically do a billion solutions but the boilerplate is here and it's working so for example you can see that I've gotten an error for this file manager you might not get an error again it's a very simple fix it forgot to add use client to the top of the file we can see that in the file grid it was supposed to add use client but it didn't right or it should have added it to the page so perhaps this can be a very very easy fix you know you can maybe tell it inside of the prompt right here you can somewhere add a rule that it must add use client how about this let's add always add use client to the top of page tsx so because we are not expecting this to make any API calls right so then I can maybe remove this and I can just extend it and any other relevant files which use browser APIs or react hooks use effect okay I won't add too many tokens now but for example you can do things like this and I think that already uh this should work much much better and I purposely want to retry it now just to see if that will fix i'm trying to teach you that you know you don't have to use this prompt you can make your own prompt like I built this prompt and I have no idea about prompt engineering i just started very simple and then I extended and I extended and I extended right so I just added this file safety rule to always add use client at the top of page.tsx simply because uh if it does that it doesn't have to worry about adding it to the other places so let's see if this will fix the problem or maybe some new problem will arrive and finally I managed to get it to work so this was very funny it actually failed uh again right it forgot to add use client again but look at this it added it but it didn't add it at the top of the file so you can see how funny these AI models are sometimes you will lose your mind trying to tell it to do something right so this is what I did i modified this always add use client to the top the first line of app page tsx so this way it understood me and it did an interesting thing this time you can see that it understood what I wanted now and also it decided to create a whole new separate file where it created everything i'm not sure why it needed to do that um but let's see what it created because I think that this is very interesting actually can I rename this okay I can't do that oh I can one two three save oh it works i can rename i can delete or can I i can this is actually super impressive can I delete entire folders looks like something's wrong with the models keep in mind that sometimes the problems aren't in code but the problems are in the iframe right sometimes you might have to visit a live example wow this is actually a very very nice example of a file manager but yeah you can see that I had to struggle a bit with this right i got a very good result in the end but you know the prompt can always be better again I'm not a prompt engineer i have no idea what I'm doing when it comes to prompt engineering so spend some time learning that and you will get even better results than uh what I am in this tutorial but I still managed to get extremely impressive results great so I believe that that marks the end of this chapter now so 14 homepage let's go ahead and close everything here and I will go and create a new branch 14 homepage like so i'm going to stage all of my changes and I will create a commit 14 homepage i will commit and I will publish my branch perfect now let's go ahead and open a new pull request here and let's create a pull request and let's wait for the summary to arrive and here we have the summary we introduced a new homepage layout with a visually enhanced background and responsive design we added project creation form with template section validation and keyboard shortcut support basically a copy of our message form right we implemented project list view showing saved projects with quick navigation and relative timestamps we provided a set of predefined project templates for faster project setup we also fixed the fragment handling uh to prevent repeated state updates exactly uh and we also updated the resizable handle styling for a smoother and more interactive user experience and it also detected our prompt change where we clarified the requirement for the use client directive in relevant files excellent so in here as always we have a more in-depth walk through in here we have a sequence diagram explaining exactly how all of those things happen and in here we have some comments so it suggests adding some loading states here in the project list uh we could very much do that we could even leverage our pre-fetching and suspense we'll see how we're going to handle that later and in here it suggests also adding is dirty check i'm not sure if we need that i think I completed the project without it so I think we don't need this so I'm going to merge this pull request here and after I've done that I'm going to go back inside of the main branch and I'm going to click on synchronize changes and after that my graph here will update and it will show me that pull request 14 uh was just merged amazing amazing job i believe that marks the end of this chapter and see you in the next one in this chapter we're going to learn how to change the theme of our project and I'm going to show you two ways you can do that the first one is to simply visit my public assets folder or if you have access you can use the source code basically just visit the link you can see on the screen or the link in the description and from in here you can find globals.css and in here you can click copy or you can you know manually select and copy things and then go inside of your source app globals.css ensure that you are on your main branch and you can synchronize changes if you aren't sure make sure that the last merge was 14 and simply replace the entire globals CSS file so in here uh alongside changing all the colors this will update as well this is basically what enables button to have a cursor pointer just in case you were wondering so this is new and basically the colors were modified and if you take a look at your app now you will see that we have this new orange color and if you go to the dashboard you will see that it's more of a yellowish color so this is the one that I like but I want to show you exact place where I found this and how you can create your own uh CSS theme so for now what I'm going to do is I'm just going to revert this simply so it is the old global CSS you don't have to right if you like the theme you can copy from my uh GitHub assets you can use it but let me show you how I even found that theme i basically used tweak cn.com again you can use the link in the description or the link you can see on the screen and in here you can go inside of try it now and you can basically click here and find a bunch of different themes for UI and I think it is super cool and the one I selected was cloth right and in here you can check how it looks in light mode and how it looks in dark mode i think this is an amazing project it has so many themes you can try from so I purposely want to pick uh some theme that I haven't tried before let's see how about I try this claymorphism so the way you would do it is you would click on code and in here you can see that they are taking care of Tailwind versions right so I would take Tailwind version 4 and if you want to you can just use the CLI to do it but you can also just copy this and then you will have to replace your root your dark and theme inline so let me show you how you would do that so starting from the theme inline root and dark we select all of these and you can remove them so this is how the global CSS looks now and you just paste the new one here and that changes the entire look of your app as you can see it looks very different now right so if you like this one you can use this one right i personally like the look of Claude so I'm going to select Claude right here code uh code and I will click copy and then the same thing you basically select the root the dark and theme inline and you can delete it so this is how it should look like and paste your new ones here and then your app should look like this i think this is a very very nice look uh and it has nice borders everything just looks nice with this style again I don't know how well this website will be maintained i don't know if this will be available you know 2 years from now i hope it will because it's an amazing project but then again Shhatzen can update a lot and they will probably update the app accordingly to that so because of that I am offering you my globals.css which you can copy from the source code or the global assets and just paste the entire globals.css inside and if you're using this my globals.css you will notice that now buttons have cursor pointers they look clickable right each of these buttons look clickable that is because of this part let me show you this one so if you don't have this u it will not come with uh tweak CN so it doesn't come with this i added this myself in my global CSS so basically this is a way to enable cursor pointer for all buttons which are not disabled so you can add this little snippet if you want to and then your buttons will have proper uh cursor pointers i just think that this looks way better than everything than anything else right now let me try and go to one of my previous projects where I have a lot of fragments you can see how now fragments look clickable right they have a proper cursor on them great i am super satisfied with this one so I will leave it at this and while we are here there is just one more thing I want to do so just go in any of your projects and let's go ahead and do the following select your theme i would recommend using my global CSS and then later at the end of the project you can modify it to whatever theme you like but it will be easier for you to have the exact same result as me so that's why you can use my global.css keep in mind that this is for let me show you next version for next 15.3.4 four right so if you are watching this two years from now I have no idea if it will work for you and whatever is the latest version but if you're using a similar version like me uh or if you're using the exact version as me it will work great so now let's go ahead and do one more thing let's go inside of our button inside of source components UI button and in here I want to add a new variant called uh terriiary i don't know how to pronounce this to be honest i never I always mess this up but basically it's going to be background primary with 25% opacity in dark mode is going to be BG primary again but 30% opacity text will be primary shadow will be extra small hover will be BG primary 20 bg primary 20 and on dark mode hover will be BG uh let me just check on dark mode hover will be BG primary 25% and now go inside of your project view here and in these tabs find the upgrade button and give it a variant of this new one however you pronounce this right and then when you look at it it will look like this it's a kind of uh lighter version and let me switch to dark mode and still looks good and of course check your app in dark mode to see it looks fine i very much like this look of the app more than all the other themes but you're of course free to choose your own and I like how this becomes orange now when you resize your panels uh great so this was a very very easy chapter so let's go ahead and just quickly merge this so mark this as complete and 15 theme i'm going to open a new branch here let me just see what did we all change we'll change this to 30 this new variant here and we changed our theme overall so I'm going to create a new branch 15 theme i'm going to add all of the changes 15 theme i'm going to commit and I'm going to publish the branch and there's really no need for any review because this was a super simple uh change so I'm going to immediately merge this pull request so we speed things up there we go so just three simple changes and we can immediately merge it we don't need to wait for any review this time it's much simpler and after that's done let's go inside of main and let's synchronize our changes and then your last merge here should be 15 theme amazing amazing job and see you in the next chapter in this chapter we're going to add authentication to our project this will include creating a clerk account setting up clerk creating the necessary components to display the authenticated state creating protected TRPC procedures and updating the Prisma schema let's start by creating the clerk account you can use the link you can see on the screen or the link in the description and once you get to the landing page you might see something interesting in here where they mention the companies that use clerk you can actually find injust the company that we are using for our background jaws and you can confirm that yourself by going in their signin screen and searching for clerk inside of their network tab and in here you can see that they are actually making requests for clerk and I just think it is super interesting that such a uh great company uses the same authentication system that we are going to implement in our project right now so let's go ahead and do that once you create your account here you will be redirected to the dashboard and in here you can click create application i'm going to call this application Vibe and I'm going to enable email and Google you can of course enable all of these other providers if you want to and I will click create application after we do that we have to install the Nex.js clerk package but just before you do that ensure that you are on your main branch ensure that your last change was 15 theme and that you have synchronized all of your changes now let's go ahead and let's run npm install lurk nex.js and once it's been installed I'm going to show you the exact version that I will be using 6.23.0 now that we have that let's go ahead and add the environment variables to our environment file so I'm going to go ahead and add clerk and paste these two i like to wrap them in parenthesis but I think this might depend on the system i think Windows might have problems with this uh but I think maybe even not i think all of these will work just fine but yeah in case you were wondering I like to wrap them in parenthesis they don't have to be in parenthesis so all of these could actually be without parenthesis if that's something you prefer i just feel like the syntax looks better with parenthesis uh I keep saying parenthesis I mean quotes sorry uh okay now let's create our middleware file so that's going to be inside of the source folder create middleware.d DS make sure to not misspell this middleware.ds it's a reserved file name we import clerk middleware from clerk next.js server and we export default clerk middleware middleware and we add a matcher so uh we target all of these files here excellent so now that we have this let's go ahead and let's add the clerk provider to our layout so I'm just going to import clerk provider to our root layout so app folder layout let's go ahead and import clerk provider from add clerk next.js and I'm going to wrap the entire application inside of a clerk provider yes make sure you wrap your TRPC React provider inside of clerk provider as well like that so let me just confirm that I use the correct package and just confirm that they've done this as well perfect and now let's go ahead and let's do npm rundev here you don't need to start your uh ingest right now because we will be doing some other things so what I did is I went to the end here and I clicked on next steps utilize your own pages for authentication the account portal is the fastest way to add authentication so let's click continue to the next GS guide and the first thing we're going to do is we're going to add this uh sign in pages so let's go ahead and do that i'm going to go inside of source app home here and now I'm going to create a new folder called sign in and then inside I will create another folder which will use the catch all route sign in like this it needs to be exactly like this and then page.dsx inside and now let's go ahead and let's import sign in from clerk nextjs and let's do a page export here with a div which will have a class name of flex flex column maximum width of 3 excel mx out and width pool and then let's add a section which includes a class name space Y 6 padding top of 16 VH and to Excel padding top of 48 inside of this section add a div with a class name flex flex column items center and inside of here render sign in whoops sign in like this and once you've added this you can go ahead and copy this and you can add sign up here like so and then change this to be sign up as well go inside of the sign up page and replace sign in import with sign up import and then let's go ahead and do the following so we're going to set this to be public route so we are going to go inside of our middleware.ts we're going to import create route matcher right here and we're going to define a constant is public route using create route matcher and we are going to target sign in and then we're going to change this expert default clerk middleware to include an arrow function which checks if the current request is not a public route and then it will redirect to the protect page and then what we have to do is we have to modify our environment variables so let's go ahead and go inside of environment variables here and let's add that next public clerk signin URL is forward slash signin and the fallbacks will be an empty forward slash so next public clerk sign in fallback redirect and next clerk sign up fall back redirect urls perfect and now I think that already you should be able to see this if you go to localhost 3000 I think you should immediately be redirected to this page right and if you try to visit any other page like try to visit some older project like projects 1 2 3 you get immediately redirected back to the signin page so all pages are now protected we are of course going to slightly modify this by going inside of the middleware and let's modify this array of public routes to also include a forward slash and I like to use these types of quotes and we also uh actually yeah I think this uh we also need forward slap API inest like this so make sure you add this otherwise background jobs will not be able to work so we need to allow inest to be contacted great so once you've done this you should now be able to visit the localhost 3000 page there we go you can see that now we can visit this but we still can't visit the individual project page so uh and yes I am in dark mode you might be in light mode it doesn't matter so now let's go ahead and do the same thing that we did let me just go here the same thing that we just did for sign in we are now going to do to the sign up page so we just did this so we don't have to do it i told you like already that you can just copy the sign in and do it right here but what we need to do is we need to add sign up to the list of our public routes so let's see did we do that or not we didn't so let's add it there we go so sign up is now added to the list the same as sign in and then we also need to add all the environment variables here so let's go inside of environment here and let's just add some so next clerk next public clerk sign up URL and the redirect URLs for sign up fallback and sign in fallback and looks like these are duplicates so yeah I think you only need one of these and one of these so yeah you can do remove these two and just move these two there we go at least I think that they were duplicates right i think they were uh and now you should be able to go uh manually you can just enter any other route try going to projects one to three you will be redirected and if you click sign up you should be taken on the same layout as you can see it loads the sign up page so now you can switch between the two perfect uh so now what I want to do before we even log in I want to go back to localhost 3000 here and I want to create a navbar so let's go inside of our home module so that's going to be inside of source modules home UI components and in here go ahead and create navbar esx let's go ahead and mark this as use client and let's import link from next link let's import image from next image let's import all of these from clerk next.js signed in signed out sign in button and sign up button and then let's import button from components UI button let's export con navbar here and let's return a nav element give this nav element a class name of padding 4 background color transparent fixed top zero left zero right zero zindex of 50 transition all duration 200 border bottom and border transparent inside of this div uh nav add a div with a class name of maximum width 5 xl mxal width full flex justify between and items center add a link inside with an href to a forward slash with a class name of flex item center and gap of two and in here render an image with a source of logo SVG out of vibe width of 24 and height of 24 as well add a span with a text vibe inside add a class name font semibold and text large like that and let's go ahead and let's go inside of our layout in app folder home layout and let's render it just so we can start seeing some results so navbar from modules home UI components navbar and you should now see the vibe right here at the top and the fun fact it should also appear if you go into out screens as well as you can see so now you can always use it to quickly go back so now let's continue developing the navbar here the first thing we're going to add after the link is we're going to add signed out state like this and then inside add a div with a class name flex gap 2 and add sign up button and add a normal button inside with a variant of outline and a size of small and render sign up inside you can copy this and then change this to sign in button this one will say sign in and this one won't have the outline variant it will just have a size small so there we go now you have sign up and sign in buttons that you can access only if you're logged out of course and then if you are signed in let's just add a paragraph to do user control and now we should be ready to log in so I'm going to click sign in here and I'm going to continue with Google and once you confirm your Google login you will be redirected back here and you should be redirected on the landing page with the text to-do user control like that and you can see how now we can also load these apps so the reason they previously weren't even loading uh is because in the middleware we didn't allow the TRPC to be a public route so in my case I'm not going to have any public TRPC procedures but if you want to you can also add TRPC here like this let's just fix this TRPC and then if you well you can't log out now so let's just create a component to log out now and then I will demonstrate this it's completely fine to add this here because we are going to protect TRPC routes based on their procedure type as well because right now if you wanted to have any public API routes they don't exist we prevent any anything other than this to be a public route uh also you can create the exact opposite right you can call this is private route and then all of these will be private routes right and then you would just modify your logic you would remove the exclamation point and you would do this so if you have the majority of the public routes and minority of the private ones you can just reverse the logic of the clerk middleware that's the cool thing about this it doesn't have to right we just called this is public route we could have called it anything and we could just put private routes inside and then use the reverse logic here right it's not like you need to add the public ones here so this is especially useful if you have a bunch of public routes then just do the reverse logic you know great now let's add the user control uh component so I'm going to go ahead and close everything i'm going to go inside of source components and I will create user control dsx i will mark this as use client and I'm going to import user button component here I will export const user control and I will create an interface props here to show name which is an optional boolean and in here I will add the props and show name then in here I'm going to return the user button component which is a self-closing tag and I will modify well first I will pass the show name prop and then I'm going to modify the appearance prop to include the elements and then get the user button box to be rounded medium with an exclamation point at the end which basically means important user button avatar box rounded medium with size eight eight and user button trigger rounded medium like so so I don't have to type this any every time I have uh created it in a component like this so now let's go back inside of our navbar and inside of signed in render user control and pass in show name prop so just make sure you have imported user control and there we go uh and in here you now have this uh name which is barely visible because I'm in dark mode don't worry we're going to fix that as well but from here you can access your entire account your security uh all of those things and you can also sign out from here and you can see that now since I enabled inside of my middleware TRPC I can fetch them right but if I remove this and refresh I'm not able to fetch them because all the network requests for TRPC are failing as you can see all of them are failing but we will protect our TRPC routes in a different way so it's completely okay in my opinion to allow this in fact you can even just allow your entire API like this then you don't have to worry about injust or DRPC specifically because our API should uh it should be protected in a different way in the first place let's just do a sanity check what do we have here we have ingest and we have uh TRPC so inest needs to be publicly available simply because inest will contact this no one else right and if you're wondering how this works they probably have some kind of uh security header which is checked every time you access this route because you can see that we're using the serve from ingest next so inside of here they probably have their own request handler that does all the security features inside and as for TRPC uh well we are going to be the ones who are going to have to protect each individual route here and that's what we are going to do with the protected procedure so I would actually recommend allowing all API endpoints to be public routes so now let's go ahead and let's uh create the dark mode for this because you can see that when I log in of course it just looks weird so what we're going to do is we're going to go and create a hooks folder so go inside of source uh do we we already have hooks great so this came with chats and UI and now create use current theme.ts so we already have use theme from next themes and we already use it in the project header use theme the problem with this is that it has uh the following possible values it can be system dark or light which is fine for this radio group but if the value is system what exactly is that is it light or is it dark we don't know that's why we have to create a custom use current theme here where we can extract the theme and system theme specifically use theme like that and then if theme is dark or if theme is light we can just return the theme as usual otherwise return the system theme like that because you you cannot always just return the system theme this only makes sense if the theme is system right if it's dark or light then we don't care we can just return whatever the value is but if it is something other than dark or light it means it is system so then we cannot return theme we have to return the actual value of the system theme and now we can go inside of the user control right here and we can adapt it as follow const current theme use current theme like this and then inside of here uh let's also import i think we need to install a package first so let's just do npm install at clerk forward slash themes and I'm going to show you my package json here 2.2.51 is my version and then from that package you can now import dark from clerk themes and then very simply in the appearance here set the base theme to check if current theme is equal to dark use dark otherwise use undefined and now you can see the text is visible and this is now in dark mode so you might be thinking could I have just added that to the clerk provider because clerk provider also allows for the appearance and base theme well you can but the problem is the theme provider for SHAT CN needs to be inside of the body and clerk provider needs to be outside of the HTML so we kind of have a conflicting situation here right um you can try moving both the clerk provider and TRPC react provider here maybe but I'm not sure how that works right uh I'm not sure if it matters but uh from all the documentation I've seen these two need to be outside of HTML i'm not sure I could be wrong but basically if you are able to move these two like this inside then you can create an abstraction around cleric provider and then you can do the same thing like this but for now I'm going to leave it like this simply because this is what worked for me initially great so we now have this in the user control and we can now go inside of sign in and do the same thing because right now if I sign out and if I go here you can see that this uses light mode so let's go inside of sign in page right here let's go ahead and mark this as use client and let's import use current theme from hooks use current theme which we just created and let's import dark from clerk themes now in here we can extract the current theme and for this sign in let's add appearance here base theme we'll check if current theme is equal to dark and use dark otherwise use undefined and let's also modify the elements a bit by adding card box here do not have any border not have any shadow and be rounded for LG like this and there we go you can see how now this is in dark mode and when you click on sign up you can see it still uses the old theme so let's just go ahead we can just copy the entire file go inside of sign up paste the entire thing and replace the import to be sign up i think that's faster and there we go now both of our sign in and sign ups have the proper team great so let's see where we are what did we do we created a clerk account we updated updated our environment we added clerk provider signup screens middleware perfect we added home layout in the navbar we created the user control component now let's create protected tRPC procedures and let's update the Prisma schema so I just want to do one more thing with the user control component and that is inside of the project view so go inside of this component here and in here after the tabs list here we added this ML auto flex and this button to upgrade now next to it also add user control like this and don't add the prop show name so just make sure that you imported user control and let me show you how that will look like now so now if you of course sign in so let me just enter an account here and let me just go to uh any random project here you can see that I have my user button right here and let me just switch to light mode to see everything still works fine there we go you can see that now I can log out and access my account information from here as well and let's just double check the light mode to see everything works fine everything works just great perfect so now what we have to do is we have to create the protected TRPC procedures so in order to do that let's go inside of source tRPC and let's go inside of init and now in here we're going to modify the TRPC context here so what I'm going to do is I'm going to remove this comment and I will return al to be await out from clerk next.js server after that I mean just below it I'm going to export type context which uses awaited return type type of off create trpc context and you can actually find these exact instructions in clerk documentation here let me just find tRC maybe I can find it integrate clerk into your next.js plus tRPC app let me see if that is uh what I'm looking for here let's try again trpc I think this might be it so yes you can see that they instruct you to wrap the clerk provider around the TRPC provider so we already did that right we are using TRPC React provider simply because the documentation has changed since then but it's the same thing it's important that the clerk provider is wrapping around the TRPC provider and now in here we are basically doing this in the create context and we are creating the context type here like that and in here you can find all the other things that we are going to do uh for example they have a specific instruction to now add create context to this TRPC route but if you look at the TRPC route we already do that right so you don't have to worry about that you can just follow what I do now so I'm going to go after this T initialization and I will do const is outped like so and I will do T dot middleware and from here the structure next and context and check if not context out user ID in that case throw new TRPC error code uh let me just see what exactly is the problem in this one oh so I need to import TRPC error from TRPC server okay make sure you do this then let's do unauthorized here with a message of not authenticated like that nothing uh and then after this if clause return next and extend the context to include out now we have to fix this problems that out doesn't exist you can do that quite easily by going back to this t here and simply add dot context add the context type and execute it and you can see that now we have the al property here which we added here perfect and it's important that we also cache this in React so this doesn't need to be called every single time and we are simply relying on the user ID from it here so make sure you don't do any mistakes here because now we're finally going to go ahead down here and do export const protected procedure to be t.procedure whoops t.procedure is authored there we go now we have our protected procedure so now it's time to replace a lot of our previous uh well procedures with this new one so thankfully we don't have too many modules so let's start with the messages procedures here let's see at first we have get many instead of base procedure what you can do is honestly I don't think there will be a single public procedure here so what I like to do is I like to highlight base procedure and then I press command D or control D and then this just selects all of the other ones right so 1 2 3 and I can remove them and I can add protected procedure like this and nothing really changes now so I'm just now using protected procedure for each of these for get many for create and I think that's that's the only two instances and you might think but nothing really changed now that's right but look at this if I'm using so just for example I will bring back base procedure here for the get many I'm now using base procedure if I try to extract context from here and if I try to do uh let's for example imagine that we can query the messages by user ID imagine if I do user ID here and do context and then I try to do you know user ID in here it can tell me that the user ID is string or null so that means what I have to do is I have to first check if there is no context.out user ID and then I have to throw new tRPC error blah blah blah but that makes no sense we just created the protected procedure which does that for us and then uh passes the context further so instead what we do when we know that something has to be a protected procedure that we will always throw an error if the user ID is missing we can now just use the protected procedure and this time the user ID is a type of string see the difference base procedure tells me it can be string or it can be null but protected procedure tells me this is definitely a string because it 100% exists at this point so that's why we're replacing things with a protected procedure and then at this point it doesn't matter that our API is allowing the public route for API right an important thing you should know you should never never ever ever rely on the middleware for authentication so what I'm doing here is just a nice user experience right it is easy to redirect the user using the middleware but this isn't my line of defense this isn't what I'm doing to throw errors that's why I have a data access layer called TRPC and in here I have my protected procedures so if this middleware fails even even in this case I explicitly allow the middleware to allow API routes i'm still very much protected because I'm protecting my data access layer and you should do the same never ever rely on the middleware to protect your app if you want to use the middleware for nice user experience like we are of course you can do that but it shouldn't be your last line of defense you should have a data access layer and you should protect your routes individually because let's imagine this middleware breaks which can happen nex.js had a middleware security issue just a few versions ago and people who were shocked that that happened know got a very big security lesson you shouldn't rely on the middleware even if the middleware was perfect you should not rely on it uh don't confuse this middleware with this is also technically a middleware right we we just created a middleware this middleware and this middleware are two different things they are not comparable okay what I'm trying to tell you is don't try and do API and then projects and then create don't do this this is not enough for you to protect your API routes you should protect your API routes inside of the routes themselves like I am doing right now so this is a different type of middleware they're just using the same word they're using the same keyword middleware here and middleware here right i'm trying to explain the difference so whenever you use the middleware it should only be used to improve user experience like adding redirects which is very a very nice thing to use the middleware for but if your middleware breaks and if the user actually ends up being able to visit my individual project page I'm still just going to throw a bunch of errors because when we try to load the messages it will be a protected procedure and it will just throw the user an error saying "Hey you're not authorized i don't know how you access this API but you cannot see that API." That's how authorization should work not by the middleware the middleware is just the first layer of security the actual layer of security is the data access layer in our case the RPC i hoped I cleared that up sorry for going on this rant but it is important for you to understand that great so now let's go ahead and once we finish the messages let's go inside of projects server procedures and I think that we have to do the very same thing here i don't see a single thing that can be a base procedure here so I'm just going to replace All of these instances I think this is the last one yes with protected procedure so let me show you the exact changes get one get many and create so three procedures in this case and when I search for base procedure now not a single one exists except the actual instance here in the init file and when I search for protected procedure I have eight results in three files the third one being in it file so that's how your project should look as well so now only authorized users can access this API routes and it absolutely doesn't matter that we are not protecting it in the middleware perfect so now let's go ahead and let's add Prisma schema update because now we finally have the user ID so that means we can go inside of Prisma schema here and we can modify some things so let's start with the project the project from now on will have a user ID which will be a required string like this and since other entities relating to the project all other entities end up being related to the root project we don't really have to add it to the message as well you can of course do that if you want to uh if you have any architectural reason for doing that of course you can add individual user ID for the fragment individual user ID uh for the message right but for the same reason I'm not adding project ID into the fragment because the fragment is related to the message which has the project ID already i'm not going to be adding the user ID uh to my uh other entities because it is enough that the user ID is in the project and once I've done that I'm going to shut down my app and I'm going to do npx prisma migrate reset so again only do this in development we are clearing up our database because we are in development and we can do that and once we've done this let's go ahead and do npx prisma migrate dev and once it connects let's simply call this user ID or out here we go i'm going to call this user ID and there we go now I'm going to do npm rundev and I'm going to run npx inest cli latest dev so both things should be running and just double check that it was able to connect to API inest because as I said if you accidentally don't allow your API here then inest will not be able to connect there we go you can see that now it's 404 so that's wrong that's why you need to make sure to allow all of your API routes and then after some time let's check again it can connect to it exactly what we need so now let's go ahead and fix all of the issues that we have because we do have them we just got a new rule and that is that each project needs to have a user ID so let's go ahead inside of our modules and let's go inside of projects server procedures and we can already see some errors here such as the create error so in the create protected procedure we now have to also pass the user ID which we can easily extract from the context here because we are using a protected procedure so context.out user id as simple as that problem fixed now what we have to do next is you also have to modify the get many so whose projects are we loading very simple the currently logged in users projects so let's add a wear here like this user ID matches context out user ID and now we are only loading this currently logged in users project and same thing for get one simply extract context from here and we can only load the existing project if we have a matching user ID if we don't this will be null and we're going to throw the error not found so even if the user is logged in and manages to surpass this protected procedure we will still be able to throw the error because we have no idea which project with that specific ID and that user ID they are looking for so we just throw we have no idea what you're talking about we've never seen that project before so full security in our application and now we have to do the same thing but for messages so let's go inside of procedures here and let's check get many so in here I'm going to extract the context as well and I'm going to try and do project user ID and it seems like I can do that so let's simply add context out user ID there we go so just like that we are now also protecting all of our messages but since we don't have direct user ID in the message we have to go through the project ID first perfect and for the create uh well we have to do the same thing but a little bit differently here so what we're going to do here is we're going to do con existing project first await prisma project find unique where and simply add the ID to be input project ID and user ID to be context pal user ID like this i mean maybe we can somehow do it from here i don't know i'm not that good with Prisma but you can do it in two separate queries you know it's not the end of the world and if there is no existing project let's throw new TRPC error here code not found with a message project not found so I have no idea what where what project do you want to create this message into right and make sure you have imported the TRPC error from TRPC server so this way even if they somehow surpass the protected procedure we are still not going to allow them to just create messages in someone else's project because they need to match the exact user ID who created that project uh great so we now have this done right here and then we can safely do the created message you can even then use maybe it's even safer to use existing project ID for the project ID so it's only this one which we can query from our database with the correct user ID that we're going to insert this message into excellent and you don't have to worry about these background jobs because we are protecting them before we even trigger them so that is for the create method let's see did I fix it for the get many and I think that should be it so obviously we should now just test our app to make sure things are still working uh so let's go ahead and do the following let's go inside of our projects list now and I just want to do a slight modification here and that modification is that I'm going to load the current user from use user which you can import from clerk next.js and then this will allow us to do the following we can then do user question mark first name and then apostrophes users vibes and then in here also do if there is no user return null so we don't even load the project list if we are not logged in we can of course do this in a million ways but I think this is just simple enough for now uh great so you can see that when I am logged out nothing happens here great so what I want to do first is I want to go inside of my project form and in here in my on success specifically on error I should redirect the user to the out screen as well if this fails because right now when I type test I'm just getting an error not authenticated i mean you could technically argue that's good enough but uh let me show you what you can do so you can do router and then you can just push the user to sign up or sign in that's an easy way you can do but here's a cool thing you can actually do con clerk use clerk from clerk.js so just make sure to add this import and once you have it you can do the following if error data.code is equal to unauthorized you can do clerk.open sign in like that uh and let me just so error data is possibly undefined so maybe I need to do this there we go and let me just move this to the top so this way if this fails it will open the signin model so I write test and there we go it opens this nice model i think it looks cool if you want to you can also just do you know router.push sign in that also works there we go so whichever one you prefer i just thought I would show you this cool alternative uh great so I'm pretty sure that we don't have to do anything more besides test the app so now I'm going to log in here and as you can see it says Jones Vibes and no projects found and I will do build a landing page here and let's see will I get any errors i don't think I'm getting any errors at all i do want to just check my functions.ts just to confirm I'm not getting any errors in here even though we shouldn't be getting any errors at all this is a background job this doesn't need any user ID i think everything is just fine here and I think that we will be able to normally load the messages but let's wait and see the result and there we go once I am logged in you can see that I can normally create my messages i can even refresh this and I can load my messages i can see my fragments so all of this is obviously working perfect uh and let's try something fun i'm going to copy the URL here and I will log out and then I'm going to go ahead and paste that URL so obviously I'm getting redirected but let's say inside of my middleware I accidentally do projects and I do this all right so let's see what happens then you can see that even if the middleware fails nothing useful is shown to the user and finally an error is thrown this is of course not ideal because we are missing an error boundary uh we're going to fix this details in the last chapters right obviously it's not ideal that this types of errors shown even though this wouldn't show in production this is what you would see in production which is not any better but we will I'm going to show you how to add proper error boundaries i just wanted to show you that you can't fool this system we just created right you will either get redirected or you will be hit with a bunch of errors because you don't belong on that website amazing amazing job i think that officially marks the end of this chapter so now let's go ahead and let's open a pull request so 16 authentication i'm going to create a new branch 16 authentication i'm going to stage all of my changes 16 authentication i'm going to commit and I'm going to publish the branch now let's go ahead and open a pull request and let's review our changes and here we have the summary we added user authentication and theming support using clerk including sign in and sign up pages with theme aare styling we introduced a navigation bar with authentication controls and user display we added a user control component for displaying user information and actions we integrated authentication checks into project and message features ensuring users can only access their own data we improved project and message lists to only display personalized content and enforce userbased access exactly what we did in this chapter as always file by file walk through here and a whole sequence diagram explaining how our new clerk provider and authentication TRPC procedures work and we did a very good job this time the only comment is in the migration SQL um we don't really care about this because we are in development phase and no other comments amazing amazing job let's go ahead and merge this pull request and once we've done that let's go ahead and go back to the main branch and let's click on synchronize changes and okay and in a few seconds you will see that 16 was just merged authentication that marks the end of this chapter amazing amazing job and see you in the next one in this chapter we're going to implement billing and the credit system into our project in order to do that we first have to enable billing in clerk we then have to create a pricing page after we've done those two we can start and add rate limiting or usage or credit system in our application this will include adding some new models to Prisma schema and creating the util for rate limiting after that we're going to have to create the usage component which will show to the user how many credits they have and finally we're going to have to update some procedures to actually call this util for rate limiting to trigger credit spend so let's start with enabling billing so this is the first time I'm using clerk billing it was announced recently and the moment I heard it I just knew it had to be an incredible developer experience and I think that you will be shocked at how good it is because we all know that Clerk's developer experience is immaculate they have completely solved the issue of uh complicated code everything regarding Clerk is super easy super fast and super simple to do and billing is one of the most complicated parts of building the authentication especially if we are doing it with Stripe so you're going to be so impressed by the fact that we won't even need a web hook for this entire process more so we won't even have to build a single component besides our custom usage component which actually has nothing to do with billing let's go ahead and do that you can find information about clerk billing in their documentation here you can scroll and find billing and in here you can select B2C you can also do B2B but in this case it will be uh B2C SAS the first thing we have to do is enable billing so we have to go to billing settings this will redirect you to your project so you click into configure and down here billing settings go ahead and click create a plan and the first thing we're going to do is we're going to create a free plan so I'm going to go ahead and open this and in here you can set the name of the plan and you can set the slug like this so this is what we are going to use in our codebase to check if the user is on that plan right so we're going to check if free user is active that means the user is currently on the free tier uh and in here make sure to check publicly available this basically means that this will appear on the pricing table so you can create that and then you can click add another user plan and for example call this pro like this and give it a monthly fee of $29 and if you're wondering can I easily combine this into an annual discount yes you can just enable annual discount and in here set it to something like 25 so if they pay monthly it's going to be $29 a month but if they choose to pay annually we're going to reduce the price to $25 per month so you're going to get $300 instantly from them and in return they're going to have a bit of a cheaper plan you can of course uh assign the price to whatever you want and click save so right now in your subscription plans whoops right here you should have two subscription plans one free and one pro which is build monthly or annually so in here let me just go and click on the settings here and in here let's just click enable billing there we go so now billing is enabled and in here you can choose your payment getaway so if you want to you can add your own Stripe account but you can also choose clerk's payment getaway which is a zero conflict payment getaway it is ready to process and test payments immediately and this is amazing you're going to see how simple this is so to recap go inside of configure go inside of billing settings and make sure that you click enable make sure that you have a message billing is enabled after that go ahead and create two subscription plans right here and now let's go ahead and let's add a pricing table to our app so as always make sure that you are on your main branch make sure that you synchronize your changes and if you want to go inside of source control and confirm that the last change was adding authentication what we have to do now is we have to implement the pricing page so let's go inside of source app home and let's create a new folder called pricing inside page.tsx tsx like this let's mark this as use client and then let's go ahead and let's import image from next image and let's import pricing table from clerk next.js and let's go ahead and export this page so I'm going to export it like this and inside of here for now let's just do pricing table let's just do that and nothing more if you now go into your app just make sure you have it running and if you go to forward slashpricing uh it will redirect you to the login page so let's just make sure to add that here so forward slpricing like so now you should be able to go to localhost 3000 pricing there we go we have a date a pricing table so we didn't have to code a single component all we have to do is style it a little bit now so let's go ahead and do that so I'm going to go back inside of here and I'm going to add a class name flex flex column maximum width of 3 Excel MX auto and full width i will then add a section around our pricing table and I'm going to create a div inside of here with an image component and then in here I will add an H1 element and then I'm going to add a paragraph now let's go ahead and style this starting with the section which will have space Y 6 padding top of 16 VH on to Excel padding top of 48 then on this div encapsulating the image let's give it a class name of flex flex column and items center for the image itself give it a source logo SVG alt vibe width 50 and height 50 as well and give it a class name hidden MD block then in the H1 go ahead and add the text pricing and give this a class name of text extra large like this on MD text 3 Excel font bold and text center for the paragraph enter the text choose the plan that fits your needs and give this a class name text muted foreground text center text small and MD text base and now let's just go to the pricing table appearance and let's add elements here pricing table card and let's change this to use the border shadow none rounded large just just make sure you're putting the exclamation points here and just like that we have a pricing table that clearly reflects the two plans that we created in clerk dashboard so now let's go ahead and let's modify the descriptions of these and let's show some features which will be active once we upgrade so let's go inside of our clerk dashboard here go inside of configure and in here subscription plans select the free one and let's go ahead and give it a description for getting started like this and click save and then in here let's add a feature and let's go ahead and call this feature five monthly credits like that make sure it's publicly available and let's click create feature and let's click save and just by doing that and refreshing you will immediately see the new description reflected here and you will also see the new feature five monthly credits and now if you wanted to this is where you will add even more features for example public projects something like that so for example we don't even have private or public projects all projects are private in our case but for example here you can see how that would look like and now let's go ahead and let's modify the other plan which is the pro plan so go back here back inside of our subscription plans and select the pro plan so this one can have the description of for more projects and usage and then go inside of the features here and let's go ahead and add a new feature called 100 credits per month like this let's go ahead and let's add private projects like that let's add custom domains basically whatever you plan to you know extend this application with you can add here or maybe some collaboration like three editors per project all right just think of a bunch of features you would add to your app and let's do uh remove the vibe badge imagine that we would create some kind of feature that adds the vibe badge and click save and you can of course you know drag and drop this however you like i just wanted us to add a lot of features here simply because the the pricing table looks better if you add more features here and I absolutely love how this looks so now that we have uh this finished let me just go ahead and do one thing i want to go inside of layout right here and I want to modify the clerk provider and its appearance here and I want to add variables here color primary and I'm just going to set it to the light mode of our cloud theme which is this and when you save this you can see that immediately it will pick up the theme that we are using throughout the project and I just think this looks amazing now let's just go back to the pricing here and let's enable dark mode if we need it so I'm going to import dark from Clark themes and I'm going to import use current theme make sure this is marked as use client go ahead and add this and then simply in the appearance go ahead and add base theme checking if the current theme is dark then use dark otherwise it's undefined and now this page will support dark mode as well uh and if you try and subscribe you can see that you're redirected to login so you don't have to immediately uh try and subscribe simply because I want to demonstrate the entire upgrade process you can see that when I log in by default every user is in the free tier you didn't even have to write the code for that you automatically we automatically added this user to the free tier if you click subscribe here you can see how nicely this looks as I said you don't have to do this now if you can fine sure but you're going to have to create a new account to test out our usage uh tryyouts so you can see how this looks i think it's just you know amazing uh and one thing that I want to fix that we forgot about is when I scroll I want this navbar to stop being transparent because it just looks weird so let's quickly fix that by going inside of source hooks and let's create use scroll.ts like this and inside of here let's go ahead and do import use state use effect from React export const use scroll and let's add the threshold to be 10 define the state is scrolled and set is scrolled use state by default is going to be false call use effect with for now an empty dependency array like this and inside create a handle scroll arrow function which will call set is scrolled to be window scroll Y which is above the threshold and then let's add a window add event listener here to listen for scroll and handle scroll and then simply call handle scroll and in the return method call window remove event listener scroll handle scroll just like that and add the threshold inside and all you have to do is return is scrolled there we go so now that we have use scroll in our app we can go back to the navbar inside of home module UI components navbar and in here you can now easily get is scrolled use is scrolled use scroll my apologies from hooks use scroll and then make this a dynamic class name by wrapping it inside of curly brackets and adding the CN util so we have to import CN from lib utils i'm going to keep the static classes as the first argument and then I'm going to check if is scrolled let's do back bg background and border border so now if you scroll ever so slightly you can see that the navbar starts to stop being transparent and a border appears amazing now that we have this and now that we have the billing let's go ahead and just check a couple of things so now this upgrade button should take you to the pricing if yours doesn't make sure you check the project view here and make sure that you have a button let me just find it here it is button with a link redirecting to pricing like that and now it's time to create the usage model so in order to do that we're going to have to install a package called rate liimiter flexible so let me just close this and this and let me do npm install rate limiter flexible like this let me show you the version so I'm using 7.1.1 that's my version let me do npm rundev and then in here I'm going to go ahead and do the following inside of Prisma schema I'm going to create uh a new model called usage right here at the bottom model usage let's go ahead and give it a key which will be a type of string and that's going to be the ID and then a points which will be integer and finally expire which will be an optional date time so this will be my usage model now let's go ahead and let's do npx prisma migrate dev we don't need to clear our database because this is not really conflicting with any other models we're just adding a new one so I'm going to call this migration usage let's go ahead and add the name usage and there we go now that we have the new usage model here and the new migration ready let's go ahead and let's implement uh the usage tracker so this is what I'm going to do i'm going to go ahead and create a new lib that I'm going to call usage.ts ts and inside of here I'm going to go ahead and add an import for the rate limiter so specifically it's going to be rate limiter Prisma right here and let's go ahead and do export async function get usage tracker like this and for now I'm just going to define const usage tracker to be new rate limiter Prisma store client will be our Prisma from the database like this and table name will be usage so just make sure it matches exactly the model we named here and for the points let's go ahead and by default uh give everyone five points and for the duration let's go ahead and let's do 30 days so 30 * 24 * 60 * 60 now what I like to do is I like to do const free points and let's go ahead and give everyone free points so you can replace this like so then let's do the cons duration to be 30 * 24 * 60 * 60 so you can add a little comment 30 days for example and now that we have this let's just return the usage tracker and now let's go ahead and let's create a function called consume credits so export async function consume credits and in here let's go ahead first uh and let's extract user ID to be await out from clerk next.js server like so and make sure to execute this if there is no user ID we can throw new error here user not authenticated that's the first thing and then let's go ahead and do const usage tracker to be await usage tracker basically this function which we defined above and then in here const result to be await usage tracker dot consume pass in the user ID and then how many points do we want to take from them so for that I'm going to define const generation cost cost to be one so let's go ahead and add that here so we're going to subtract one point from the user every time we consume credits and then let's just return result and then let's create the last function export asynchronous function get usage status again extract user ID from await out if there is no user ID throw new error user not authenticated and then let's do const usage tracker here to be await get usage tracker and then result will be await usage tracker dot get user id so we are looking at how many points we have left there we go so we are basically using this very very cool library which can inject directly into Prisma uh and I'm just going to open the documentation now for it so you can read more so here it is node rate limiter flexible basically node limiter flexible counts and limits the number of actions by key and protects from DDOS and brute force attacks at any scale it works with W key radius prisma dynamo process memory cluster pm2 memach myql sqlite and posgress also works in the browser it offers atomic increments all operations are in memory or distributed environment use atomic increments against race conditions so if that's something you were wondering about yes we solved the problem of race conditions by using this package it is extremely fast it is flexible ready for growth and it is friendly now should it be used exactly the way I'm using it right i'm using it as a simple rate limiting for premium credits i haven't really seen any advice not to do it but since it solves uh a bunch of problems out of the box and it's just an npm package I thought it was a no-brainer to use it uh given the fact that we can easily add it to Prisma right so that's why I chose this package uh I explored a bit what we should use should we develop our own and this ended up being the best decision great so now that we have these three functions a functions to get the usage status by the current user ID key a function to consume credits for the current user and the overall function to get the usage tracker which right now doesn't make too much sense this could have been a constant but don't worry it will make sense later so now let's go ahead and let's actually create the procedure for the rate limiting here so I'm going to go ahead and go inside of source i will create a new module called usage and in here I'm going to create server and then I'm going to create procedures.ts let's go ahead and do get usage status from lib usage let's import create trpc router from trpc init and protected procedure then let's go ahead and export constage router to be create trpc router status is going to be protected procedure query asynchronous method and then in here let's open a try and catch block return null in the catch block and in the try attempt to get the result from await get usage status and return the As simple as that so we we don't really worry about catching these errors and displaying something since this is a query right so once you've done this go ahead and add that to your TRPC routers here so usage usage router there we go and yes if you want to you can move everything usage related into this module perhaps you can move it out of the usage um for now I will leave it here but yeah if you want to you can create a lib here i think it will make more sense actually uh okay now that we have this let's go ahead and let's create the usage component so this one will be interesting let's go inside of source modules projects UI components and let's create usage.tsx so in here I want to create an interface props which accepts the points and milliseconds before next refresh and for the imports let's go ahead and let's import link from next link let's go ahead and let's import the crown icon from lucid react and let's import format duration and interval to duration from date fns and finally the button from components UI button now in here let's go ahead and let's add the usage like so let's return a div with a class name rounded top extra large bg background border border bottom zero adding 2.5 another div inside with a class name flex items center and gap x of two in here a div which will have one more div inside and this inner deal div div will have a class name of text small and let's go ahead and simply render the number of points that we have and then let's just say you have that many free credits remaining and you can change this into a paragraph so we don't use so many divs and then after that add another paragraph with a class name of text extra small and text muted foreground and inside resets in then add a space like this open curly brackets format duration inside of it interval to duration and set the start to be new date and set the end to be new date and inside date dot now plus milliseconds before next and then add a new prop here I mean a new param in this interval to duration uh my apologies format duration function which takes the format to be months days and hours so it's going to display in those intervals and I think that's it i think that's all we need and then outside of this div right here go ahead and add a button and a link inside the link will have an href to the pricing page we're going to render a crown icon and text upgrade the button will have an as child size small variant will be the new one that we created tertiary I I guess class name ML auto now that we have this let's go ahead and display the usage prop in order to display it we have to go inside of our messages form component so it is inside of projects UI components message form and then let's go ahead above this and let's do show usage and end and then render the usage like so import the usage from dot / usage passing the points to be zero and milliseconds before next to be zero just make sure you have imported the usage component so now go into any random project that you have so I'm going to go ahead and go inside of this one that I already have and once this loads nothing changes but if I go inside of the message form and if I change the show usage to true and if I refresh you will see zero free credits remaining resets in nothing and we have a button to upgrade that's what I wanted to see and now what we're going to do is we're actually going to fetch the usage from our new router so let's go ahead to the top here and before the form let's do const data usage to be use query which you can import from let me just find tanstack react query here it is and in here pass TRPC usage status like this query options and once you have the usage let's go ahead and define the show usage to be double exclamation point and then usage and then in here you're going to do if you pass the points to be usage remaining points and in here usage milliseconds before next and now let's refresh and it looks like it does not exist yet i think that is because yes so it's not going to exist right now because in order for this to be written to the database let me just start npx Prisma studio so you can see what I'm talking about we have this new model called usage right now we have the fields key points and expire but nothing exists here it will not be created by itself it will be created after the very first consume credits function is called so the first time we do dot consume and take some points that's when it's going to be stored in the database so let's go ahead and let's do that so the first one we can do it for is the messages procedures so let's go inside of messages server procedures and in the create here let's go ahead and do that so before we even create the message here let's go ahead and let's do await and let's call consume credits like so and now this will already work but I want to do I want to just wrap this into try and catch because get usage uh usage.conume will have an error object right because there is an error that we have to catch and that is the error which says you have no more points so we have to catch that here so let's do it by wrapping this inside of try like so and then open catch and let's get the error and the first thing we're going to do is we're going to check if error is actually an instance of error this is this basically means that something else happened right this doesn't mean that we hit a rate limit this just means something literally failed maybe it's the database connection right because this works by connecting to the database so maybe that failed so it would be incorrect to just throw a TRPC error saying rate limit exceeded if consume credits fail that's why in here I will throw new ERPC error here with the code bad request and a message something went wrong right so I have no idea what happened here but it's not something we expect otherwise it is so if it is not an instance of error that means this is the rate limit response so in here add a code too many requests and add a message um let's see you have no more or maybe you have run out of credits something like that basically a message indicating to the user that they have no more points and now just for fun I'm going to modify my usage here and I'm going to set uh two free points so let's go ahead and try it out now I'm going to do build a landing page something that reliably works for me and we should have done uh one thing here immediately oh yes we forgot the ingest API we forgot to do that npx inest cli whoops my bad and let me just refresh this and you can see that now when you refresh you you have one free credit remaining which resets in 29 days and 23 hours do I have my Prisma Studio running i do so if I go here now in the usage and reset once we call this consume method you can see that I have a key which is the user ID with some prefix here and I can see when this will expire and I can also see how many points I have spent so far so I only spent one point so far and basically that is how this is going to work so just for fun I will do build a landing page again and this time uh I will refresh and I will have no free credits remaining so if I try one more time I should get the error you have run out of credits and we just got that error amazing you successfully implemented usage now you probably noticed a little bit of a weird thing here uh and that is that uh we call consume credits before we even know that this succeeded so if you want to you could move this consume credits function into the background job and then only consume the credit after you successfully save the result to the database it will depend on what you want to protect right if you want to protect your resources you will most likely add this before you even call uh something like inest and you don't even want to spend any open AI credits if someone doesn't have enough credits right but if you were to pass this in the background job you would also need to pass the user ID in the event data so just be mindful of that and then you would also have to modify the consume credits overall because in here we rely on it using ALF and I'm not sure how this will work if it is invoked from a background job i just think that it will throw user not authenticated because background jobs by default are not authenticated they are like web hooks right so that's why I decided to do it in the procedure rather than in the background job what we have to do is this to-do right here so let's remove this let's add queryclient dot invalidate queriesc usage status query options like this so now when we create a new message we automatically invalidate the queries and one easy way to reset this is to just go inside of your Prisma Studio and just bring back the points for your user to be zero and click save and this way you will not have spent any points so you are now back at three credits remaining so if I go ahead and do test and send the message now it should automatically upgrade and there we go you can see now it says one so that is thanks to this invalidation here and now we can also fix this to-do here as well so if error.code error data question mark code is equal to too many requests let's go ahead and do router we don't have router so let's add it con router use router from next navigation make sure you add this import and just do router.push push forward slash pricricing like that so now when you hit too many requests it will yeah you can see this is kind of the not perfect thing if you spend your credit on a bad query we take the credit away from you and you don't get the result so yeah not exactly perfect but I think it's pretty good so far right let's go ahead and just I purposely just going to use stupid queries now just to get that error there we go so once I run out of credits I'm redirected to the pricing page perfect now there is one more place where we need to do this exact thing so I'm going to go inside of messages procedures just so I can copy the try and catch for my consume credits here and now let's go ahead and go inside of projects server procedures procedures right here and find the create right here and simply call that try catch before you create a new project and import consume credits like this and then go inside of project form component and we have to do the same thing so first things first query client invalidate queries and pass in gRPC usage status query options and then in here if error data code is too many requests do router.push/pricing there we go so now you have the exact same thing happening from here so if you try test from here same thing happens you have run out of credits and you are redirected here amazing but right now if we were to upgrade nothing would change so let's go ahead and fix that so in order to fix that we have to go inside of our usage in the lib here and then what we have to do uh is we have to get inside of here the status so has and let's do await out hon has premium access will be has plan and then pro so how do I know it's pro well because inside of the clerk configuration here the slug is pro so maybe has row axis would be better and then what I'm going to do is I'm just going to add const pro points 100 like this and then if I have has proaxis it's going to be row points otherwise it's going to be three points like that and here's a quick tip if you also want to change the duration uh which I wouldn't recommend you know there there's also if you look at all of these apps chat GPT uh claude lovable bolt replet I've noticed that not all of them have annual plans and the reason for that is it is safer for them to bill you monthly uh simply because they don't know how many credits you can spend right so that's why I recommend not changing the duration for the proaxis but even if you wanted to the way this rate limiter works is that it will not update the duration right so you can update the points in the middle of an existing uh database record for rate limit but you cannot do it for expiration just if you in case you were interested but in this case it doesn't really matter because it is safer for us business-wise to track monthly usage and do monthly billing right even if a user is on an annual plan we're just going to give them the same amount of points 100 points per month great now that we have this done uh let me just check i think this is the only place here uh where I have to do that and now let's just do a comparison so when I click on one of my projects it says zero free credits remaining i will click upgrade i will click subscribe pay with the card that's it that was clerk billing i don't know if you just saw that but that was it i can now go inside of my manage account billing and I can find that I am on this plan and from here I can see cancel subscription i can switch i can remove monthly whatever I want so I think this is insanely good and let's see if it worked so right now uh I think that there we go i have to refresh right and then it says 96 free credits remaining so we are have officially upgraded right i can now send another broken message and it works so we successfully added 100 points it seems like it has subtracted the existing points we spent during the free trial so that's something we could improve but overall it works when the user is pro we use a larger amount of points here so now what we have to do is we have to change the text this is no longer free credits this is just credits now and we can also remove all of the upgrade buttons we no longer need them so let's do that i'm going to go inside of the usage.tsx here and let's see so this is from out which means that in here we can access has from use out from clerk next.js js I have has here so I'm going to change let's go ahead and do const is has pro access has plan pro has question mark plan pro so let's check if has pro access then it's an empty string otherwise it is free so now it should just say 95 credits remaining no free credits and let's hide this button if I don't have Pro Access so only show this for users who don't have Pro Access there we go and let's do the same thing in the project view so I'm just going to copy this go inside of the project view i'm going to add it here i'm going to import use out from clerk nextjs i'm going to move it here and then if I don't have pro access I'm going to show this button right here so if I don't have pro access only then show the button and there we go now the button doesn't exist if you want to use the reverse logic if you want to create const is free tier then you would do has plan and be careful here it's not free right you always have to go inside of here inside of your plans select the plan you want and then check the slug it's free user this is the one you want that's the mistake I made when I developed so I'm just warning you but in here we used this type of logic so it's fine and I think that that might be it regarding billing it was that simple to do i'm super impressed by this no web hooks nothing i mean 90% of this chapter wasn't even adding billing it was adding usage rate limiting right so amazing amazing job i am super satisfied by this so let's go ahead and merge all of this i believe this chapter is called 17 billing and let's just mark things so we enabled billing created pricing page added rate limiting updated the Prisma schema created the util we created the usage component and we updated procedures to trigger credit spend yeah one more thing I wanted to show you if you want to you can also implement something like usage procedure and then in the middleware you could check for the uh consume status maybe that would be something fun for you to try and then you would have a more abstracted routers and procedures to work with maybe homework for you if you want to after you finish the project okay so I'm going to go ahead and I will create a new branch here 17 billing like this i'm going to stage all of my changes i'm going to add 17 billing commit here and I'm going to publish the branch just a quick reminder there's a code rabbit free extension which you can use and it will review all of your files for you now let's go ahead and let's open a pull request here and let's see the summary of our billing changes and here we have the summary we introduced a usage and credit tracking system for users with separate limits for free and pro plans we added a new pricing page with dynamic theming and a detailed pricing table we added a usage component to display remaining credits and reset time with an upgrade prompt for nonpro users navbar now dynamically changes style based on the scroll position as per the enhancements project and message creation now deducts credits and prevents actions if credits are exhausted redirecting users to the pricing page when necessary usage status is now displayed and updated in relevant forms and components the upgrade button is only shown to users without a pro plan perfect so that's exactly what we did as always an more in-depth walkthrough here and we have a sequence diagram uh explaining exactly what happens right so when user tries to submit a and create a new project or a message we call the mutation in here we call the consume credits and in here we call the database to check and update the usage and then if we have credits available we return with succeed with success and we proceed with the creation and then we simply return the creation results but if credits are exhausted we throw too many requests and we redirect the user to pricing amazing exactly what we developed and in here we also have the diagram for our get usage status method which simply reads the usage and it returns it perfect so in here we have some actionable comments this one recommends adding a default false in case has doesn't load which is actually a good advice we could do that in here it recommends wrapping this instead of try and catch and fall backs to soon so this can happen if the dates are incorrect and yeah this this might be a good idea because it's kind of u weird that the entire page fails just because the date renders incorrectly so we could actually do this in the next chapter uh so we ensure some kind of security here so it doesn't ruin the entire experience and then in the usage.ts for all of the function it recommends adding error tracking but we don't have to do that simply because we track in the TRPC so I'm going to merge this pull request i'm going to keep in mind the changes it suggested and then I'm going to change back to my main branch here and I'm going to click on the synchronize changes button and okay and then I will confirm that we just merged that right here 17 billing perfect amazing amazing job we have finished billing and see you in the next chapter in this chapter we're going to implement agent memory right now our agent and our conversations have no context the agent doesn't know the history of our conversations it doesn't understand our previous messages each message is technically a new project let's test that out as always ensure that you are on your main branch and feel free to synchronize the changes the last chapter was 17 billing make sure you have npm rundev and injust running and what I want you to do is I want you to create a very simple build a landing page the one we already did hundreds of times so go ahead and build a simple landing page and here we have a very simple landing page what if I just send it a message make it red what we would expect to happen is that it would understand that my previous message was build a landing page and it will now change it to red but the truth is that won't happen right so it didn't modify the landing page it's simply updated the page to be a red themed page if I add add a calculator there it won't understand what I mean right but what we want to is basically a landing page like this colored in red or if I tell it build a calculator in the hero segment I want a little calculator here instead of the rocket so let's go ahead and make that possible the reason we really really need this is not for continuous conversation the more important reason is AI can make mistakes you already saw that sometimes it forgot to add use client and we want to allow our users to say "Hey you made a mistake you forgot use client." Because if I just give it that right now it will have no idea what I'm talking about it has no idea that previously it created this so let's improve that let's fix that what we're going to do is the following we're going to go inside of our functions.ts and in here let's go right after we do sandbox ID and let's do const messages and let's do await step.r run get previous messages it is an asynchronous arrow function like this and then let's do con formatted messages and give it a type of message which you can import from inest agent kit so I can put type message here as well and set it to be an empty array and now let's fetch the messages using await prisma messages and let's do find many where project id is event data project id like that and let's add order by created at descending and then for con message of messages let's go ahead and push each message to this new array the reason we are doing it like this is so that we have this type which cannot be uh broken so formatted messages dot push type text ro if message ro is assistant it will be lowerase assistant otherwise lowerase user like this and the content is going to be message dot content and let me just see what uh what is the problem here formatted messages oh it should be an array of message my my apologies there we go and then let's go ahead and let's return formatted messages there we go so right now it it is going to have context of the entire conversation and it will know exactly what we told it it will know exactly what it responded back to us so now let's go ahead and let's create a const state to be create state from agent kit again so create state from inest agent kit let's give it a type of agent state so we already have agent state defined right here we have summary and files and let's go ahead and do the following the first object in here will be summary make it empty and files make them empty and then in the second object you will have messages which will be previous messages and now we have the state so now we have to add this state uh to a couple of places so let's go ahead and find our network execution right here and let's add default state to be the state from above and in the result when we run it let's add state and make it state or you can use the shorthand operator like this perfect so let's go ahead and do this again build a landing page let's do that build a landing page and let's follow the context here as you can see we now have a step get previous messages and you can now see that we included all of the new all of the older messages even the responses and the user messages here so now the code agent as you can see has messages so it knows exactly what we ask it to do now so let's go ahead and wait for this result right here we should see it any second and you can see how it preserved the red color because that's what we asked previously so it already knows the context and now this is what I'm going to say add a calculator in the hero segment so I didn't tell it to create a landing page i didn't tell it anything other than this and let's see how well it will do of course it can make a mistake even at this point but now it has the context it knows that add a calculator in the hero segment is the message after build a landing page and it is a message after uh created a polished fully responsive red themed landing page so let's see if it was able to do this or not we should see any second now uh and looks like it wasn't able to do it let me refresh just in case and let's see the code looks like we didn't add it so let I just want to make sure that I didn't accidentally maybe do the incorrect order of loading the messages here created at descending i think that should be okay let's try again you didn't add the calculator component in the hero page add the calculator component so in the previous examp when I tried this privately off camera it worked for me so you can see that AI is sometimes a bit unpredictable but I just want to tune it you know uh we might even have to modify the prompt for this we might have to tell it you have context of all older messages you can use older messages right but you can already see a slight improvement right because right now when we asked it to create that landing page uh it's it made it red right so it understood the context but I have a feeling it is still not understanding entirely what we want let's see if this will be better and there we go we now have a very very simple calculator in our landing page great so this is exactly what we asked let's try and do make it green now just to make sure that this is the last message it sees right i want I'm okay with adding state i just don't want to make it so that it conf it's confused about what is the latest message so let's follow along in the running here so yes make it green is the first message in the array here maybe that should be the opposite i don't know because maybe it's now thinking that this the last message in the array is the newest one and let's see the coding agent i think the coding agent understands the same thing maybe or not yeah in here it also the last message here is build a landing page so I keep thinking that maybe or maybe not yeah you can see that it preserved the fact that it's a landing page it added the calculator and it ma changed it green so obviously now it understands what we are doing so I'm going to go ahead and add a little to-do here to-do change to ascending if AI does not understand what is the latest message but I think that it works pretty well i think that it understands that make it green refers to the landing page which I scolded it for because it didn't add the calculator so now it has both the calculator and it is green and I think that's exactly what we wanted so let's try and just do one more time make sure to use separate component files and while this is happening uh let's go ahead and do the following i want you to visit my uh public assets folder or the source code you can use the link in the description or the link you can see on the screen and in here I added a new file called additional prompts and in here I have the response prompt and the fragment title prompt so go ahead and copy this entire file go inside of your prompt.ts and at the end of it or if it's easier you know at the top just add those two and export both of them so export the fragment title and export the response prompt we're now going to use this to create two more agents so they create better responses and so they create a proper name here so let's see what it did there we go so it understood the context it it seems to again made it red uh I keep thinking that the way we are loading these previous messages maybe isn't perfect so you're going to have to tweak that a little bit or maybe you can somehow um maybe you can somehow modify it so that it knows you can add it in the content like maybe let's see I'm thinking of keeping a track of the index and then maybe we can modify the content and like say first message and then the message content like something like that and then maybe In here we can keep track of index and then replace this with the index for example maybe that can instruct it better to understand what's going on but uh what's important is that it at least understands the last message right that's what I want to make sure so I just told it to use separate components and that's exactly what it did it preserved the fact that it's a landing page but it made it uh into separate components let's do make it green or let's do make it yellow this time you know keep testing it make sure that it's listening to you and you can play around with changing the order here you can use that idea that I told you uh you can even explore you know in justest documentation about the state maybe in there we can find something uh I will of course research off camera and in the next chapter I will tell you more information if I find out anything new but what I want to do now is the following in the function here after the network finishes so right here after we get the result I want to go ahead and I want to do uh the following so I want to create an agent called fragment title generator and that will be create agent like this and let me just see I already forgot how do we create agents so the name will be something and then the description and then the system and then model okay so I will just copy this let's add it all over here so the name will be fragment title generator a description will be a fragment title generator and for the model we can use open AI and you can use a cheaper model you can use 4.0 for example and you can remove the default parameters here so in here use a cheaper model because this will just generate text and in here go ahead and use the fragment title prompt which we just added and also now import the response prompt so let's go ahead and use this now after this go ahead and copy it and now this will be response generator change this to be response generator and a response generator and change the system here uh to be response prompt and now you're going to define two outputs the first output here will be t uh fragment title await fragment title generator run and inside of here you will pass the result state data summary and then you're going to copy this and this will be response response generator from the same thing and then you're going to go inside of save result and for the fragment title go ahead and do the following fragment title dot uh first in the array dot type is equal to text fragment title first in the array dot content otherwise just fragment like this and let me just see content is this um okay let me just build a little function uh so we don't have to do this in one file so we have fragment title output and we have response output here so I'm going to just collapse this and then in here I'm going to do con generate fragment title and I will do if fragment title output type is not equal first in the array of course the text return fragment ment otherwise let's go ahead and do if fragment title generator first in the array content and let's check maybe if is array can I do this uh array is array I think fragment title output because this can be an array Okay then let's return fragment title output first in the array.content.m map text join like this so basically this should always return a string and otherwise just return in the else here just return the content and let me just see so this is a type of string here uh and well you can just add another safety one fragment And okay but this is unreachable so I don't know why exactly uh string is not uh okay yeah my bad and now go ahead and copy this and call this generate response and basically the same thing so response output and in here we're going to just set the default to be here you go otherwise it can be this and now when we have those two in here we can put generate fragment title and in the content we can do generate response there we go and this should now improve uh our app so let's see if that is uh true or not so I'm going to do build a let's actually start a new project just to make sure everything is clear so build a calculator app like this and let's follow the ingest to see if we're going to mess something up or not i mean technically I don't think it will ever be an array of items that we're going to have to join like this it will almost always certainly be just this but uh yeah I guess we're trying it out so we successfully did this fragment title and we successfully did response generation so let's see what it came up with there we go here's what I built for you a snazzy calculator app with a sleek responsive design and we have a name this time for the fragment calculator app so that's what I wanted us to achieve right if you don't want this you don't have to use it i mean the app worked just fine before this so if this for some reason messes up your app you don't have to use it of course I just thought it would be you know fun to add that as well and you can definitely write this in a better way i mean starting with the fact that we can just do con title and just make it this so let's do output and just make it this like so there we go this is already better and then you can do the same thing here con output change this to this and then replace all instances here there we go and you can probably also just use a single function because it's exactly the same so let's maybe do parse uh agent output and in here let's go ahead and see this is a type of uh message or array so let's try value message array like that and then can I just use value con output value first in the array yeah that works as well so parse agent output then is the only function you need and you can then put it maybe at the top of the file and we are later going to move it to libs so basically parse agent output and in here it accepts the value which is a message which is an array the message is a type of message from agent kit and now that we have parse agent output let's go down here and keep the fragment title generator keep the response generator keep the two outputs and remove generate response function and now what you're just going to do is parse how did I call the function uh parse agent output and in here you're going to parse response output and in here you're going to pass fragment title output there we go and then you can move this function to utils here in the ingest so export const parse agent output and import message from inent uh inest kit here there we go then you can remove it from here find some place you're using it and then there we go import from utils like this and let's just do a sanity check here uh make the calculator use glossy glassy design or something like that the only thing I'm trying to do here is again confirm it can kind of understand the context of my previous messages and that it will give me a nice response with a name for my fragment so we can follow again inside of the running here to make sure that's what's happening there we go fragment title generator response generator and let's see here's what I built for you a sleek glassy design calculator app with a modern twist very cool so it understood that we just wanted a glassy design on top of our previous app amazing i'm very very satisfied with this uh and I think that marks the end of this chapter as always you know your app worked just fine up until this point so don't let uh this ruin your project if you don't like it or you know feel free to research a bit yourself about whether this should be descending ascending uh and if this is failing for whatever reason the fragment title generator and the response generator you can also remove them you don't need them and make sure to just use a cheaper model here simply because you can even use an entirely new model you know like uh Gemini Grock whatever because we are not calling any tools here so just make sure this is something cheap so it doesn't spend your credits for no reason when it's just generating some text uh amazing so 18 agent memory let's go ahead and review that i'm opening a new branch here 18 agent memory i'm going to stage all of my changes 18 agent memory and I'm going to commit and I'm going to publish the branch let's go ahead and open a pull request and let's review our changes and here we have the summary we enhanced message handling by retrieving and formatting previous messages for improved agent interactions we added automated generation of concise userfriendly summary messages and short descriptive fragment titles we updated the process for saving results to use dynamically generated summaries and titles instead of static content and we introduced utility functions and structured prompt templates to standardize agent outputs and in here we have just one comment and that is that we should probably check if the value is actually valid um so yeah we could add this as well and I just noticed that we return the text fragment as placeholder even though we use this both for the response and for the fragment title so I should probably add a new value something like fallback value something like that we'll see uh nevertheless very satisfied with this one i will research before the next chapter if there's something we can do uh better when it comes to adding message history but I think this is as good as we can do right now uh great so let's go ahead and change this to main and let's synchronize our changes and we should see our new poll request being merged amazing uh I believe that marks the end of this chapter amazing amazing job and see you in the next one in this chapter we're going to go over some final bug fixes and improvements in our application this will include learning how to increase the sandbox expiration making A2B template private so no one else other than your team can use it improving our conversation history from the previous chapter and overall error handling improvement in our application so let's start by learning how to make our sandboxes last longer as always ensure that you're on your main branch and make sure you have synchronized your changes the last chapter we we merged was 18 agent memory so let's learn how to increase sandbox expiration right now inside of our application if I visit uh even this one 4 minutes ago okay this one works but if you visit anything older than 5 minutes ago it will show this the sandbox wasn't found which is not ideal if you're doing some presentation or if you're showcasing this to someone so here's what how you can increase your timeout so the sandbox life cycle it will stay alive for 5 minutes by default but you can change that using the timeout parameter now of course depending if you are on free tier or if you're on premium tier you have different limits on premium tier you can keep it alive up for 24 hours but on free tier which we are on we can keep it alive for 1 hour so for example let's find something in between let's use uh half an hour i think that's a fair amount so all you can do is go inside of your functions inside of the ingest folder and in here when you create it go ahead and do await sandbox dot set timeout and now you have to enter in milliseconds right and in here you can see so the maximum time a sandbox can can be kept alive is 24 hours for pro users and 1 hour for hobie users so if you want to you can set this and then this will be alive for an hour but keep in mind the longer you put this the more credits are you going to spend so what I recommend is you know find a middle ground this is half an hour so you can put this instead uh and you also have this util here I believe get sandbox now in here it's also important to increase it but you don't have to put half an hour here but um yeah let's be consistent and let's put half an hour here as well i just want to be careful and I don't want you to spend all your credits but perhaps maybe add this to some kind of constant here types.ts DS export const sandbox timeout and add a comment 30 minutes in milliseconds like this and then you can consistently use it in different places and you can easily change it if you change your mind let's go ahead and add that here sandbox timeout there we go so now we know how to increase our sandbox timeout and I will try this out i will do build a uh calculator app here and you know at the end of this chapter I'll I'll see if it still exists if it manages to do it without errors so let's see what else do we have to do here we just learned how to increase our sandbox expiration uh I'm going to leave this for last simply because we are in the middle of generating uh so let's go here improving conversation history so in the previous chapter we learned that we can add previous messages and we can add it to the state and I've been experimenting a bit and I think I found kind of a perfect combination so what I think we have to do is we have to limit our messages history because the longer the history the more confused the model gets at least that was my experience so I limited it to five messages i'm pretty sure it would work great with 10 messages also but five was somehow the sweet spot where I was able to keep a conversation going and do some small changes uh constantly and then the proper one is actually created at descending but make sure that you do reverse in here so it's actually ascending you need ascending here but since we're limiting the take we need to offset right you can also do the offset thing actually it is skipped in Prisma but honestly I'm not really sure if we need to do that and we can just do it descending and then just reverse them here and this in my opinion gave me much much better results than anything else so again I invite you to experiment but once I did this so I keep this at descending i limit this take to five and I reverse the formatted messages and this made the AI understand much better what I'm building so for example let me do make it glassy design i'm going to try and do this so we're going to see okay so we did that we improved the conversation history and now let's talk about error handling so uh error handling in our app currently doesn't exist outside of TRRPC procedures which means that all of our suspense can go wrong so here's what we can do we can do npm install react error boundary and let me show you my version here so package.json React error boundary 6.0.0 and then let's go ahead and find a random suspense here for example for loading the project so how about we add error boundary here and wrap it in suspense this is how you do error handling if you want to do it on a segment level nex.js also comes with its own error boundaries which are written the same as pages you would have error.tsx you can of course add this as well but I want to show you this so uh I'm not sure if this is error boundary from react error boundary okay I think it needs to be like this there we go and then in here you would add a fallback error like this so first let me just check if this is working there we go glassy design glassy calculator you can see it understands the context perfect so let me show you this now uh so first without error boundary so comment out error boundary I'm working inside of project ID let's go inside of uh projects get one here and in the query I want you to throw new tRPC error here with code bad request and refresh here And in here you can see it's loading project it's loading project oh uh yes my apologies no u uh I I'm trying to demonstrate this but I forgot we commented out error boundary and this happens then this is obviously not good we don't want this to happen that's why we have error boundaries like this so go ahead and refresh now and again it will keep trying to do this for 3 seconds for three attempts one two three and then finally it will hit the error and this is what you can then design as your error page right so what's important is that the error boundary is around suspense now this doesn't make too much sense because I am wrapping the whole page here right but imagine if course let's just remove this TRPC error from here imagine the case where I'm doing where is it UI components where I have the project header here right so let me see where do I render project header in the project view so go inside of your project view and in here we have suspense so the error boundary from react error boundary would make a lot of sense here fallback project header error like that or in here error boundary again around this suspense with the fallback messages container error so now let's say we go inside of the messages here let's go uh inside of messages get many and let me just try and do this so throw new tRPC error here code bad request so something happened here and let's go ahead and refresh here you can see that the project has loaded and you can see it's trying to load messages it's trying to load the messages until eventually it fails and since we added the boundary we only see messages container error but if you didn't have that here in the project view if you didn't wrap the error boundary let's see what would happen then so let's refresh again so it's loading messages it's loading messages and you already know what will happen the entire screen will error so just like minimizing the loading state you can use the error boundary to minimize the error state so that's what you would do right that's why we use the error boundary so I would recommend you know finding all the suspenses that you use in your project and I think these are the only three so we just added to all of them right and you can also do the following you can also add inside of source app you can add a page called error.tsx now this has to be a client component and in here make sure to call it error page don't call it error this is a reserved keyword call it error and you can return here global error you can of course design this however you want but this is useful so this right now doesn't do much but let's go ahead and do this let's go inside of project ID and let's say we forgot to wrap this error boundary here so now uh and yes uh also go to project view and comment out the error boundary here now the error the global error takes care right so that's how the global error works so if I didn't have this let me just remove it now if I didn't have this this is what would happen let's say we forgot all the inner error boundaries right this happens so this is the one thing you don't want to happen this error just looks ugly it looks like something really really broken right that's why you want to make sure that you have the inner error boundaries you want to make sure that you have your individual page error boundaries and you should also have your app error.tsx the sx simply because it is the last line of defense in case something goes wrong perfect so now let's go back inside of our messages procedures here let's just remove the throwing of the error here there we go perfect now what I want to do is I just want to go to the usage dsx here component and I'm really worried about this format duration for a simple reason dates can often cause errors and it would be very stupid if our entire app here fails just because the date is invalid so here's uh what I think we can do let's go ahead and try it so I'm going to open a function like this and let me just close it here and I'm going to open curly brackets here let me close that here and I'm going to open Actually here's what I'm going to do instead of trying to do it here I'm going to just do const reset time use memo like this make sure you added use memo from React and then inside of here what we're going to do is we're going to open the try and we're going to open catch and in here let's add an little error and let's do console error and let's do error formatting duration error like that and let's simply return soon so it will just say or maybe unknown or whatever you think is better user experience right and then in here let's return format duration and then inside interval to duration and then start new date and let's me just copy it and will be this and then we're just missing the format here there we go and in here let's add ms before next and then we can use this constant here so resets in reset time let me just check if it still works there we go resets in 29 days and 20 hours because now if you if this MS before next happens to be something like not a number there we go resets in now doesn't work and it doesn't break the page that's what I at least wanted it to happen okay perfect so now that we have this actually I mean we can try it out by doing throw new error whoops and now it should say resets in unknown basically it cannot block the page it can still allow the user to work which is what we wanted um perfect so this is very good let's see what else we have in the list here so we learned about improving the error handling and now let's talk about making our E2B template private so if you go inside of your E2B dashboard in here you can see your templates and you can see that my Vibe Nex.js test 2 is currently public that is because we have published it the reason I told you to publish it is because I personally had problems with private uh templates but what you can do is the following open your terminal go inside of sandbox templates go inside of Next.js and since inside of here we have a E2B TOML file we can easily just do E2B template unpublish you don't have to add any other flags it will read everything from here including your team ID and just confirm that you want to unpublish it and what this does is the following if you now go back here and refresh you will see that my vibe next.js test 2 is now set to private and that means that inside of the functions on the ingest here whenever someone tries to create a sandbox with that this will fail unless in their environment their E2B API key belongs to my organization so what I suggest you do now is definitely try so let's try make it red and you can see that these sandbox are still going strong so we def it definitely works what we increased the timeout for so now what I'm interested in will this still work now that I have made my template private and I think that it does since I can fetch the sandbox ID for me it happened that the sandbox ID was not able to be fetched once I changed it to private so just make sure that it still works here let's see make it red there we go and you can see how the conversation history is improved it made it glassy and red exactly what we wanted so we definitely improved the conversation history here and for me it seems to still be working if for whatever reason yours stopped working it shouldn't but you know it happened to me so maybe it will happen to you you can easily go inside of here inside of next.js and just run E2B template publish you don't need any arguments you can just press publish and then you can confirm and then from here you can go back inside of here go inside of your templates and see the status make sure it's public and you can even do that from here I think by clicking here if you want to um perfect amazing so I think that's all we wanted to fix and there is one thing left to discuss and that is let's just search for to-do instead of messages container we're using refetch interval as the live message update and I was thinking about what I should do instead of this but initially I built a project like this and it worked just fine so the thing is this is not a multiplayer chat this is a single person chat who receives responses from AI and most of the time you only send one message and then wait for the other message to uh come back and we are not just doing any kind of polling we are doing polling using the tan stack query this means that this refetch interval will ddup it will use cache it will be an extremely optimized interval and also I'm not sure if you knew this but while right now new requests are being made every 5 seconds if I change to this page requests stop being made so you don't have to worry that in the background it's constantly going to fire it is a very very optimized polling and it actually makes no problem to use in our type of application here and in fact you can even reduce it to 2 seconds if you want to this will give you a better experience and it will still be very very optimized now in case you're wondering uh okay but does inest offer any uh realtime updates they absolutely do you can go inside the documentation and read about a real time so in here you can subscribe to a channel and then from the function you can initialize uh you can publish to that channel and I explored this option but the problem was I wasn't able uh to synchronize both my Prisma messages and uh the ingest subscription messages it is absolutely possible uh and it can be a good homework for you if you want to give yourself a challenge and do that for our use case polling is more than enough so I will just remove this from here and if you want to you can move this into a constant so you can change it easily if you're using some polling in multiple places uh great amazing so I believe we are now ready to deploy i don't think there's anything else we have to do here so let's go ahead now and let's merge this so 19 bug fixes i'm going to go ahead and open a new branch 19 bug fixes i will stage all of my changes 19 bug fixes and I'm going to commit and I'm going to publish the branch uh and since these changes were very very minimal I think we can just go ahead and merge them because they were just some very small bug fixes here we can do our own review here so we added React error boundary we added global error page we added some wrappers here error boundary we added the proper sandbox timeout we properly uh reverse the messages so the conversation history is improved we use the same sandbox timeout in the utils here we reduced the refetch interval we made it safely here to fetch the reset interval and we just added some more error boundaries that's it nothing else needed here we can merge this request immediately amazing amazing job that marks the end of this chapter as always go back to your main branch here and synchronize the changes and then confirm in the source control that you just merged 19 bug fixes amazing amazing job and see you in the next chapter where we are going to deploy our app in this chapter we're going to go ahead and deploy our app to Verscell this will include the initial deployment after that we will obtain our app URL then we have to update our environment variables with that new URL and we have to redeploy and after that we have to connect inest to our versel project and redeploy once more and after that we are ready to test the app so let's start with step one deploy to versel so make sure that you are on your main branch and make sure the last one was 19 bug fixes you can synchronize your changes if you haven't already and at this point you can also shut down your terminal no point to have this running while you are deploying now let's go ahead and make sure that you have a GitHub repository right i don't know if you followed the Git workflow through this tutorial but if you have then you have a GitHub repository so head to Verscell and click add new project and in here if you are connected with GitHub you have your project right here i'm going to click import and then I'm going to open environment variables and in here I'm going to go into environment and I'm going to copy all of them and then I'm just going to paste them inside so database URL next public app URL open AI API key E2B key and all of these other ones and let's click deploy we are now going to see the result of this perhaps it will succeed from the first try or maybe it will fail i'm going to pause the screen and show you the result and my deployment failed with a bunch of errors and I forgot about the first rule of deploying to Verscell and that is that you should try building locally first so you don't waste time with failed Verscell deployments and we also forgot about one more important thing and that is that when we deploy the versel we need to add a post install script so let's go ahead and do a post install script and add it to our package.json here let me just add it here let me just check where do we add it in the scripts okay so post install prisma generate like this so now I'm going to go ahead and do npm run build locally and I'm going to see if I have any more errors and I'm going to show you how do you trigger a deployment again if your initial one failed basically from here you have buttons to go to project or to inspect deployment you can click whichever one you like uh and from here you basically have your project vibe you can click here and there we go you have deployments the first deployment was failed and now the way another deployment will be triggered is simply whenever it notices a new push in the GitHub so now let's go ahead and see what we have here so I seem to keep having these errors seemingly coming from here these errors seem to be coming from source generated so it seems to be linting this folder when it should not be linting this folder so I'm going to look into how I can prevent the app uh the build from looking at the generated folder right here and I'll tell you what I find okay I have managed to find the combination which enables npm run build so just to remind you the last change we did was we added post install to the scripts we still need this regardless so there are different ways you can fix the failing lint because the failing linting is what's going on here one solution is to go to the next config here and add slint and enable ignore during builds now this isn't exactly recommended but you can see that once you add this slint will not fire during the build process or at least it won't fire in production but you can see that in here it works perfectly fine now well whereas if you don't have this feature and you try mpm run build it is going to fail because it will try to lint our source generated uh folder there we go but I don't really recommend this simply because uh that will turn off linting for your entire project during the build and there's no need for that because what we can do instead is we can go inside of eslint.lint.config.mjs config.mjs here and we can open ignores and in here we can target asterisk asterisk forward slashgenerated and then everything inside of a generated folder so basically ignore wherever you can find the generated folder and then everything inside and I feel like this is a little bit better solution simply because we are still going to lint the rest of our project but we are not going to lint the source generated one so if you try this now it should work let's wait a second and there we go since the linting has passed everything else seems to be working just fine so try for yourself and choose one that works right if this works for you sure then use this but I will recommend doing this if possible for you in the estate config mjs perfect once you have these two let's go ahead and let's merge them uh like this and let's go ahead and add deployment here we can do this in the main branch we don't need to branch out and then just go ahead and synchronize the changes in case you branched out no problem just merge the branch to the main and once it detects a new branch to the main uh it is going to uh trigger a redeployment there we go so in here you can see that it automatically detected a new push and it's going to deploy so let's see if it succeeds this time and here we have it this time the build succeeded and now we have our app deployed so you can see it's still running some final uh things here but down here you can see that we assigned a custom domain and we have the deployment summary so what I care about is the custom domain so what I recommend you do is you click on vibe up here and go inside of overview and in here you will find all of your domains do not use the deployment domain use this one the shortest one that is the domain of your project you can go ahead and visit it if you want to and what I want you to do is I want you to copy the URL that you have and I want you to go back to Verscell and then go inside of settings environment variables and in here find next public app URL and you now have to modify this to be your new app just remove the forward slash like this and click save and after you do this you can see a prompt here to redeploy so you can click it if you don't get the prompt to redeploy you can manually go in your deployments and then you can select the last one and you can click redeploy so let me just check if uh I'm not sure if redeployment is now happening or not so I will just click redeploy myself and just confirm so every time you change environment variables you have to redeploy so I'm going to pause wait for the redeployment and then we have to connect inest to this versel project and here we have the successful uh redeployment here so now what I suggest you do is just try and use your application if possible wait out till this shows a success message as well there we go and then go to your main URL here always use the main URL and try something simple like signing in so I'm going to go ahead and use my account here and I will try to just create a simple project so I will go ahead and do uh you can see that all of our projects are saved so our TRPC is working here let's try clicking on one of these and let's try sending a message so I would add test here and what should happen here is the following you can see the message my message was generated but injust was unable to be fired that's because we need to connect inest to production so this will actually never finish let's go ahead and do that now so use the link you can see on the screen or the link in the description to visit ingest and go ahead and sign up i suggest using GitHub simply so you always have access to your repositories if needed and then once you enter here down here at the bottom you can choose to switch organization i recommend creating a new organization so I'm going to call this Vibe and I will click create organization and I'm not going to invite any members now and let's go ahead and click on apps here and let's go ahead and just find oh sorry integrations i think this is what I'm looking for and let's click on Versel here to connect let's click connect Verscell to ingest and click on add integration here and I'm I have multiple accounts so I'm going to select this one where I just deployed the project and I will click continue and in here go ahead and find your new project so let me just find Vibe here it is select it and click save configuration right here and click continue to the ingest uh Verscell dashboard and now somewhere in here you have all of your Versel projects and you should now find Vibe and you can see it says enabled but in here it says deployment protection is enabled ingest may not be able to communicate with your application by default let's go ahead and click more here and basically what we have to do is we have to configure protection bypass so in here let's go ahead and uh I'm never sure how to properly access this so don't worry I will tell you the exact steps in the versel dashboard but let me just see does this take me to Verscel it does take me to Versel here basically I think this is where I need to go let's go to versel and let's select our new project here let's go inside of settings and let's go inside of deployment protection here it is so go inside of your vibe settings deployment protection and in here let's go ahead and let's do protection bypass for automation so I think this is what we need so let's click add secret you don't need to add any value and just click save and then in here you can copy this bypass secret and then let me go ahead and go back and click click on configure here and if I remember this correctly you should now have deployment protection key that you can add here and click save configuration there we go so now inest should be able to access your uh Versell application and let's go ahead and do one more thing here so now I want to go back here to production and in here there we go you can see that my app was already found vibe development on Versel so this is a good sign and it has found one function code agent so I think that this means that it's running successfully i'm just not 100% sure i keep thinking that I need to redeploy um so h let's see let's try it out if it doesn't work it means we have to redeploy so go to your uh deployed URL this time and let's go ahead and do build a calculator app let's see if that will work and let's go inside of Ingest here ingest cloud inest runs and let's see if a new run will appear and the new run is right here that would mean that we successfully deployed our project and we connected inest to deployed instance and looks like we didn't need to redeploy at all let's just go ahead and wait to see uh if this will actually work if there are any issues we have to fix and then we're going to be able to wrap up this project and here I have the result so it seems to be working this is entirely in production so my URL is vibe-bond.cell.app and if you check the cloud here there we go it seems to be working uh if it still says running just do a refresh and it should update the status here we go amazing amazing job you finished an amazing project i had so much fun building this uh I I'm sure you did as well make sure to test your app you know make sure everything's working sometimes the easiest fix can actually be for you to redeploy again and you can see there was obviously a deployment that was running the entire time so perhaps this happened automatically when we connected inest you can always you know click here and click redeploy and that will just redeploy your latest version and now in your settings environment variables you should now see inest event keys and signing keys so that's the trick that's what made it work amazing amazing job i think this was an absolutely amazing project good job see you in the next tutorial and thank you so so much for watching 